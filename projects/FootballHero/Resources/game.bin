{"scripts.views.PredTotalConfirmScene":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\n\n\nlocal mWidget\n\nfunction loadFrame()\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/PredFinalConfirm.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    mWidget:addTouchEventListener( bgEventHandler )\n    SceneManager.addWidget(widget)\n\n\tinitContent()\n\n    local confirmBt = widget:getChildByName(\"confirm\")\n    confirmBt:addTouchEventListener( confirmEventHandler )\n\n    local cancelBt = widget:getChildByName(\"cancel\")\n    cancelBt:addTouchEventListener( cancelEventHandler )\n\n    local facebook = mWidget:getChildByName(\"facebook\")\n    facebook:addTouchEventListener( facebookEventHandler )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction bgEventHandler( sender, eventType )\n\t-- Do nothing, just block\nend\n\nfunction confirmEventHandler( sender, eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n\t\tlocal facebook = tolua.cast( mWidget:getChildByName(\"facebook\"), \"CheckBox\" )\n\t\tLogic:setPredictionMetadata( \"\", facebook:getSelectedState() )\n\t    EventManager:postEvent( Event.Do_Post_Predictions )\n\tend\nend\n\nfunction cancelEventHandler( sender, eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n\t\tLogic:resetPredictions()\n    \tEventManager:postEvent( Event.Enter_Match_List )\n\tend\nend\n\nfunction facebookEventHandler( sender, eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n\t\tlocal facebook = tolua.cast( mWidget:getChildByName(\"facebook\"), \"CheckBox\" )\n\t\tif facebook:getSelectedState() == false and Logic:getFbId() == false then\n\t\t\tlocal successHandler = function()\n\t\t\t\t-- Nothing to do.\n\t\t\tend\n\t\t\tlocal failedHandler = function( selectedState )\n\t\t\t\tfacebook:setSelectedState( selectedState )\n\t\t\tend\n\n\t\t\tEventManager:postEvent( Event.Do_FB_Connect_With_User, { successHandler, failedHandler } )\n\t\tend\n\tend\nend\n\nfunction initContent()\n\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"resultContainer\"), \"ScrollView\" )\n    contentContainer:removeAllChildrenWithCleanup( true )\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n    local contentHeight = 0\n\n    local predictions = Logic:getPredictions()\n\tfor i = 1, predictions:getSize() do\n\t\tlocal content = SceneManager.widgetFromJsonFile(\"scenes/PredFinalConfirmContent.json\")\n\t\tif i == 1 then\n\t\t\tlocal bg = tolua.cast( content:getChildByName(\"bg\"), \"ImageView\" )\n\t\t\tbg:loadTexture( \"scenes/PredictionConfirm/bg-1.png\" )\n\t\tend\n\n\t\tlocal coupon = predictions:get( i )\n\t\tlocal question = tolua.cast( content:getChildByName(\"Question\"), \"Label\" )\n\t\tlocal reward = tolua.cast( content:getChildByName(\"Reward\"), \"Label\" )\n\t\tlocal stake = tolua.cast( content:getChildByName(\"stake\"), \"Label\" )\n\t\tlocal answerIcon = tolua.cast( content:getChildByName(\"answerIcon\"), \"ImageView\" )\n\n\t\tquestion:setFontName( \"Newgtbxc\" )\n\t\treward:setFontName( \"Newgtbxc\" )\n\n\t\tquestion:setText( coupon[\"Answer\"] )\n\t\treward:setText( string.format( reward:getStringValue(), coupon[\"Reward\"] ) )\n\t\tstake:setText( string.format( stake:getStringValue(), coupon[\"Stake\"] ) )\n\t\tanswerIcon:loadTexture( coupon[\"AnswerIcon\"] )\n\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n\tend\n\n\t-- Update the size of the scroll view so that it locate just above the facebook button.\n\tlocal originSize = contentContainer:getSize()\n\tif originSize.height > contentHeight then\n\t\tcontentContainer:setSize( CCSize:new( originSize.width, contentHeight ) )\n\t\tcontentContainer:setTouchEnabled( false )\n\tend\n\n\tcontentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n    local layout = tolua.cast( contentContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n","scripts.data.MarketsForGameData":"module(..., package.seeall)\n\nlocal MarketConfig = require(\"scripts.config.Market\")\n\nMarketsForGameData = {}\n\n--[[\n[\n    {\n        \"marketTypeId\": 25,\n        \"Line\": null,\n        \"odds\": [\n            {\n                \"Id\": 2303086,\n                \"Odd\": 4,\n                \"OutcomeUIPosition\": 1\n            },\n            {\n                \"Id\": 2303100,\n                \"Odd\": 1.83,\n                \"OutcomeUIPosition\": 2\n            }\n        ]\n    },\n    {\n        \"marketTypeId\": 26,\n        \"Line\": 2.5,\n        \"odds\": [\n            {\n                \"Id\": 2303110,\n                \"Odd\": 1.7,\n                \"OutcomeUIPosition\": 1\n            },\n            {\n                \"Id\": 2303116,\n                \"Odd\": 2.1,\n                \"OutcomeUIPosition\": 2\n            }\n        ]\n    },\n    {\n        \"marketTypeId\": 27,\n        \"Line\": 0.5,\n        \"odds\": [\n            {\n                \"Id\": 2397661,\n                \"Odd\": 2.02,\n                \"OutcomeUIPosition\": 1\n            },\n            {\n                \"Id\": 2397666,\n                \"Odd\": 1.86,\n                \"OutcomeUIPosition\": 2\n            }\n        ]\n    }\n]\n--]]\n\nfunction MarketsForGameData:new( list )\n\tlocal match = nil\n\tlocal matchIndex = 0\n\tfor k, v in pairs( list ) do\n\t\tlocal market = v\n\t\tif market[\"marketTypeId\"] == MarketConfig.MARKET_TYPE_MATCH then\n\t\t\tmatch = market\n\t\t\tmatchIndex = k\n\t\tend\n\tend\n\tif match ~= nil then\n\t\ttable.remove( list, matchIndex )\n\tend\n\n\tlocal obj = {\n\t\tmatchMarket = match,\n\t\tmarketList = list\n\t}\n\n\tsetmetatable(obj, self)\n    self.__index = self\n    \n    obj.__newindex = function(t, k, v) assert(false, \"MatchListData--\"..k .. \"__newindex not exist\") end\n    \n    return obj \nend\n\nfunction MarketsForGameData:getMatchMarket()\n\treturn self.matchMarket\nend\n\nfunction MarketsForGameData:getNum()\n\treturn table.getn( self.marketList )\nend\n\nfunction MarketsForGameData:getMarketAt( index )\n\treturn self.marketList[index]\nend\n\n-- Get the market info which contains the given couponId\nfunction MarketsForGameData:getMarketInfoByCouponId( couponId )\n    for k, v in pairs( self.matchMarket[\"odds\"] ) do\n        local odds = v\n        if odds[\"Id\"] == couponId then\n            return self.matchMarket\n        end\n    end\n\n    for i = 1, self:getNum() do\n        local market = self:getMarketAt(i)\n        for k, v in pairs( market[\"odds\"] ) do\n            local odds = v\n            if odds[\"Id\"] == couponId then\n                return market\n            end\n        end\n    end\n\n    return nil\nend\n\n-- Getters for inner data structure\n\nfunction getMarketType( market )\n    return market[\"marketTypeId\"]\nend\n\nfunction getMarketLine( market )\n    return market[\"Line\"]\nend\n\nfunction getOddConfigForType( market, oddsType )\n    for k, v in pairs( market[\"odds\"] ) do\n        local odds = v\n        if odds[\"OutcomeUIPosition\"] == oddsType then\n            return odds\n        end\n    end\n    return nil\nend\n\nfunction getOddIdForType( market, oddsType )\n    local oddsConfig = getOddConfigForType( market, oddsType )\n    \n    if oddsConfig ~= nil then\n        return oddsConfig[\"Id\"]\n    end\n    return 0\nend\n\nfunction getOddsForType( market, oddsType )\n\tlocal oddsConfig = getOddConfigForType( market, oddsType )\n\t\n\tif oddsConfig ~= nil then\n\t\treturn oddsConfig[\"Odd\"] * 1000\n\tend\n\treturn 0\nend\n","scripts.data.CompetitionDetail":"module(..., package.seeall)\n\nCompetitionDetail = {}\n\n--[[\n\n{\n\n   \"LeaderboardUserBaseDtos\": [\n\n      {\n\n         \"Roi\": 0,\n\n         \"Id\": 3,\n\n         \"DisplayName\": null,\n\n         \"NumberOfCoupons\": 0,\n\n         \"PictureUrl\": null\n\n      }\n\n   ],\n\n   \"CompetitionInfoDTO\": {\n\n      \"Id\": 3,\n\n      \"Name\": \"2222\",\n\n      \"Description\": \"2222\",\n\n      \"StartTimeStamp\": \"2014-06-20T08:30:36\",\n\n      \"EndTimeStamp\": \"2014-09-11T16:00:00\",\n\n      \"JoinToken\":\"5i7o0izr\",\n\n      \"Open\": true,\n\n      \"OwningUserName\": \"Test001\"\n\n   }\n\n}\n\n--]]\n\n\nfunction CompetitionDetail:new( detail )\n   local obj = {\n      leaderboardUserBaseDtos = detail.LeaderboardUserBaseDtos,\n      name = detail.CompetitionInfoDTO.Name,\n      description = detail.CompetitionInfoDTO.Description,\n      startTimeStamp = detail.CompetitionInfoDTO.StartTimeStamp,\n      endTimeStamp = detail.CompetitionInfoDTO.EndTimeStamp,\n      joinToken = detail.CompetitionInfoDTO.JoinToken,\n      open = detail.CompetitionInfoDTO.Open,\n      owningUserName = detail.CompetitionInfoDTO.OwningUserName,\n   }\n\n   setmetatable(obj, self)\n    self.__index = self\n    \n    obj.__newindex = function(t, k, v) assert(false, \"CompetitionDetail--\"..k .. \"__newindex not exist\") end\n    \n    return obj \nend\n\nfunction CompetitionDetail:getDto()\n   return self.leaderboardUserBaseDtos\nend\n\nfunction CompetitionDetail:getName()\n   return self.name\nend\n\nfunction CompetitionDetail:getDescription()\n   return self.description\nend\n\nfunction CompetitionDetail:getStartTime()\n   return self.startTimeStamp\nend\n\nfunction CompetitionDetail:getEndTime()\n   return self.endTimeStamp\nend\n\nfunction CompetitionDetail:getJoinToken()\n   return self.joinToken\nend\n\nfunction CompetitionDetail:getOpen()\n   return self.open\nend\n\nfunction CompetitionDetail:getOwningUserName()\n   return self.owningUserName\nend\n","scripts.views.MatchPredictionScene":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal TeamConfig = require(\"scripts.config.Team\")\nlocal MarketConfig = require(\"scripts.config.Market\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal MarketsForGameData = require(\"scripts.data.MarketsForGameData\")\n\nlocal mWidget\nlocal mMatch\nlocal mMarketsData\n\nlocal MIN_MOVE_DISTANCE = 100\nlocal SCALE_BASE = 0.8\nlocal SCALE_UP_OFFSET_MAX = 0.2\nlocal SCALE_DOWN_OFFSET_MAX = -0.2\nlocal OPACITY = 255\n\n\nfunction loadFrame()\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/MatchPrediction.json\")\n    mMatch = Logic:getSelectedMatch()\n    mMarketsData = Logic:getCurMarketInfo():getMatchMarket()\n\n    local backBt = widget:getChildByName(\"Back\")\n    backBt:addTouchEventListener( backEventHandler )\n\n    helperInitMatchInfo( widget )\n\n    widget:addTouchEventListener( onFrameTouch )\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget(widget)\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction selectTeam1Win()\n    local team1 = tolua.cast( mWidget:getChildByName(\"team1\"), \"ImageView\" )\n    makePrediction(\n        MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION ),\n        MarketsForGameData.getOddIdForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION ),\n        TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) )..\" to win.\",\n        team1:getTextureFile() )\nend\n\nfunction selectTeam2Win()\n    local team2 = tolua.cast( mWidget:getChildByName(\"team2\"), \"ImageView\" )\n    makePrediction(\n        MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION ),\n        MarketsForGameData.getOddIdForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION ),\n        TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) )..\" to win.\",\n        team2:getTextureFile() )\nend\n\nfunction backEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        --EventManager:postEvent( Event.Enter_Match_List )\n        EventManager:popHistory()\n    end\nend\n\nfunction makePrediction( rewards, oddId, answer, answerIcon )\n    local seqArray = CCArray:create()\n    seqArray:addObject( CCDelayTime:create( 0.1 ) )\n    seqArray:addObject( CCCallFuncN:create( function()\n        --EventManager:postEvent( Event.Enter_Prediction_Confirm, { answer, rewards, oddId, answerIcon } )\n\n        Logic:addPrediction( oddId, answer, rewards, answerIcon )\n        EventManager:postEvent( Event.Enter_Next_Prediction )\n    end ) )\n\n    mWidget:runAction( CCSequence:create( seqArray ) )\n    \nend\n\nfunction helperUpdatePoint( content )\n    local point = Logic:getPoint()\n    local pointLabel = tolua.cast( content:getChildByName(\"myPoint\"), \"Label\" )\n    pointLabel:setText( point )\nend\n\nfunction helperInitMatchInfo( content, marketsData )\n    local team1 = tolua.cast( content:getChildByName(\"team1\"), \"ImageView\" )\n    local team2 = tolua.cast( content:getChildByName(\"team2\"), \"ImageView\" )\n    local team1Name = tolua.cast( content:getChildByName(\"team1Name\"), \"Label\" )\n    local team2Name = tolua.cast( content:getChildByName(\"team2Name\"), \"Label\" )\n    local team1WinPoint = tolua.cast( team1:getChildByName(\"team1WinPoint\"), \"Label\" )\n    local team2WinPoint = tolua.cast( team2:getChildByName(\"team2WinPoint\"), \"Label\" )\n    local stake = tolua.cast( content:getChildByName(\"stake\"), \"Label\" )\n    local balance = tolua.cast( content:getChildByName(\"balance\"), \"Label\" )\n\n    team1:loadTexture( TeamConfig.getLogo( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) ) )\n    team2:loadTexture( TeamConfig.getLogo( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) ) )\n    team1Name:setText( TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) ) )\n    team2Name:setText( TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) ) )\n    team1WinPoint:setText( MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION )..\" points\" )\n    team2WinPoint:setText( MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION )..\" points\" )\n\n    stake:setText( string.format( stake:getStringValue(), Constants.STAKE ) )\n    balance:setText( string.format( balance:getStringValue(), Logic:getBalance() - Logic:getUncommitedBalance() ) )\nend\n\n\nfunction onFrameTouch( sender, eventType )\n    local team1 = tolua.cast( mWidget:getChildByName(\"team1\"), \"ImageView\" )\n    local team2 = tolua.cast( mWidget:getChildByName(\"team2\"), \"ImageView\" )\n    if eventType == TOUCH_EVENT_ENDED then\n        local touchBeginPoint = sender:getTouchStartPos()\n        local touchEndPoint = sender:getTouchEndPos()\n        if touchBeginPoint.x - touchEndPoint.x > MIN_MOVE_DISTANCE then\n            -- Swap to Left\n            selectTeam2Win()\n        elseif touchBeginPoint.x - touchEndPoint.x < MIN_MOVE_DISTANCE * (-1) then\n            -- Swap to Right\n            selectTeam1Win()\n        else\n            team1:setScale( SCALE_BASE )\n            team2:setScale( SCALE_BASE )\n            team1:setOpacity( OPACITY )\n            team2:setOpacity( OPACITY )\n        end\n    elseif eventType == TOUCH_EVENT_MOVED then\n        local touchBeginPoint = sender:getTouchStartPos()\n        local touchMovPoint = sender:getTouchMovePos()\n\n        local scalePercentage = math.abs( touchBeginPoint.x - touchMovPoint.x ) / MIN_MOVE_DISTANCE\n        if scalePercentage > 1 then\n            scalePercentage = 1\n        end\n        if touchBeginPoint.x - touchMovPoint.x > 0 then\n            team2:setScale( scalePercentage * SCALE_UP_OFFSET_MAX + SCALE_BASE )\n            team1:setScale( scalePercentage * SCALE_DOWN_OFFSET_MAX + SCALE_BASE )\n            team2:setOpacity( OPACITY )\n            team1:setOpacity( OPACITY / 3 )\n        else\n            team1:setScale( scalePercentage * SCALE_UP_OFFSET_MAX + SCALE_BASE )\n            team2:setScale( scalePercentage * SCALE_DOWN_OFFSET_MAX + SCALE_BASE )\n            team1:setOpacity( OPACITY )\n            team2:setOpacity( OPACITY / 3 )\n        end\n    end\nend\n","scripts.actions.LoadMoreInLeaderboardAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal LeaderboardConfig = require(\"scripts.config.Leaderboard\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\nlocal mLeaderboardId\nlocal mSubType\n\nfunction action( param )\n\tmLeaderboardId = param[1]\n\tmSubType = param[2]\n\tlocal step = param[3]\n\n\tlocal url = RequestUtils.GET_MAIN_LEADERBOARD_REST_CALL..\"?sortType=\"..mSubType[\"sortType\"]..\"&step=\"..step\n\n    local requestInfo = {}\n    requestInfo.requestData = \"\"\n    requestInfo.url = url\n\n\tlocal handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( response )\n    local leaderboardListScene = require(\"scripts.views.LeaderboardListScene\")\n    leaderboardListScene.loadMoreContent( response )\nend\n","scripts.config.Country":"module(..., package.seeall)\n\nlocal JsonConfigReader = require(\"scripts.config.JsonConfigReader\")\nlocal LeagueConfig = require(\"scripts.config.League\")\nlocal Constants = require(\"scripts.Constants\")\nlocal DoLogReport = require(\"scripts.actions.DoLogReport\")\n\n\nlocal FILE_NAME = \"config/countries.txt\"\nlocal mConfig = {}\nlocal mIndex = {}\nlocal mConfigNum = 0\n\nfunction init()\n\tif mConfigNum > 0 then \n\t\treturn\n\tend\n\tprint(\"Read Country config.\")\n\tlocal filter = function( v )\n\t\treturn v[\"isActive\"]\n\tend\n\tmConfig, mConfigNum, mIndex = JsonConfigReader.read( FILE_NAME, \"Id\", filter )\n\tprint( \"Read active country number: \"..mConfigNum )\n\n\tfor i = 1, LeagueConfig.getConfigNum() do\n\t\tlocal countryId = LeagueConfig.getCountryId( i )\n\t\tif getConfigIdByKey( countryId ) ~= nil then\n\t\t\taddLeague( getConfigIdByKey( countryId ), i )\n\t\tend\n\tend\n\n\tfor i = 1, getConfigNum() do\n\t\tif getLeagueList( i ) == nil then\n\t\t\tassert( \"County \"..getCountryName( i )..\" has no league.\" )\n\t\telse\n\t\t\tprint( \"County \"..getCountryName( i )..\" has \"..table.getn( getLeagueList( i ) )..\" leagues.\" )\n\t\tend\n\tend\nend\n\nfunction getConfig( id )\n\tassert( mConfig[id] ~= nil, FILE_NAME..\" dosen't has \"..id )\n\n\treturn mConfig[id]\nend\n\nfunction getConfigIdByKey( key )\n\tif mIndex[key] == nil then\n\t\tlocal log = FILE_NAME..\" dosen't has \"..key\n\t\tprint( log )\n\t\tDoLogReport.reportConfigError( log )\n\t\treturn nil\n\tend\n\n\treturn mIndex[key]\nend\n\nfunction getConfigNum()\n\treturn mConfigNum\nend\n\n--[[\n\tProvide additional getters.\n--]]\n\nfunction getCountryCode( id )\n\tlocal config = getConfig( id )\n\treturn config[\"countryCode\"]\nend\n\nfunction getCountryName( id )\n\tlocal config = getConfig( id )\n\tif config[\"countryName\"] ~= nil then\n\t\treturn config[\"countryName\"]\n\telse\n\t\treturn config[\"countryCode\"]\n\tend\nend\n\nfunction isActive( id )\n\tlocal config = getConfig( id )\n\treturn config[\"isActive\"]\nend\n\nfunction addLeague( id, leagueId )\n\tlocal config = getConfig( id )\n\tif config[\"leagueList\"] == nil then\n\t\tconfig[\"leagueList\"] = {}\n\tend\n\ttable.insert( config[\"leagueList\"], leagueId )\nend\n\nfunction getLeagueList( id )\n\tlocal config = getConfig( id )\n\treturn config[\"leagueList\"]\nend\n\nfunction getLogo( id )\n\tlocal config = getConfig( id )\n\n\tif config ~= nil then\n\t\tlocal fileUtils = CCFileUtils:sharedFileUtils()\n\t\tlocal filePath = fileUtils:fullPathForFilename( Constants.COUNTRY_IMAGE_PATH..config[\"Id\"]..\".png\" )\n\t\tprint( \"Countries \"..filePath )\n\t\tif fileUtils:isFileExist( filePath ) then\n\t\t\treturn Constants.COUNTRY_IMAGE_PATH..config[\"Id\"]..\".png\"\n\t\telse\n\t\t\treturn Constants.COUNTRY_IMAGE_PATH..\"default.png\"\n\t\tend\n\telse\n\t\treturn Constants.COUNTRY_IMAGE_PATH..\"default.png\"\n\tend\nend\n\nfunction getAllLeagues()\n\tlocal leagues = {}\n\n    for i = 1, getConfigNum() do\n        local list = getLeagueList( i )\n        for j = 1, table.getn( list ) do\n            table.insert( leagues, list[j] )\n        end\n    end\n\n    return leagues\nend\n\ninit()\n","scripts.views.SelFavTeamScene":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal LeagueConfig = require(\"scripts.config.League\")\nlocal TeamConfig = require(\"scripts.config.Team\")\nlocal LeagueTeamConfig = require(\"scripts.config.LeagueTeams\")\nlocal LeagueListScene = require(\"scripts.views.LeagueListScene\")\n\nlocal TEAM_NUM = 20\nlocal mWidget\nlocal mDisplayLeagueId\nlocal mLeagueId\nlocal mTeamId\n\nfunction loadFrame()\n\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/FavouriteTeam.json\")\n\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.addWidget( widget )\n\n    LeagueListScene.loadFrame( \"scenes/FavouriteCountryContent.json\", \"scenes/FavouriteLeagueContent.json\", \n        tolua.cast( mWidget:getChildByName(\"countryList\"), \"ScrollView\" ), leagueSelected )\n\n    -- Disable the ok button\n    local okBt = widget:getChildByName(\"ok\")\n    okBt:addTouchEventListener( okEventHandler )\n    okBt:setBright( false )\n\n    -- Set the default one.\n    leagueSelected( 1 )\n\n    local leagueName = tolua.cast( mWidget:getChildByName(\"leagueName\"), \"Label\" )\n    leagueName:setText( \"Please select your favourite team.\" )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction okEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        print(\"Favourite Team is: \"..mTeamId..\" in league: \"..mLeagueId)\n        EventManager:postEvent( Event.Do_Post_Fav_Team, { mTeamId, mLeagueId } )\n    end\nend\n\nfunction leagueSelected( leagueId )\n    mDisplayLeagueId = LeagueConfig.getConfigId( leagueId )\n    print( \"leagueSelected: \"..mDisplayLeagueId )\n--[[\n    -- Update the country list\n    local countryContainer = tolua.cast( mWidget:getChildByName(\"countryList\"), \"ScrollView\" )\n    for i = 1, LeagueConfig.getConfigNum() do\n        local country = countryContainer:getChildByTag( i )\n        if i == leagueId then\n            country:setOpacity( 255 )\n        else\n            country:setOpacity( 100 )\n        end\n    end\n--]]\n    \n    -- Update the team list.\n    local teamList = LeagueTeamConfig.getConfig( LeagueConfig.getConfigId( leagueId ) )\n    local teamListLength = table.getn( teamList )\n\n    local teamContainer = tolua.cast( mWidget:getChildByName(\"teamList\"), \"ScrollView\" )\n    teamContainer:removeAllChildren()\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_LEFT)\n\n    local contentHeight = 0\n    for i = 1, ( teamListLength + 1 ) / 2 do\n\n        local content = GUIReader:shareReader():widgetFromJsonFile(\"scenes/Team.json\")\n        for j = 1, 2 do\n            local teamIndex = ( i - 1 ) * 2 + j\n            local eventHandler = function( sender, eventType )\n                if eventType == TOUCH_EVENT_ENDED then\n                    local teamId = TeamConfig.getConfigIdByKey( teamList[teamIndex][\"teamId\"] )\n                    teamSelected( teamId )\n                end\n            end\n\n            local teamButton = tolua.cast( content:getChildByName(\"team\"..j), \"Button\" )\n            local teamName = tolua.cast( content:getChildByName(\"team\"..j..\"Name\"), \"Label\" )\n\n            if teamIndex > teamListLength then\n                teamName:setVisible( false )\n                teamButton:setVisible( false )\n            else\n                local teamId = TeamConfig.getConfigIdByKey( teamList[teamIndex][\"teamId\"] )\n                teamButton:loadTextureNormal( TeamConfig.getLogo( teamId ) )\n                teamButton:addTouchEventListener( eventHandler )\n                teamName:setText( TeamConfig.getTeamName( teamId ) )\n            end\n            \n        end\n\n        content:setLayoutParameter( layoutParameter )\n        teamContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n    end\n\n    teamContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n\nend\n\nfunction teamSelected( index )\n    print(\"Team Selected: \"..index)\n    mLeagueId = mDisplayLeagueId\n    mTeamId = TeamConfig.getTeamId( index )\n    local teamSelected = tolua.cast( mWidget:getChildByName(\"leagueName\"), \"Label\" )\n    teamSelected:setText( \"Your favourite team: \"..TeamConfig.getTeamName( index ) )\n\n    local okBt = mWidget:getChildByName(\"ok\")\n    okBt:setBright( true )\nend\n\n","scripts.actions.EnterCompetitionDetailAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal LeaderboardConfig = require(\"scripts.config.Leaderboard\")\nlocal CompetitionDetail = require(\"scripts.data.CompetitionDetail\").CompetitionDetail\n\nlocal competitionId\n\nfunction action( param )\n    local url = RequestUtils.GET_COMPETITION_DETAIL_REST_CALL\n\n    local step = 1\n    local sortType = 1\n    competitionId = param[1]\n\n    url = url..\"?competitionId=\"..competitionId..\"&sortType=\"..sortType..\"&step=\"..step\n\n    local requestInfo = {}\n    requestInfo.requestData = \"\"\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    local competitionDetail = CompetitionDetail:new( jsonResponse )\n\n    local CompetitionDetailScene = require(\"scripts.views.CompetitionDetailScene\")\n    CompetitionDetailScene.loadFrame( competitionDetail, LeaderboardConfig.LeaderboardSubType[1], competitionId )\nend\n","scripts.actions.EnterNextPredictionAction":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal SceneManager = require(\"scripts.SceneManager\")\n\n\nfunction action( param )\n\tlocal marketInfo = Logic:getCurMarketInfo()\n\tlocal curDisplayMarketIndex = Logic:getCurDisplayMarketIndex()\n\n\tcurDisplayMarketIndex = curDisplayMarketIndex + 1\n\tLogic:setCurDisplayMarketIndex( curDisplayMarketIndex )\n\n\tif curDisplayMarketIndex > marketInfo:getNum() then\n\t\tEventManager:postEvent( Event.Enter_Pred_Total_Confirm )\n\telse\n\t\tprint( \"Display the next prediction: \"..curDisplayMarketIndex )\n\t\tlocal ScorePrediction = require(\"scripts.views.ScorePrediction\")\n\t\tlocal matchMarketData = marketInfo:getMarketAt( curDisplayMarketIndex )\n\n\t\tSceneManager.clear()\n\t\tScorePrediction.loadFrame( matchMarketData )\n\tend\nend\n","scripts.actions.EnterCreateCompetitionAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal CreateCompetitionScene = require(\"scripts.views.CreateCompetitionScene\")\n    CreateCompetitionScene.loadFrame()\nend\n","scripts.actions.DoLogReport":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\n\nlocal PROJECT_ID = \"544021a2e18b11e3923422000ab5bb50\"\nlocal ACCOUNT_ID = \"sXq6y8k3RoWKE8pyCSEJfZH9LsTc3MmCv9wjNMVjx3zhSFZN-H9Vu0_VveSM2ITwFMxJF5nYlD4=\"\nlocal SPLUNK_LOG_IP = \"https://api.p3js-eqtr.data.splunkstorm.com/1/inputs/http\"\n\nfunction reportConfigError( log )\n    report( log, \"configError\" )\nend\n\nfunction reportNetworkError( log )\n    report( log, \"networkError\" )\nend\n\nfunction reportLog( log )\n\treport( log, \"clientLog\" )\nend\n\nfunction reportError( log )\n\treport( log, \"clientError\" )\nend\n\nfunction report( log, sourceType )\n\tlocal handler = function( isSucceed, body, header, status, errorBuffer )\n    end\n\n\tlocal httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )\n    httpRequest:addHeader( Constants.CONTENT_TYPE_PLAINTEXT )\n    httpRequest:setUserpwd( \"samyu:\"..ACCOUNT_ID )\n    httpRequest:getRequest():setRequestData( log, string.len( log ) )\n\n    local url = SPLUNK_LOG_IP\n    url = url..\"?index=\"..PROJECT_ID\n    url = url..\"&sourcetype=\"..sourceType\n\n    httpRequest:sendHttpRequest( url, handler )\nend\n","scripts.views.LeaderboardMainScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal Navigator = require(\"scripts.views.Navigator\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal LeaderboardConfig = require(\"scripts.config.Leaderboard\")\nlocal ViewUtils = require(\"scripts.views.ViewUtils\")\n\n\nlocal SUB_CONTENT_HEIGHT = 187\n\nlocal mWidget\n\n\n-- DS, see Competitions.lua\nfunction loadFrame( compList )\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/LeaderboardScene.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget( widget )\n\n    Navigator.loadFrame( widget )\n\n    initContent( compList )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction isFrameShown()\n    return mWidget ~= nil\nend\n\nfunction initContent( compList )\n\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n    contentContainer:removeAllChildrenWithCleanup( true )\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n\n    -- Add Competition items\n    local contentHeight = initCompetition( layoutParameter, contentContainer, compList )\n\n    -- Add leaderboard items\n    for i = 1, table.getn( LeaderboardConfig.LeaderboardType ) do\n    \tlocal eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                contentClick( i )\n            end\n        end\n\n        local content = SceneManager.widgetFromJsonFile(\"scenes/LeaderboardContent.json\")\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n        local bt = content:getChildByName(\"button\")\n        bt:addTouchEventListener( eventHandler )\n        initLeaderboardContent( content, LeaderboardConfig.LeaderboardType[i] )\n\n        -- Add sub\n        local subContent = GUIReader:shareReader():widgetFromJsonFile(\"scenes/LeaderboardSubContent.json\")\n        subContent:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( subContent )\n        contentHeight = contentHeight + subContent:getSize().height\n        subContent:setName( \"subContent\"..i )\n        for j = 1, 4 do\n            local eventHandler = function( sender, eventType )\n                if eventType == TOUCH_EVENT_ENDED then\n                    subContentClick( i, j )\n                end\n            end\n\n            local button = subContent:getChildByName(\"button\"..j)\n            button:addTouchEventListener( eventHandler )\n        end\n    end\n    \n    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n    local layout = tolua.cast( contentContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n\nfunction initLeaderboardContent( content, info )\n    local name = tolua.cast( content:getChildByName(\"name\"), \"Label\" )\n    local logo = tolua.cast( content:getChildByName(\"logo\"), \"ImageView\" )\n\n    name:setText( info[\"displayName\"] )\n    logo:loadTexture( info[\"logo\"] )\nend\n\nfunction initCompetition( layoutParameter, contentContainer, compList )\n    -- Add competition items\n    local competitionTitle = GUIReader:shareReader():widgetFromJsonFile(\"scenes/CompetitionTitle.json\")\n    competitionTitle:setLayoutParameter( layoutParameter )\n    contentContainer:addChild( competitionTitle )\n    local height = competitionTitle:getSize().height\n\n    -- Add the create competition button\n    local create = GUIReader:shareReader():widgetFromJsonFile(\"scenes/CompetitionCreate.json\")\n\n    local createEventHandler = function( sender, eventType )\n        if eventType == TOUCH_EVENT_ENDED then\n            EventManager:postEvent( Event.Enter_Create_Competition )\n        end\n    end\n    local joinEventHandler = function( sender, eventType )\n        if eventType == TOUCH_EVENT_ENDED then\n            --EventManager:postEvent( Event.Enter_Create_Competition )\n            local token = create:getChildByName( \"tokenContainer\" ):getNodeByTag( 1 ):getText()\n            EventManager:postEvent( Event.Do_Join_Competition, { token } )\n        end\n    end\n\n    create:setLayoutParameter( layoutParameter )\n    contentContainer:addChild( create )\n    local createbt = create:getChildByName(\"Create\")\n    createbt:addTouchEventListener( createEventHandler )\n    local joinBt = create:getChildByName(\"Join\")\n    joinBt:addTouchEventListener( joinEventHandler )\n    local tokenInput = ViewUtils.createTextInput( create:getChildByName( \"tokenContainer\" ), \"Enter Competition Code\" )\n    tokenInput:setFontColor( ccc3( 0, 0, 0 ) )\n    tokenInput:setTouchPriority( SceneManager.TOUCH_PRIORITY_MINUS_ONE )\n    height = height + create:getSize().height\n\n    -- Add existing competions\n    for i = 1, compList:getSize() do\n        local eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                enterCompetition( compList:get( i )[\"Id\"] )\n            end\n        end\n\n        local content = SceneManager.widgetFromJsonFile(\"scenes/CompetitionItem.json\")\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        height = height + content:getSize().height\n\n        local name = tolua.cast( content:getChildByName(\"name\"), \"Label\" )\n        local rank = tolua.cast( content:getChildByName(\"rank\"), \"Label\" )\n        name:setText( compList:get( i )[\"Name\"] )\n        rank:setEnabled( false )\n\n        local bt = content:getChildByName(\"button\")\n        bt:addTouchEventListener( eventHandler )\n    end\n\n    return height\nend\n\nfunction contentClick( id )\n    local contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n    local subContent = contentContainer:getChildByName( \"subContent\"..id )\n    local originSize = subContent:getSize()\n\n    if originSize.height > 0 then\n        subContent:setSize( CCSize:new( originSize.width, 0 ) )\n        contentContainer:setInnerContainerSize( CCSize:new( 0, contentContainer:getInnerContainerSize().height - SUB_CONTENT_HEIGHT ) )\n    else\n        subContent:setSize( CCSize:new( originSize.width, SUB_CONTENT_HEIGHT ) )\n        contentContainer:setInnerContainerSize( CCSize:new( 0, contentContainer:getInnerContainerSize().height + SUB_CONTENT_HEIGHT ) )\n    end\n    \n    local layout = tolua.cast( contentContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n\nfunction subContentClick( id, subId )\n    EventManager:postEvent( Event.Enter_Leaderboard_List, { id, subId } )\nend\n\nfunction enterCompetition( competitionId )\n    EventManager:postEvent( Event.Enter_Competition_Detail, { competitionId } )\nend\n","scripts.config.League":"module(..., package.seeall)\n\nlocal JsonConfigReader = require(\"scripts.config.JsonConfigReader\")\nlocal DoLogReport = require(\"scripts.actions.DoLogReport\")\n\n\nlocal FILE_NAME = \"config/leagues.txt\"\nlocal mConfig = {}\nlocal mIndex = {}\nlocal mConfigNum = 0\n\nfunction init()\n\tif mConfigNum > 0 then \n\t\treturn\n\tend\n\tprint(\"Read League config.\")\n\tlocal filter = function( v )\n\t\treturn v[\"isActive\"]\n\tend\n\tmConfig, mConfigNum = JsonConfigReader.read( FILE_NAME, \"Id\", filter )\n\tprint( \"Read active league number: \"..mConfigNum )\nend\n\nfunction getConfig( id )\n\tassert( mConfig[id] ~= nil, FILE_NAME..\" dosen't has \"..id )\n\n\treturn mConfig[id]\nend\n\nfunction getConfigIdByKey( key )\n\tif mIndex[key] == nil then\n\t\tlocal log = FILE_NAME..\" dosen't has \"..key\n\t\tprint( log )\n\t\tDoLogReport.reportConfigError( log )\n\t\treturn nil\n\tend\n\n\treturn mIndex[key]\nend\n\nfunction getConfigNum()\n\treturn mConfigNum\nend\n\n--[[\n\tProvide additional getters.\n--]]\n\nfunction getConfigId( id )\n\tlocal config = getConfig( id )\n\treturn config[\"Id\"]\nend\n\nfunction getCountryId( id )\n\tlocal config = getConfig( id )\n\treturn config[\"countryId\"]\nend\n\nfunction getLogo( id )\n\tlocal config = getConfig( id )\n\treturn config[\"Id\"]..\".png\"\nend\n\nfunction getLeagueName( id )\n\tlocal config = getConfig( id )\n\treturn config[\"leagueName\"]\nend\n\nfunction getThumbUrl( id )\n\tlocal config = getConfig( id )\n\treturn config[\"thumbUrl\"]\nend\n\nfunction isActive( id )\n\tlocal config = getConfig( id )\n\treturn config[\"isActive\"]\nend\n\ninit()\n","scripts.views.ForgotPasswordScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ViewUtils = require(\"scripts.views.ViewUtils\")\n\nlocal EMAIL_CONTAINER_NAME = \"emailContainer\"\n\nlocal mWidget\n\nfunction loadFrame()\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/ForgotPassword.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget(widget)\n\n    local okBt = widget:getChildByName(\"OK\")\n    local cancelBt = widget:getChildByName(\"cancel\")\n    okBt:addTouchEventListener( okEventHandler )\n    cancelBt:addTouchEventListener( cancelEventHandler )\n\n    local emailInput = ViewUtils.createTextInput( mWidget:getChildByName( EMAIL_CONTAINER_NAME ), \"E-mail address\" )\n    emailInput:setFontColor( ccc3( 0, 0, 0 ) )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction okEventHandler( sender,eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        local email = mWidget:getChildByName( EMAIL_CONTAINER_NAME ):getNodeByTag( 1 ):getText()\n        EventManager:postEvent( Event.Enter_Login )\n    end\nend\n\nfunction cancelEventHandler( sender,eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n        EventManager:postEvent( Event.Enter_Login )\n    end\nend\n","scripts.actions.EnterLoginNRegAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal loginNRegScene = require(\"scripts.views.LoginNRegScene\")\n    loginNRegScene.loadFrame()\nend\n","scripts.actions.EnterMatchAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal RequestUtils = require(\"scripts.RequestUtils\")\n\n\nfunction action( param )\n    local matchId = Logic:getSelectedMatch()[\"Id\"]\n\n    local url = RequestUtils.GET_GAME_MARKETS_REST_CALL..\"?gameId=\"..matchId\n\n    local requestInfo = {}\n    requestInfo.requestData = \"\"\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\n\n--[[\n    local JsonConfigReader = require(\"scripts.config.JsonConfigReader\")\n    local config = JsonConfigReader.read( \"config/market.json\" )\n\n    local match = { Id = 4077,\n                HomeTeamId = 2744,\n                AwayTeamId = 2942,\n                StartTime = 1398311338 }\n    Logic:setSelectedMatch( match )\n    onRequestSuccess( config )\n--]]\nend\n\nfunction onRequestSuccess( response )\n    local MarketsForGameData = require(\"scripts.data.MarketsForGameData\").MarketsForGameData\n    \n    local marketInfo = MarketsForGameData:new( response )\n\n    Logic:setCurMarketInfo( marketInfo )\n    \n    if marketInfo:getMatchMarket() ~= nil then\n        local matchPredictionScene = require(\"scripts.views.MatchPredictionScene\")\n        matchPredictionScene.loadFrame( marketInfo:getMatchMarket() )\n    elseif marketInfo:getNum() > 0 then\n        EventManager:postEvent( Event.Enter_Next_Prediction )\n    else\n        RequestUtils.onRequestFailed( \"You have completed this match.\" )\n    end\nend\n","scripts.RequestUtils":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal DoLogReport = require(\"scripts.actions.DoLogReport\")\n\nHTTP_200 = 200\nHTTP_204 = 204\n\nSERVER_IP = \"http://fhapi-prod1.cloudapp.net\"\nFACEBOOK_GRAPH_IP = \"https://graph.facebook.com\"\nCDN_SERVER_IP = \"http://portalvhdss3c1vgx5mrzv.blob.core.windows.net/fhsettings/\"\n\nEMAIL_REGISTER_REST_CALL = SERVER_IP..\"/api/user/SignupWithEmail\"\nEMAIL_LOGIN_REST_CALL = SERVER_IP..\"/api/loginWithEmail\"\nSET_USER_METADATA_REST_CALL = SERVER_IP..\"/api/user/setUserMetaData\"\nFB_LOGIN_REST_CALL = SERVER_IP..\"/api/user/SignupWithFacebook\"\nFB_CONNECT_REST_CALL = SERVER_IP..\"/api/user/connectUserWithFacebook\"\nGET_ALL_UPCOMING_GAMES_REST_CALL = SERVER_IP..\"/api/games/allUpcoming\"\nGET_UPCOMING_GAMES_BY_LEAGUE_REST_CALL = SERVER_IP..\"/api/games/upcomingByLeague\"\nGET_GAME_MARKETS_REST_CALL = SERVER_IP..\"/api/markets/getMarketsForGame\"\nGET_COUPON_HISTORY_REST_CALL = SERVER_IP..\"/api/couponHistory/getUserCouponHistory\"\nGET_MAIN_LEADERBOARD_REST_CALL = SERVER_IP..\"/api/leaderboards/getMainLeaderboard\"\nGET_FRIENDS_LEADERBOARD_REST_CALL = SERVER_IP..\"/api/leaderboards/getFriendsLeaderboard\"\nGET_COMPETITION_LIST_REST_CALL = SERVER_IP..\"/api/competitions/getCompetitionsForUser\"\nGET_COMPETITION_DETAIL_REST_CALL = SERVER_IP..\"/api/leaderboards/getCompetitionInfoAndLeaderboard\"\nGET_COMPETITION_LEAGUE_REST_CALL = SERVER_IP..\"/api/competitions/getCompetitionLeagueIds\"\nPOST_COUPONS_REST_CALL = SERVER_IP..\"/api/coupons/placeCoupons\"\nPOST_FAV_TEAM_REST_CALL = SERVER_IP..\"/api/user/setFavoriteTeam\"\nPOST_CREATE_COMPETITION_REST_CALL = SERVER_IP..\"/api/competitions/createUserCompetition\"\nPOST_JOIN_COMPETITION_REST_CALL = SERVER_IP..\"/api/competitions/joinCompetitionWithToken\"\n\nFACEBOOK_FRIENDS_LIST_CALL = \"/me/friends?access_token=\"\nUSE_DEV = false\n\nfunction setServerIP( serverIp )\n    EMAIL_REGISTER_REST_CALL = serverIp..\"/api/user/SignupWithEmail\"\n    EMAIL_LOGIN_REST_CALL = serverIp..\"/api/loginWithEmail\"\n    SET_USER_METADATA_REST_CALL = serverIp..\"/api/user/setUserMetaData\"\n    FB_LOGIN_REST_CALL = serverIp..\"/api/user/SignupWithFacebook\"\n    FB_CONNECT_REST_CALL = serverIp..\"/api/user/connectUserWithFacebook\"\n    GET_ALL_UPCOMING_GAMES_REST_CALL = serverIp..\"/api/games/allUpcoming\"\n    GET_UPCOMING_GAMES_BY_LEAGUE_REST_CALL = serverIp..\"/api/games/upcomingByLeague\"\n    GET_GAME_MARKETS_REST_CALL = serverIp..\"/api/markets/getMarketsForGame\"\n    GET_COUPON_HISTORY_REST_CALL = serverIp..\"/api/couponHistory/getUserCouponHistory\"\n    GET_MAIN_LEADERBOARD_REST_CALL = serverIp..\"/api/leaderboards/getMainLeaderboard\"\n    GET_FRIENDS_LEADERBOARD_REST_CALL = serverIp..\"/api/leaderboards/getFriendsLeaderboard\"\n    GET_COMPETITION_LIST_REST_CALL = serverIp..\"/api/competitions/getCompetitionsForUser\"\n    GET_COMPETITION_DETAIL_REST_CALL = serverIp..\"/api/leaderboards/getCompetitionInfoAndLeaderboard\"\n    GET_COMPETITION_LEAGUE_REST_CALL = serverIp..\"/api/competitions/getCompetitionLeagueIds\"\n    POST_COUPONS_REST_CALL = serverIp..\"/api/coupons/placeCoupons\"\n    POST_FAV_TEAM_REST_CALL= serverIp..\"/api/user/setFavoriteTeam\"\n    POST_CREATE_COMPETITION_REST_CALL = serverIp..\"/api/competitions/createUserCompetition\"\n    POST_JOIN_COMPETITION_REST_CALL = serverIp..\"/api/competitions/joinCompetitionWithToken\"\n\n    CDN_SERVER_IP = \"http://portalvhdss3c1vgx5mrzv.blob.core.windows.net/fhdevsettings/\"\n\n    USE_DEV = true\nend\n\nsetServerIP( \"http://fhapi-dev1.cloudapp.net\" )\n\nfunction createHeaderObject( headerStr )\n\tlocal headerList = split( headerStr, \"\\n\" )\n    local headers = {}\n    for k, v in pairs( headerList ) do\n        local headerObj = split( v, \": \" )\n        if table.getn( headerObj ) >= 2 then\n        \theaders[headerObj[1]] = headerObj[2]\n        end\n    end\n\n    return headers\nend\n\nfunction split(str, delim, maxNb)   \n    -- Eliminate bad cases...   \n    if string.find(str, delim) == nil then  \n        return { str }  \n    end  \n    if maxNb == nil or maxNb < 1 then  \n        maxNb = 0    -- No limit   \n    end  \n    local result = {}  \n    local pat = \"(.-)\" .. delim .. \"()\"   \n    local nb = 0  \n    local lastPos   \n    for part, pos in string.gfind(str, pat) do  \n        nb = nb + 1  \n        result[nb] = part   \n        lastPos = pos   \n        if nb == maxNb then break end  \n    end  \n    -- Handle the last field   \n    if nb ~= maxNb then  \n        result[nb + 1] = string.sub(str, lastPos)   \n    end  \n    return result   \nend \n\nfunction messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, successRequestID, successHandler, failedHandler )\n    print( \"Http reponse: \"..status..\" and errorBuffer: \"..errorBuffer )\n    print( \"Http reponse body: \"..body )\n    \n    local jsonResponse = {}\n    if string.len( body ) > 0 then\n        jsonResponse = Json.decode( body )\n    else\n        jsonResponse[\"Message\"] = errorBuffer\n    end\n    ConnectingMessage.selfRemove()\n    if status == successRequestID then\n        if successHandler ~= nil then\n            successHandler( jsonResponse )\n        end\n    else\n        reportRequestFailed( requestInfo, jsonResponse[\"Message\"] )\n        if failedHandler ~= nil then\n            failedHandler( jsonResponse )\n        else\n            onRequestFailed( jsonResponse[\"Message\"] )\n        end\n    end\nend\n\nfunction reportRequestFailed( requestInfo, errorBuffer )\n    if errorBuffer == \"An error has occurred.\" then\n        local unknowErrorPostText = \"Get \"..errorBuffer..\" with request: \"..Json.encode( requestInfo )\n        print( unknowErrorPostText )\n        DoLogReport.reportNetworkError( unknowErrorPostText )\n    end\nend\n\nfunction onRequestFailed( errorBuffer )\n    EventManager:postEvent( Event.Show_Error_Message, { errorBuffer } )\nend\n","scripts.actions.EnterCompetitionLeaguesAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\n\nfunction action( param )\n    local competitionId = param[1]\n\n    local url = RequestUtils.GET_COMPETITION_LEAGUE_REST_CALL\n    url = url..\"?competitionId=\"..competitionId\n\n    local requestInfo = {}\n    requestInfo.requestData = \"\"\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n\tlocal SelectedLeaguesScene = require(\"scripts.views.SelectedLeaguesScene\")\n    SelectedLeaguesScene.loadFrame( jsonResponse )\nend\n","scripts.views.LoginScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ViewUtils = require(\"scripts.views.ViewUtils\")\nlocal Logic = require(\"scripts.Logic\")\n\nlocal EMAIL_CONTAINER_NAME = \"emailContainer\"\nlocal PASSWORD_CONTAINER_NAME = \"passwordContainer\"\n\nlocal mWidget\nlocal inputWidth = 400\nlocal inputHeight = 50\n\nfunction loadFrame()\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/Signin.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget(widget)\n\n    local signinBt = widget:getChildByName(\"signin\")\n    local backBt = widget:getChildByName(\"back\")\n    local forgotPasswordBt = widget:getChildByName(\"forgotPassword\")\n    signinBt:addTouchEventListener( signinEventHandler )\n    backBt:addTouchEventListener( backEventHandler )\n    forgotPasswordBt:addTouchEventListener( forgotPasswordEventHandler )\n\n    local emailInput = ViewUtils.createTextInput( mWidget:getChildByName( EMAIL_CONTAINER_NAME ), \"E-mail address\" )\n    emailInput:setFontColor( ccc3( 0, 0, 0 ) )\n    local passwordInput = ViewUtils.createTextInput( mWidget:getChildByName( PASSWORD_CONTAINER_NAME ), \"Password\" )\n    passwordInput:setInputFlag( kEditBoxInputFlagPassword )\n    passwordInput:setFontColor( ccc3( 0, 0, 0 ) )\n\n    emailInput:setText( Logic.getInstance():getEmail() )\n    passwordInput:setText( Logic.getInstance():getPassword() )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction backEventHandler( sender,eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        --EventManager:postEvent( Event.Enter_Login_N_Reg )\n        EventManager:popHistory()\n    end\nend\n\nfunction signinEventHandler( sender,eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n        local email = mWidget:getChildByName( EMAIL_CONTAINER_NAME ):getNodeByTag( 1 ):getText()\n        local pass = mWidget:getChildByName( PASSWORD_CONTAINER_NAME ):getNodeByTag( 1 ):getText()\n\n        EventManager:postEvent( Event.Do_Login, { email, pass } )\n    end\nend\n\nfunction forgotPasswordEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        EventManager:postEvent( Event.Enter_Forgot_Password )\n    end\nend\n","scripts.Constants":"module(..., package.seeall)\n\nCONTENT_TYPE_JSON = \"Content-Type: application/json\"\nCONTENT_TYPE_PLAINTEXT = \"Content-Type: text/plain\"\n\nIMAGE_PATH = \"images/\"\n\nTEAM_IMAGE_PATH = IMAGE_PATH..\"teams/\"\nLEAGUE_IMAGE_PATH = IMAGE_PATH..\"leagues/\"\nCOUNTRY_IMAGE_PATH = IMAGE_PATH..\"countries/\"\nPREDICTION_CHOICE_IMAGE_PATH = \"scenes/MatchPrediction/\"\nLEADERBOARD_IMAGE_PATH = \"scenes/Leaderboards/\"\n\nDRAW = 0\nTEAM1_WIN = 1\nTEAM2_WIN = 2\n\nYES = 1\nNO = 2\n\nFONT_1 = \"fonts/Newgtbxc.ttf\"\n\nSTAKE = 1000\n","scripts.actions.EnterForgotPasswordAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal forgotPasswordScene = require(\"scripts.views.ForgotPasswordScene\")\n    forgotPasswordScene.loadFrame()\nend\n","scripts.config.Settings":"module(..., package.seeall)\n\nlocal Event = require(\"scripts.events.Event\").EventList\n\nSettingsItem = {\n\t{ [\"itemName\"] = \"Send feedback\", [\"event\"] = Event.Do_Send_Feedback, },\n\t{ [\"itemName\"] = \"Profile\", [\"event\"] = Event.Do_Send_Feedback, },\n\t{ [\"itemName\"] = \"Logout\", [\"event\"] = Event.Do_Log_Out, },\n\t{ [\"itemName\"] = \"FAQ\", [\"event\"] = Event.Enter_FAQ, },\n\t{ [\"itemName\"] = \"Send review\", [\"event\"] = Event.Do_Send_Feedback, },\n\t{ [\"itemName\"] = \"About\", [\"event\"] = Event.Do_Send_Feedback, },\n}\n","scripts.views.ViewUtils":"module(..., package.seeall)\n\nlocal inputWidth = 400\nlocal inputHeight = 50\nlocal FONT_NAME = \"Newgtbxc\"\nlocal FONT_SIZE = 30\n\nfunction createTextInput( container, placeholderText, width, height, fontName, fontSize )\n\twidth = width or inputWidth\n\theight = height or inputHeight\n\tfontName = fontName or FONT_NAME\n\tfontSize = fontSize or FONT_SIZE\n\n    local textInput = CCEditBox:create( CCSizeMake( width, height ), CCScale9Sprite:create() )\n    container:addNode( textInput, 0, 1 )\n    textInput:setPosition( width / 2, height / 2 )\n    textInput:setFont(fontName, fontSize)\n    textInput:setPlaceHolder( placeholderText )\n\n    return textInput\nend\n","scripts.actions.DoFBConnectWithUserAction":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal Json = require(\"json\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\n\nlocal mSuccessHandler\nlocal mFailedHandler\n\nfunction action( param )\n    mSuccessHandler = param[1]\n    mFailedHandler = param[2]\n\n\tlocal Json = require(\"json\")\n\tlocal RequestUtils = require(\"scripts.RequestUtils\")\n\n    local successHandler = function( accessToken )\n        if accessToken == nil then\n            -- To handle user reject to the oAuth.\n            onFBConnectFailed()\n        else\n            print(\"Get token \"..accessToken)\n            onFBConnectSuccess( accessToken )\n        end\n    end\n\n    FacebookDelegate:sharedDelegate():login( successHandler, successHandler )\nend\n\nfunction onFBConnectFailed()\n    mFailedHandler( true )\nend\n\nfunction onFBConnectSuccess( accessToken )\n    local requestContent = { SocialNetworkType = 0, AuthToken = accessToken, useDev = RequestUtils.USE_DEV }\n    local requestContentText = Json.encode( requestContent )\n    \n    local url = RequestUtils.FB_CONNECT_REST_CALL\n    \n    local requestInfo = {}\n    requestInfo.requestData = requestContentText\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess, onRequestFailed )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )\n    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    Logic:setFbId( \"\" )\n    mSuccessHandler()\nend\n\nfunction onRequestFailed( jsonResponse )\n    local errorBuffer = jsonResponse[\"Message\"]\n    mFailedHandler( false )\n    EventManager:postEvent( Event.Show_Error_Message, { errorBuffer } )\nend\n","scripts.views.ConnectingMessage":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\n\nlocal mWidget\nlocal mWaitingArmature\n\nfunction loadFrame( message )\n    if mWidget == nil then\n        local widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/ConnectingMessage.json\")\n\n        widget:addTouchEventListener( onFrameTouch )\n        mWidget = widget\n        mWidget:registerScriptHandler( EnterOrExit )\n        SceneManager.addWidget( widget )\n\n        CCArmatureDataManager:sharedArmatureDataManager():addArmatureFileInfo(\"anims/waiting0.png\",\"anims/waiting0.plist\",\"anims/waiting.ExportJson\")\n\n        mWaitingArmature = CCArmature:create(\"waiting\")\n        mWaitingArmature:setPosition( ccp( 50, 50 ) )\n        mWaitingArmature:getAnimation():playWithIndex(0)\n        mWidget:getChildByName(\"animContainer\"):addNode( mWaitingArmature )\n\n    end\n    setMessage( message )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n        mWaitingArmature:getAnimation():stop()\n        mWaitingArmature = nil\n    end\nend\n\nfunction setMessage( message )\n    message = message or \"Connecting...\"\n    print( \"Load connecting message scene:\"..message )\n    local messageLabel = tolua.cast( mWidget:getChildByName(\"connectMessage\"), \"Label\" )\n    messageLabel:setText( message )\nend\n\nfunction selfRemove()\n    SceneManager.removeWidget( mWidget )\nend\n\nfunction onFrameTouch( sender, eventType )\n    -- Do nothing, just block touch event.\nend\n","scripts.views.LoginNRegScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\n\nlocal mWidget\n\nfunction loadFrame()\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/LoginNReg.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget(widget)\n\n    local signinBt = widget:getChildByName(\"signin\")\n    local registerBt = widget:getChildByName(\"register\")\n    local facebookBt = widget:getChildByName(\"facebookConnect\")\n    local dev = tolua.cast( widget:getChildByName(\"dev\"), \"Button\" )\n\n    signinBt:addTouchEventListener( signinEventHandler )\n    registerBt:addTouchEventListener( registerEventHandler )\n    facebookBt:addTouchEventListener( facebookEventHandler )\n    dev:addTouchEventListener( devEventHandler )\n    dev:setEnabled( false )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction signinEventHandler( sender,eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n        EventManager:postEvent( Event.Enter_Login )\n    end\nend\n\nfunction registerEventHandler( sender,eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n        EventManager:postEvent( Event.Enter_Register )\n    end\nend\n\nfunction facebookEventHandler( sender,eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        EventManager:postEvent( Event.Do_FB_Connect ) \n    end\nend\n\nfunction devEventHandler( sender,eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n         local RequestUtils = require(\"scripts.RequestUtils\")\n         RequestUtils.setServerIP(\"http://fhapi-dev1.cloudapp.net\")\n    end\nend\n","scripts.data.Coupons":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\n\nCoupons = {}\n\n--[[\nData need to be sent to server:\n\n{\n  \"CouponForms\":\n  [\n    {\n      \"OutcomeIds\" : [2435033],\n      \"Stake\" : 1000,\n    }\n  ],\n  \"Message\" : \"My first bet\",\n  \"ShareOnFacebook\" : false  \n}\n\nWhole Data :\n\n{\n  \"CouponForms\":\n  [\n    {\n      \"OutcomeIds\" : [2435033],\n      \"Stake\" : 1000,\n      \"Answer\" : \"Arsenal to win.\", \n      \"Reward\": 4000, \n      \"AnswerIcon\": \"XXXX.png\"\n    }\n  ],\n  \"Message\" : \"My first bet\",\n  \"ShareOnFacebook\" : false\n}\n--]]\n\nfunction Coupons:new()\n\tlocal obj = {\n\t\tCouponForms = {},\n    Message = \"\",\n    ShareOnFacebook = false\n\t}\n\n\tsetmetatable(obj, self)\n    self.__index = self\n    \n    obj.__newindex = function(t, k, v) assert(false, \"Coupons--\"..k .. \"__newindex not exist\") end\n    \n    return obj \nend\n\nfunction Coupons:addCoupon( id, answer, reward, answerIcon )\n    local idList = {}\n    table.insert( idList, id )\n\n    local coupon = {\n        OutcomeIds = idList,\n        Stake = 1000,\n        Answer = answer,\n        Reward = reward,\n        AnswerIcon = answerIcon\n    }\n\n    table.insert( self.CouponForms, coupon )\nend\n\nfunction Coupons:getSize()\n    return table.getn( self.CouponForms )\nend\n\nfunction Coupons:get( index )\n    return self.CouponForms[index]\nend\n\nfunction Coupons:setMessage( message )\n    self.Message = message\nend\n\nfunction Coupons:setShareOnFacebook( share )\n    self.ShareOnFacebook = share\nend\n\nfunction Coupons:toString()\n    local form = {}\n    for i, v in ipairs( self.CouponForms ) do\n        local coupon = {\n            OutcomeIds = v[\"OutcomeIds\"],\n            Stake = v[\"Stake\"],\n        }\n\n        table.insert( form, coupon )\n    end\n\n    return string.format( \"{\\\"CouponForms\\\":%s, \\\"Message\\\":\\\"%s\\\", \\\"ShareOnFacebook\\\":%s}\", Json.encode( form ), self.Message, self.ShareOnFacebook )\nend\n","scripts.events.Event":"module(..., package.seeall)\n\nfunction CreatEnumTable( tbl, index ) \n    assert( type( tbl ) == \"table\" ) \n    local enumtbl = {} \n    local enumindex = index or 0 \n    for i, v in ipairs( tbl ) do \n        enumtbl[v] = enumindex + i \n    end \n    return enumtbl \nend \n\nfunction GetEventNameById( id )\n\treturn EventNameList[id]\nend\n\nEventNameList = \n{ \n    \"Check_File_Version\",\n\n    \"Enter_Login_N_Reg\",\n    \"Enter_Register\",\n    \"Enter_Register_Name\",\n    \"Enter_Login\",\n    \"Enter_Forgot_Password\",\n    \"Enter_Match_List\",\n    \"Enter_Match\",\n    \"Enter_Prediction_Confirm\",\n    \"Enter_Pred_Total_Confirm\",\n    \"Enter_Sel_Fav_Team\",\n    \"Enter_Next_Prediction\",\n    \"Enter_History\",\n    \"Enter_History_Detail\",\n    \"Enter_Leaderboard\",\n    \"Enter_Leaderboard_List\",\n    \"Enter_Settings\",\n    \"Enter_FAQ\",\n    \"Enter_Create_Competition\",\n    \"Enter_View_Selected_Leagues\",\n    \"Enter_Competition_Leagues\",\n    \"Enter_Competition_Detail\",\n\n    \"Do_Register\",\n    \"Do_Register_Name\",\n    \"Do_Login\",\n    \"Do_FB_Connect\",\n    \"Do_FB_Connect_With_User\",\n    \"Do_Post_Predictions\",\n    \"Do_Post_Fav_Team\",\n    \"Do_Send_Feedback\",\n    \"Do_Log_Out\",\n    \"Do_Create_Competition\",\n    \"Do_Join_Competition\",\n\n    \"Show_Info\",\n    \"Show_Error_Message\",\n\n    \"Load_More_In_Leaderboard\",\n    \"Load_More_In_History\",\n    \"Load_More_In_Competition_Detail\",\n}\n\nEventNameDosenotTrackList = \n{ \n    \"Do_Register\",\n    \"Do_Register_Name\",\n    \"Do_Login\",\n    \"Do_FB_Connect\",\n    \"Do_FB_Connect_With_User\",\n    \"Do_Post_Predictions\",\n    \"Do_Post_Fav_Team\",\n    \"Do_Send_Feedback\",\n    \"Do_Log_Out\",\n    \"Do_Create_Competition\",\n    \"Do_Join_Competition\",\n\n    \"Check_File_Version\",\n    \"Show_Info\",\n    \"Show_Error_Message\",\n    \"Load_More_In_Leaderboard\",\n    \"Load_More_In_History\",\n    \"Load_More_In_Competition_Detail\",\n}\n\nEventList = CreatEnumTable( EventNameList )\nEventDosenotTrackList = CreatEnumTable( EventNameDosenotTrackList )\n","scripts.actions.DoPostFavTeamAction":"module(..., package.seeall)\n\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\n\nlocal mStartLeague\n\nfunction action( param )\n\tlocal Json = require(\"json\")\n\tlocal RequestUtils = require(\"scripts.RequestUtils\")\n\n    local favTeamID = param[1]\n    mStartLeague = param[2]\n\n    local requestContent = { TeamId = favTeamID, LeagueId = mStartLeague }\n    local requestContentText = Json.encode( requestContent )\n    \n    local url = RequestUtils.POST_FAV_TEAM_REST_CALL\n\n    local requestInfo = {}\n    requestInfo.requestData = requestContentText\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )\n    httpRequest:addHeader( \"Content-Type: application/json\" )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    Logic:setStartLeagueId( mStartLeague )\n    EventManager:postEvent( Event.Enter_Match_List )\nend\n","scripts.views.ErrorMessage":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\n\nlocal mWidget\nlocal mRetryCall\n\nfunction loadFrame()\n\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/ErrorMessage.json\")\n\n    local okBt = widget:getChildByName(\"ok\")\n    okBt:addTouchEventListener( okEventHandler )\n\n    widget:addTouchEventListener( onFrameTouch )\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.addWidget( widget )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction setTitle( title )\n    local titleMessage = tolua.cast( mWidget:getChildByName(\"title\"), \"Label\" )\n    titleMessage:setText( title )\nend\n\nfunction setErrorMessage( message, retryCall )\n    local errorMessage = tolua.cast( mWidget:getChildByName(\"errorMessage\"), \"Label\" )\n    errorMessage:setText( message )\n    mRetryCall = retryCall\nend\n\nfunction okEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        SceneManager.removeWidget( mWidget )\n        if mRetryCall ~= nil then\n            mRetryCall()\n            mRetryCall = nil\n        end\n    end\nend\n\nfunction onFrameTouch( sender, eventType )\n    -- Do nothing, just block touch event.\nend\n","scripts.actions.EnterPredictionConfirmAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal prediction, teamName, reward, answerIcon = param[1], param[2], param[3], param[4]\n\n\tlocal predConfirmScene = require(\"scripts.views.PredConfirmScene\")\n    predConfirmScene.loadFrame( prediction, teamName, reward, answerIcon )\nend\n","scripts.actions.DoRegisterNameAction":"module(..., package.seeall)\n\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\nlocal mUserName = \"SamYu\"\nlocal mFirstName = \"Yu\"\nlocal mLastName = \"Zheng\"\n\n\nfunction action( param )\n\tlocal Json = require(\"json\")\n\tlocal RequestUtils = require(\"scripts.RequestUtils\")\n\n    mUserName, mFirstName, mLastName = param[1], param[2], param[3]\n    if string.len( mUserName ) == 0 then\n        RequestUtils.onRequestFailed( \"User name is blank.\" )\n        return\n    end\n    if mFirstName == nil then\n        mFirstName = \"\"\n    end\n\n    if mLastName == nil then\n        mLastName = \"\"\n    end\n\n    local requestContent = { DisplayName = mUserName, FirstName = mFirstName, LastName = mLastName, DoB = \"\" }\n    local requestContentText = Json.encode( requestContent )\n    \n    local url = RequestUtils.SET_USER_METADATA_REST_CALL\n\n    local requestInfo = {}\n    requestInfo.requestData = requestContentText\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )\n    httpRequest:addHeader( \"Content-Type: application/json\" )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    EventManager:postEvent( Event.Enter_Sel_Fav_Team )\nend\n","scripts.actions.DoLogOutAction":"module(..., package.seeall)\n\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\n\nfunction action( param )\n\tEventManager:postEvent( Event.Enter_Login_N_Reg )\nend\n","scripts.views.PredConfirmScene":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\n\nlocal mAnswer\nlocal mReward\nlocal mOddId\nlocal mAnswerIcon\nlocal mWidget\nlocal mTextInput\n\nfunction loadFrame( answer, reward, oddId, answerIcon )\n\n\tprint(answerIcon)\n\tmAnswer = answer\n\tmReward = reward\n\tmOddId = oddId\n\tmAnswerIcon = answerIcon\n\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/PredConfirm.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    mWidget:addTouchEventListener( bgEventHandler )\n    SceneManager.addWidget(widget)\n\n\tinitContent()    \n    createTextInput()\n\n    local confirmBt = widget:getChildByName(\"confirm\")\n    confirmBt:addTouchEventListener( confirmEventHandler )\n\n    local cancelBt = widget:getChildByName(\"cancel\")\n    cancelBt:addTouchEventListener( cancelEventHandler )\n\n    local textDisplay = mWidget:getChildByName(\"Text\")\n\ttextDisplay:addTouchEventListener( inputEventHandler )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n        mTextInput = nil\n    end\nend\n\nfunction confirmEventHandler( sender, eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n\t\tlocal textDisplay = tolua.cast( mWidget:getChildByName(\"Text\"), \"Label\" )\n\t\tlocal comment = textDisplay:getStringValue()\n\n\t\tSceneManager.clear()\n\t\tLogic:addPrediction( mOddId, mAnswer, mReward, mAnswerIcon )\n\t    EventManager:postEvent( Event.Enter_Next_Prediction )\n\tend\nend\n\nfunction cancelEventHandler( sender, eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n\t\tSceneManager.removeWidget( mWidget )\n\tend\nend\n\nfunction bgEventHandler( sender, eventType )\n\t-- Do nothing, just block\nend\n\nfunction inputEventHandler( sender, eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n\t\tmTextInput:touchDownAction( sender, eventType )\n\tend\nend\n\nfunction createTextInput()\n\tlocal container = mWidget:getChildByName(\"TextInput\")\n\n\tlocal inputDelegate = EditBoxDelegateForLua:create()\n\tinputDelegate:registerEventScriptHandler( EDIT_BOX_EVENT_TEXT_CHANGED, function ( textBox, text )\n\t\tlocal textDisplay = tolua.cast( mWidget:getChildByName(\"Text\"), \"Label\" )\n\t\ttextDisplay:setText( text )\n\tend )\n\tcontainer:addNode( tolua.cast( inputDelegate, \"CCNode\" ) )\n\n\tmTextInput = CCEditBox:create( CCSizeMake( 550, 35 ), CCScale9Sprite:create() )\n    container:addNode( mTextInput )\n    mTextInput:setPosition( 550 / 2, 35 / 2 )\n    mTextInput:setFontColor( ccc3( 0, 0, 0 ) )\n    mTextInput:setVisible( false )\n    mTextInput:setDelegate( inputDelegate.__CCEditBoxDelegate__ )\n    mTextInput:setTouchPriority( SceneManager.TOUCH_PRIORITY_MINUS_ONE )\nend\n\nfunction initContent()\n\tlocal question = tolua.cast( mWidget:getChildByName(\"Question\"), \"Label\" )\n\tlocal reward = tolua.cast( mWidget:getChildByName(\"Reward\"), \"Label\" )\n\tlocal answerIcon = tolua.cast( mWidget:getChildByName(\"answerIcon\"), \"ImageView\" )\n\n\tquestion:setFontName( \"Newgtbxc\" )\n\treward:setFontName( \"Newgtbxc\" )\n\n\tquestion:setText( mAnswer )\n\treward:setText( string.format( reward:getStringValue(), mReward ) )\n\tanswerIcon:loadTexture( mAnswerIcon )\nend\n","scripts.config.JsonConfigReader":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal FileUtils = require(\"scripts.FileUtils\")\n\nfunction read( fileName, primaryKey, filter )\n\tfilter = filter or passAll\n\tif primaryKey == nil then\n\t\treturn readWithoutPrimaryKey( fileName, filter )\n\telse\n\t\treturn readWithPrimaryKey( fileName, primaryKey, filter )\n\tend\nend\n\nfunction readWithPrimaryKey( fileName, primaryKey, filter )\n\tlocal startTime = os.time()\n\n\tlocal config = {}\n\tlocal index = {}\n\tlocal configNum = 0\n\n\t-- Check if there is a local version\n\tlocal text = FileUtils.readStringFromFile( fileName )\n\tprint( \"Read file \"..fileName..\" took \"..( os.time() - startTime ) )\n\tstartTime = os.time()\n\t--print( text )\n\tlocal jsonObject = Json.decode( text )\n\tfor i, v in pairs( jsonObject ) do\n\t\tif filter( v ) then\n\t\t    table.insert( config, v )\n\t    \tconfigNum = configNum + 1\n\n\t    \tlocal id = v[primaryKey]\n\t\t    index[id] = configNum\n\t\tend\n\tend\n\n\tprint( \"Parse file \"..fileName..\" took \"..( os.time() - startTime ) )\n\treturn config, configNum, index\nend\n\nfunction readWithoutPrimaryKey( fileName, filter )\n\tlocal config = {}\n\tlocal configNum = 0\n\n\tlocal text = FileUtils.readStringFromFile( fileName )\n\t--print( text )\n\tlocal jsonObject = Json.decode( text )\n\tfor i, v in pairs( jsonObject ) do\n\t\tif filter( v ) then\n\t\t\ttable.insert( config, v )\n\t    \tconfigNum = configNum + 1\n\t\tend\n\tend\n\n\treturn config, configNum\nend\n\nfunction passAll( v )\n\treturn true\nend\n\nfunction readAndCombine( fileName, primaryKey )\n\tlocal config = {}\n\n\tlocal text = FileUtils.readStringFromFile( fileName )\n\t--print( text )\n\tlocal jsonObject = Json.decode( text )\n\tfor i, v in pairs( jsonObject ) do\n\t\tlocal id = v[primaryKey]\n\t\tif config[id] == nil then\n\t\t\tconfig[id] = {}\n\t\tend\n\n\t\ttable.insert( config[id], v )\n\tend\n\n\treturn config\nend\n","scripts.config.Market":"module(..., package.seeall)\n\nMARKET_TYPE_MATCH = 1\nMARKET_TYPE_TOTAL_GOAL = 2\nMARKET_TYPE_ASIAN_HANDICAP = 3\n\n\nODDS_TYPE_ONE_OPTION = 1\nODDS_TYPE_TWO_OPTION = 2\n","scripts.views.LeagueListScene":"module(..., package.seeall)\n\nlocal CountryConfig = require(\"scripts.config.Country\")\nlocal LeagueConfig = require(\"scripts.config.League\")\nlocal SceneManager = require(\"scripts.SceneManager\")\n\nlocal mCountryNum = CountryConfig.getConfigNum()\nlocal mCountryExpended = {}\n\nlocal COUNTRY_CONTENT_HEIGHT = 140\nlocal LEAGUE_CONTENT_HEIGHT = 60\n\nlocal mCountryWidget\nlocal mLeagueWidget\nlocal mLeagueListContainer\nlocal mLeagueSelectCallback\nlocal mLeagueInitCallback\n\nfunction loadFrame( countryWidget, leagueWidget, leagueListContainer, leagueSelectCallback, leagueInitCallback )\n\tmCountryWidget = countryWidget\n\tmLeagueWidget = leagueWidget\n\tmLeagueListContainer = leagueListContainer\n\tmLeagueSelectCallback = leagueSelectCallback\n    mLeagueInitCallback = leagueInitCallback\n\n    local content = SceneManager.widgetFromJsonFile( mCountryWidget )\n    COUNTRY_CONTENT_HEIGHT = content:getSize().height\n    content = SceneManager.widgetFromJsonFile( mLeagueWidget )\n    LEAGUE_CONTENT_HEIGHT = content:getSize().height\n\n\thelperInitLeagueList()\nend\n\nfunction expendAll()\n    for i = 1, mCountryNum do\n        mCountryExpended[i] = true\n        helperUpdateLeagueList( i )\n    end\nend\n\nfunction unexpendAll()\n    for i = 1, mCountryNum do\n        mCountryExpended[i] = false\n        helperUpdateLeagueList( i )\n    end\nend\n\nfunction helperInitLeagueList()\n    local contentHeight = 0\n\n    for i = 1, mCountryNum do\n        mCountryExpended[i] = false\n        local eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                -- Handler\n                if mCountryExpended[i] == true then\n                    mCountryExpended[i] = false\n                else\n                    mCountryExpended[i] = true\n                end\n                helperUpdateLeagueList( i )\n            end\n        end\n\n        local content = SceneManager.widgetFromJsonFile( mCountryWidget )\n        local countryName = tolua.cast( content:getChildByName(\"countryName\"), \"Label\" )\n        if countryName ~= nil then\n        \tcountryName:setText( CountryConfig.getCountryName( i ) )\n       \tend\n\n        content:addTouchEventListener( eventHandler )\n        content:setPosition( ccp( 0, ( i - 1 ) * COUNTRY_CONTENT_HEIGHT ) )\n        mLeagueListContainer:addChild( content )\n        content:setName( \"country\"..i )\n        local logo = tolua.cast( content:getChildByName(\"countryLogo\"), \"ImageView\" )\n        logo:loadTexture( CountryConfig.getLogo( i ) )\n        contentHeight = contentHeight + content:getSize().height\n        mLeagueListContainer:jumpToPercentVertical( 1 )\n    end\n\n    local scrollViewHeight = mLeagueListContainer:getSize().height\n    if contentHeight < scrollViewHeight then\n        local offset = scrollViewHeight - contentHeight\n\n        for i = 1, mCountryNum do\n            local countryLogo = mLeagueListContainer:getChildByName( \"country\"..i )\n            countryLogo:setPosition( ccp( countryLogo:getPositionX() , countryLogo:getPositionY() + offset ) )\n        end\n    else\n        mLeagueListContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )    \n    end\n\n    local layout = tolua.cast( mLeagueListContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n\nfunction helperUpdateLeagueList( clickedCountryId )\n\tprint( \"helperUpdateLeagueList \"..clickedCountryId )\n\n    local leagueNum = table.getn( CountryConfig.getLeagueList( clickedCountryId ) ) \n\n    -- Calculate the move offset\n    local moveOffsetX = 0\n    if mCountryExpended[clickedCountryId] == true then\n        moveOffsetX = leagueNum * LEAGUE_CONTENT_HEIGHT\n    else\n        moveOffsetX = leagueNum * (-LEAGUE_CONTENT_HEIGHT)\n    end\n\n    -- Move upper country and league logo's position    \n    for i = clickedCountryId, mCountryNum do\n        local countryLogo = mLeagueListContainer:getChildByName( \"country\"..i )\n        countryLogo:setPosition( ccp( countryLogo:getPositionX() , countryLogo:getPositionY() + moveOffsetX ) )\n        local otherCountryLeagueNum = table.getn( CountryConfig.getLeagueList( i ) ) \n        for j = 1, otherCountryLeagueNum do\n            local leagueLogo = mLeagueListContainer:getChildByName( \"country\"..i..\"_league\"..j )\n            if leagueLogo ~= nil then\n                leagueLogo:setPosition( ccp( leagueLogo:getPositionX() , leagueLogo:getPositionY() + moveOffsetX ) )\n            end\n        end\n    end\n\n    -- Add or remove league logos according to the status\n    if mCountryExpended[clickedCountryId] == true then\n        for i = 1, leagueNum do\n            local leagueId = CountryConfig.getLeagueList( clickedCountryId )[i]\n\n            local eventHandler = function( sender, eventType )\n                if eventType == TOUCH_EVENT_ENDED then\n                    mLeagueSelectCallback( leagueId, sender )\n                end\n            end\n\n            local content = SceneManager.widgetFromJsonFile( mLeagueWidget )\n            local parent = mLeagueListContainer:getChildByName( \"country\"..clickedCountryId )\n            content:setPosition( ccp( 0, parent:getPositionY() - ( leagueNum - i + 1 ) * LEAGUE_CONTENT_HEIGHT ) )\n            mLeagueListContainer:addChild( content )\n            content:setName( \"country\"..clickedCountryId..\"_league\"..i )\n            content:addTouchEventListener( eventHandler )\n            local leagueName = tolua.cast( content:getChildByName(\"leagueName\"), \"Label\" )\n            leagueName:setText( LeagueConfig.getLeagueName( leagueId ) )\n            \n            if mLeagueInitCallback ~= nil then\n                mLeagueInitCallback( content, leagueId )\n            end\n        end\n    else\n        for i = 1, leagueNum do\n            local leagueLogo = mLeagueListContainer:getChildByName( \"country\"..clickedCountryId..\"_league\"..i )\n            mLeagueListContainer:removeChild( leagueLogo )\n        end\n    end \n    \n    -- Update the max container size.\n    local originHeight = mLeagueListContainer:getInnerContainerSize().height\n    mLeagueListContainer:setInnerContainerSize( CCSize:new( 0, originHeight + moveOffsetX ) )\n    local layout = tolua.cast( mLeagueListContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n","scripts.views.SelectedLeaguesScene":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ViewUtils = require(\"scripts.views.ViewUtils\")\nlocal LeagueListScene = require(\"scripts.views.LeagueListScene\")\nlocal CountryConfig = require(\"scripts.config.Country\")\n\n\nlocal mWidget\nlocal mSelectedLeagues\nlocal mCheckEnabled\n\n-- If selectedLeagues is not Null, this is for review of the leagues selected.\n-- So disable all the checkboxes.\nfunction loadFrame( selectedLeagues )\n    mSelectedLeagues = selectedLeagues or Logic:getSelectedLeagues() or CountryConfig.getAllLeagues()\n    mCheckEnabled = ( selectedLeagues == nil )\n\n    local widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/CreateCompSelectLeague.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget(widget)\n\n    LeagueListScene.loadFrame( \"scenes/CreateCompCountryListContent.json\", \"scenes/CreateCompLeagueListContent.json\", \n        tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" ), leagueSelected, leagueInit )\n    LeagueListScene.expendAll()\n\n    local okBt = widget:getChildByName(\"OK\")\n    okBt:addTouchEventListener( confirmEventHandler )\n    local backBt = widget:getChildByName(\"Back\")\n    backBt:addTouchEventListener( backEventHandler )\n    local allBt = widget:getChildByName(\"all\")\n    allBt:addTouchEventListener( allEventHandler )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction confirmEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        if table.getn( mSelectedLeagues ) == 0 then\n            EventManager:postEvent( Event.Show_Error_Message, { \"Please select at least one league or cup.\" } )\n        else\n            Logic:setSelectedLeagues( mSelectedLeagues )\n            EventManager:popHistory()\n        end\n    end\nend\n\nfunction backEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        EventManager:popHistory()\n    end\nend\n\nfunction allEventHandler( sender, eventType )\n    if mCheckEnabled and eventType == TOUCH_EVENT_ENDED then\n        mSelectedLeagues = CountryConfig.getAllLeagues()\n        LeagueListScene.unexpendAll()\n        LeagueListScene.expendAll()\n    end\nend\n\nfunction leagueSelected( leagueId, sender )\n    if mCheckEnabled then\n        local tick = sender:getChildByName(\"ticked\")\n        if tick:isEnabled() then\n            tick:setEnabled( false )\n            for i = 1, table.getn( mSelectedLeagues ) do\n                if mSelectedLeagues[i] == leagueId then\n                    table.remove( mSelectedLeagues, i )\n                    break\n                end\n            end\n        else\n            tick:setEnabled( true )\n            table.insert( mSelectedLeagues, leagueId )\n        end\n    end\nend\n\nfunction leagueInit( content, leagueId )\n    local isTicked = false\n    for i = 1, table.getn( mSelectedLeagues ) do\n        if mSelectedLeagues[i] == leagueId then\n            isTicked = true\n            break\n        end\n    end\n\n    content:getChildByName(\"ticked\"):setEnabled( isTicked )\nend\n","scripts.config.LeagueTeams":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal JsonConfigReader = require(\"scripts.config.JsonConfigReader\")\nlocal DoLogReport = require(\"scripts.actions.DoLogReport\")\n\n\nlocal FILE_NAME = \"config/leagueteams.txt\"\nlocal mConfig = {}\n\nfunction init()\n\tprint(\"Read LeagueTeam config.\")\n\tmConfig = JsonConfigReader.readAndCombine( FILE_NAME, \"leagueId\" )\nend\n\nfunction getConfig( id )\n\tif id == nil then\n\t\treturn nil\n\tend\n\tif mConfig[id] == nil then\n\t\tlocal log = FILE_NAME..\" dosen't has \"..id\n\t\tprint( log )\n\t\tDoLogReport.reportConfigError( log )\n\t\treturn nil\n\tend\n\n\treturn mConfig[id]\nend\n\n--[[\n\tProvide additional getters.\n--]]\n\n\ninit()\n","scripts.actions.DoRegisterAction":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal Json = require(\"json\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\n\nlocal mEmail = \"test126@abc.com\"\nlocal mPassword = \"test126\"\nlocal mPasswordConf = \"test126\"\n\n\nfunction action( param )\n\n    mEmail, mPassword, mPasswordConf = param[1], param[2], param[3]\n    if string.len( mEmail ) == 0 then\n        RequestUtils.onRequestFailed( \"Email is blank.\" )\n        return\n    end\n    if mPassword ~= mPasswordConf then\n        RequestUtils.onRequestFailed( \"Two passwords are not the same.\" )\n        return\n    end\n    if string.len( mPassword ) < 6 then\n        RequestUtils.onRequestFailed( \"Password too short.\" )\n        return\n    end\n    if string.len( mPassword ) > 160 then\n        RequestUtils.onRequestFailed( \"Password too long.\" )\n        return\n    end\n    if string.find( mEmail, \"([-%a%d%._]+)@([-%a%d.]+)\" ) == nil then\n        RequestUtils.onRequestFailed( \"Bad email format.\" )\n        return\n    end\n\n    local requestContent = { Email = mEmail, Password = mPassword, useDev = RequestUtils.USE_DEV }\n    local requestContentText = Json.encode( requestContent )\n    \n    local url = RequestUtils.EMAIL_REGISTER_REST_CALL\n\n    local requestInfo = {}\n    requestInfo.requestData = requestContentText\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )\n    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )\n    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    local sessionToken = jsonResponse[\"SessionToken\"]\n    local userId = jsonResponse[\"Id\"]\n    local configMd5Info = jsonResponse[\"ConfigMd5Info\"]\n    local displayName = jsonResponse[\"DisplayName\"]\n    local pictureUrl = jsonResponse[\"PictureUrl\"]\n    local startLeagueId = jsonResponse[\"StartLeagueId\"]\n    local balance = jsonResponse[\"Balance\"]\n    local FbId = jsonResponse[\"FbId\"]\n\n    local Logic = require(\"scripts.Logic\").getInstance()\n    Logic:setUserInfo( mEmail, mPassword, sessionToken, userId )\n    Logic:setDisplayName( displayName )\n    Logic:setPictureUrl( pictureUrl )\n    Logic:setStartLeagueId( startLeagueId )\n    Logic:setBalance( balance )\n    Logic:setFbId( FbId )\n\n    EventManager:postEvent( Event.Check_File_Version, { configMd5Info, Event.Enter_Register_Name } )\nend\n","scripts.actions.EnterSelFavTeamAction":"module(..., package.seeall)\n\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\nfunction action( param )\n\n\tif Logic:getStartLeagueId() == 0 then\n\t\tlocal selFavTeamScene = require(\"scripts.views.SelFavTeamScene\")\n    \tselFavTeamScene.loadFrame()\n\telse\n\t    EventManager:postEvent( Event.Enter_Match_List )\n\tend\nend\n","scripts.config.Team":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal JsonConfigReader = require(\"scripts.config.JsonConfigReader\")\nlocal DoLogReport = require(\"scripts.actions.DoLogReport\")\n\n\nlocal FILE_NAME = \"config/teams.txt\"\nlocal mConfig = {}\nlocal mIndex = {}\nlocal mConfigNum = 0\n\nfunction init()\n\tif mConfigNum > 0 then \n\t\treturn\n\tend\n\tprint(\"Read Team config.\")\n\tmConfig, mConfigNum, mIndex = JsonConfigReader.read( FILE_NAME, \"Id\" )\nend\n\nfunction getConfig( id )\n\tif id == nil then\n\t\treturn nil\n\tend\n\tassert( mConfig[id] ~= nil, FILE_NAME..\" dosen't has \"..id )\n\n\treturn mConfig[id]\nend\n\nfunction getConfigIdByKey( key )\n\tif key == nil then\n\t\treturn nil\n\tend\n\tif mIndex[key] == nil then\n\t\tlocal log = FILE_NAME..\" dosen't has \"..key\n\t\tprint( log )\n\t\tDoLogReport.reportConfigError( log )\n\tend\n\n\treturn mIndex[key]\nend\n\nfunction getConfigNum()\n\treturn mConfigNum\nend\n\n--[[\n\tProvide additional getters.\n--]]\n\nfunction getTeamId( id )\n\tlocal config = getConfig( id )\n\tif config ~= nil then\n\t\treturn config[\"Id\"]\n\telse\n\t\treturn 0\n\tend\nend\n\nfunction getTeamName( id )\n\tlocal config = getConfig( id )\n\tif config ~= nil then\n\t\treturn config[\"teamName\"]\n\telse\n\t\tif id ~= nil then\n\t\t\treturn \"Unknow team: \"..id\n\t\telse\n\t\t\treturn \"Unknow team\"\n\t\tend\n\tend\nend\n\nfunction getLogo( id )\n\tlocal config = getConfig( id )\n\n\tif config ~= nil then\n\t\tlocal fileUtils = CCFileUtils:sharedFileUtils()\n\t\tlocal filePath = fileUtils:fullPathForFilename( Constants.TEAM_IMAGE_PATH..config[\"Id\"]..\".png\" )\n\t\tif fileUtils:isFileExist( filePath ) then\n\t\t\treturn Constants.TEAM_IMAGE_PATH..config[\"Id\"]..\".png\"\n\t\telse\n\t\t\treturn Constants.TEAM_IMAGE_PATH..\"default.png\"\n\t\tend\n\telse\n\t\treturn Constants.TEAM_IMAGE_PATH..\"default.png\"\n\tend\nend\n\nfunction getThumbUrl( id )\n\tlocal config = getConfig( id )\n\tif config ~= nil then\n\t\treturn config[\"thumbUrl\"]\n\telse\n\t\treturn \"Unknown\"\n\tend\n\t\nend\n\ninit()\n","scripts.actions.EnterSettingsAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal SettingsScene = require(\"scripts.views.SettingsScene\")\n\tif SettingsScene.isFrameShown() then\n\t\treturn\n\tend\n    SettingsScene.loadFrame()\nend\n","scripts.views.CreateCompetitionScene":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ViewUtils = require(\"scripts.views.ViewUtils\")\nlocal CountryConfig = require(\"scripts.config.Country\")\n\n\nlocal mWidget\nlocal mTextInput\n\nlocal mTitleText\nlocal mDescriptionText\nlocal mDay\nlocal mMonth\nlocal mYear\n\nfunction loadFrame()\n    local widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/CreateCompetition.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget(widget)\n\n    createTextInput()\n\n    if mTitleText ~= nil then\n        mWidget:getChildByName( \"TitleInput\" ):getNodeByTag( 1 ):setText( mTitleText )\n    end\n\n    if mDescriptionText ~= nil then\n        tolua.cast( mWidget:getChildByName( \"DescriptionText\" ), \"Label\" ):setText( mDescriptionText )\n    end\n\n    if mDay ~= nil then\n        mWidget:getChildByName( \"DayInput\" ):getNodeByTag( 1 ):setText( mDay )\n    end\n\n    if mMonth ~= nil then\n        mWidget:getChildByName( \"MonthInput\" ):getNodeByTag( 1 ):setText( mMonth )\n    end\n\n    if mYear ~= nil then\n        mWidget:getChildByName( \"YearInput\" ):getNodeByTag( 1 ):setText( mYear )\n    end\n\n    if Logic:getSelectedLeagues() == nil then\n        Logic:setSelectedLeagues( CountryConfig.getAllLeagues() )\n    end\n\n    local confirmBt = widget:getChildByName(\"Create\")\n    confirmBt:addTouchEventListener( confirmEventHandler )\n    local backBt = widget:getChildByName(\"Back\")\n    backBt:addTouchEventListener( backEventHandler )\n    local selectLeagueBt = widget:getChildByName(\"SelectLeague\")\n    selectLeagueBt:addTouchEventListener( selectLeagueEventHandler )\n\n    local desTextDisplay = mWidget:getChildByName(\"DescriptionText\")\n    desTextDisplay:addTouchEventListener( desInputEventHandler )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n        mTextInput = nil\n    end\nend\n\nfunction confirmEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        -- Check the date\n        local checkPass = true\n        local checkDate = function()\n            local endYear = tonumber( mWidget:getChildByName( \"YearInput\" ):getNodeByTag( 1 ):getText() )\n            local endMonth = tonumber( mWidget:getChildByName( \"MonthInput\" ):getNodeByTag( 1 ):getText() )\n            local endDay = tonumber( mWidget:getChildByName( \"DayInput\" ):getNodeByTag( 1 ):getText() )\n            local endTime = os.time{ year = endYear, month = endMonth, day = endDay, hour = 0 }\n\n            local checkYear = tonumber( os.date(\"%Y\", endTime) )\n            local checkMonth = tonumber( os.date(\"%m\", endTime) )\n            local checkDay = tonumber( os.date(\"%d\", endTime) )\n            \n            if endYear ~= checkYear or endMonth ~= checkMonth or endDay ~= checkDay then\n                print( endYear..\"/\"..endMonth..\"/\"..endDay..\" | \"..checkYear..\"/\"..checkMonth..\"/\"..checkDay )\n                checkPass = false\n            end\n        end\n\n        local errorHandler = function( msg )\n            print( msg )\n            print(debug.traceback())\n            checkPass = false\n        end\n\n        xpcall( checkDate, errorHandler )\n        \n        if checkPass then\n            sendCreateCompetition()\n        else\n            EventManager:postEvent( Event.Show_Error_Message, { \"Date format is not correct.\" } )\n        end\n    end\nend\n\nfunction sendCreateCompetition()\n    local endTime = os.time{ year = tonumber( mWidget:getChildByName( \"YearInput\" ):getNodeByTag( 1 ):getText() ), \n                            month = tonumber( mWidget:getChildByName( \"MonthInput\" ):getNodeByTag( 1 ):getText() ), \n                            day = tonumber( mWidget:getChildByName( \"DayInput\" ):getNodeByTag( 1 ):getText() ),\n                            hour = 0 }\n    local name = mWidget:getChildByName( \"TitleInput\" ):getNodeByTag( 1 ):getText()\n    local description = tolua.cast( mWidget:getChildByName( \"DescriptionText\" ), \"Label\" ):getStringValue()\n    local selectedLeagues = Logic:getSelectedLeagues() or {}\n\n    EventManager:postEvent( Event.Do_Create_Competition, { name, description, endTime, selectedLeagues } )\nend\n\nfunction backEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        EventManager:popHistory()\n    end\nend\n\nfunction cancelEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        SceneManager.removeWidget( mWidget )\n    end\nend\n\nfunction selectLeagueEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        -- Cache the content so that they will not got missing back from the league select UI.\n        mTitleText = mWidget:getChildByName( \"TitleInput\" ):getNodeByTag( 1 ):getText()\n        mDescriptionText = tolua.cast( mWidget:getChildByName( \"DescriptionText\" ), \"Label\" ):getStringValue()\n        mDay = mWidget:getChildByName( \"DayInput\" ):getNodeByTag( 1 ):getText()\n        mMonth = mWidget:getChildByName( \"MonthInput\" ):getNodeByTag( 1 ):getText()\n        mYear = mWidget:getChildByName( \"YearInput\" ):getNodeByTag( 1 ):getText()\n\n        EventManager:postEvent( Event.Enter_View_Selected_Leagues )\n    end\nend\n\nfunction desInputEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        mTextInput:touchDownAction( sender, eventType )\n    end\nend\n\nfunction createTextInput()\n    -- Title\n    local titleInput = ViewUtils.createTextInput( mWidget:getChildByName( \"TitleInput\" ), \"Title\", 520, 50 )\n    titleInput:setFontColor( ccc3( 0, 0, 0 ) )\n    titleInput:setTouchPriority( SceneManager.TOUCH_PRIORITY_MINUS_ONE )\n\n    -- Description\n    local container = mWidget:getChildByName(\"DescriptionInput\")\n\n    local inputDelegate = EditBoxDelegateForLua:create()\n    inputDelegate:registerEventScriptHandler( EDIT_BOX_EVENT_TEXT_CHANGED, function ( textBox, text )\n        local textDisplay = tolua.cast( mWidget:getChildByName(\"DescriptionText\"), \"Label\" )\n        textDisplay:setText( text )\n    end )\n    container:addNode( tolua.cast( inputDelegate, \"CCNode\" ) )\n\n    mTextInput = CCEditBox:create( CCSizeMake( 550, 35 ), CCScale9Sprite:create() )\n    container:addNode( mTextInput )\n    mTextInput:setPosition( 550 / 2, 35 / 2 )\n    mTextInput:setFontColor( ccc3( 0, 0, 0 ) )\n    mTextInput:setVisible( false )\n    mTextInput:setDelegate( inputDelegate.__CCEditBoxDelegate__ )\n\n    -- DD/MM/YYYY\n    local dayInput = ViewUtils.createTextInput( mWidget:getChildByName( \"DayInput\" ), \"DD\", 110, 50 )\n    dayInput:setFontColor( ccc3( 0, 0, 0 ) )\n    dayInput:setInputMode( kEditBoxInputModeNumeric )\n    dayInput:setMaxLength( 2 )\n    dayInput:setTouchPriority( SceneManager.TOUCH_PRIORITY_MINUS_ONE )\n\n    local monthInput = ViewUtils.createTextInput( mWidget:getChildByName( \"MonthInput\" ), \"MM\", 110, 50 )\n    monthInput:setFontColor( ccc3( 0, 0, 0 ) )\n    monthInput:setInputMode( kEditBoxInputModeNumeric )\n    monthInput:setMaxLength( 2 )\n    monthInput:setTouchPriority( SceneManager.TOUCH_PRIORITY_MINUS_ONE )\n\n    local yearInput = ViewUtils.createTextInput( mWidget:getChildByName( \"YearInput\" ), \"YYYY\", 150, 50 )\n    yearInput:setFontColor( ccc3( 0, 0, 0 ) )\n    yearInput:setInputMode( kEditBoxInputModeNumeric )\n    yearInput:setMaxLength( 4 )\n    yearInput:setTouchPriority( SceneManager.TOUCH_PRIORITY_MINUS_ONE )\nend\n","scripts.actions.LoadMoreInHistoryAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal RequestUtils = require(\"scripts.RequestUtils\")\n\nfunction action( param )\n    local step = param[1]\n    \n    local url = RequestUtils.GET_COUPON_HISTORY_REST_CALL..\"?userId=\"..Logic:getUserId()..\"&step=\"..step\n\n    local requestInfo = {}\n    requestInfo.requestData = \"\"\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( response )\n    local CouponHistoryData = require(\"scripts.data.CouponHistoryData\").CouponHistoryData\n    local couponHistory = CouponHistoryData:new( response )\n    \n    local historyMainScene = require(\"scripts.views.HistoryMainScene\")\n    historyMainScene.loadMoreContent( couponHistory )\nend\n","scripts.views.MatchListScene":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal CountryConfig = require(\"scripts.config.Country\")\nlocal LeagueConfig = require(\"scripts.config.League\")\nlocal TeamConfig = require(\"scripts.config.Team\")\nlocal Navigator = require(\"scripts.views.Navigator\")\nlocal LeagueListScene = require(\"scripts.views.LeagueListScene\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal SMIS = require(\"scripts.SMIS\")\n\n\nlocal mWidget\nlocal mTopLayer\nlocal mOptionPanelShown\nlocal mTheFirstDate = nil\n\nlocal MIN_MOVE_DISTANCE = 100\nlocal OPTION_MOVE_TIME = 0.5\nlocal OPTION_VIEW_OFFSET_X = 475\n\nlocal CONTENT_FADEIN_TIME = 0.1\nlocal CONTENT_DELAY_TIME = 0.2\n\nfunction isShown()\n    return mWidget ~= nil\nend\n\nfunction loadFrame( matchList )\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/MatchListScene.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget( widget )\n\n    Navigator.loadFrame( widget )\n\n    -- Init the match list according to the data.\n    initMatchList( matchList )\n\n    -- Init the league list\n    LeagueListScene.loadFrame( \"scenes/CountryListContent.json\", \"scenes/LeagueListContent.json\", \n        tolua.cast( mWidget:getChildByName(\"leagueList\"), \"ScrollView\" ), leagueSelectedCallback )\n\n    -- Option button\n    local optionBt = widget:getChildByName(\"option\")\n    optionBt:addTouchEventListener( optionEventHandler )\n\n    local userName = tolua.cast( widget:getChildByName(\"userName\"), \"Label\" )\n    userName:setText( Logic:getDisplayName() )\n    \n    if Logic:getPictureUrl() ~= nil then\n        local handler = function( filePath )\n            if filePath ~= nil then\n                local userLogo = tolua.cast( widget:getChildByName(\"userPhoto\"), \"ImageView\" )\n                userLogo:loadTexture( filePath )\n                userLogo:setScale( 1 )\n            end\n        end\n        SMIS.getSMImagePath( Logic:getPictureUrl(), handler )\n    end\n\n    -- Init the toplayer to listen to the swap action.\n    mTopLayer = CCLayer:create()\n    mTopLayer:registerScriptTouchHandler( onTopLevelTouch, false, -100)\n    mWidget:addNode( mTopLayer )\n    mOptionPanelShown = false\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\n-- Param matchList is Object of MatchListData\nfunction initMatchList( matchList ) \n    local contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n    contentContainer:removeAllChildrenWithCleanup( true )\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n    local contentHeight = 0\n\n    local seqArray = CCArray:create()\n    \n    mTheFirstDate = nil\n    for k,v in pairs( matchList:getMatchDateList() ) do\n        local matchDate = v\n\n        local zOrder = matchDate[\"date\"]\n        seqArray:addObject( CCCallFuncN:create( function()\n            -- Add the date\n            local content = SceneManager.widgetFromJsonFile(\"scenes/MatchDate.json\")\n            local dateDisplay = tolua.cast( content:getChildByName(\"date\"), \"Label\" )\n            dateDisplay:setText( matchDate[\"dateDisplay\"] )\n            content:setLayoutParameter( layoutParameter )\n            content:setZOrder( zOrder )\n            contentContainer:addChild( content )\n            contentHeight = contentHeight + content:getSize().height\n\n            if mTheFirstDate == nil then\n                mTheFirstDate = content\n            end\n\n            content:setOpacity( 0 )\n            content:setCascadeOpacityEnabled( true )\n            mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )\n\n            updateContentContainer( contentHeight, content )\n        end ) )\n        seqArray:addObject( CCDelayTime:create( CONTENT_DELAY_TIME ) )\n\n        seqArray:addObject( CCCallFuncN:create( function()\n            -- Add the seprater\n            local upper = ImageView:create()\n            upper:loadTexture(\"images/guang.png\")\n            upper:setLayoutParameter( layoutParameter )\n            upper:setZOrder( zOrder )\n            contentContainer:addChild( upper )\n            contentHeight = contentHeight + upper:getSize().height\n\n            upper:setOpacity( 0 )\n            mWidget:runAction( CCTargetedAction:create( upper, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )\n\n            updateContentContainer( contentHeight, upper )\n        end ) )\n        seqArray:addObject( CCDelayTime:create( CONTENT_DELAY_TIME ) )\n        \n\n        for inK, inV in pairs( matchDate[\"matches\"] ) do\n            local eventHandler = function( sender, eventType )\n                if eventType == TOUCH_EVENT_ENDED then\n                    enterMatch( inV )\n                end\n            end\n\n            seqArray:addObject( CCCallFuncN:create( function() \n                local content = SceneManager.widgetFromJsonFile(\"scenes/MatchListContent.json\")\n                helperInitMatchInfo( content, inV )\n\n                content:setLayoutParameter( layoutParameter )\n                content:setZOrder( zOrder )\n                contentContainer:addChild( content )\n                contentHeight = contentHeight + content:getSize().height\n\n                content:addTouchEventListener( eventHandler )\n\n                content:setOpacity( 0 )\n                content:setCascadeOpacityEnabled( true )\n                mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )\n\n                updateContentContainer( contentHeight, content )\n            end ) )\n            seqArray:addObject( CCDelayTime:create( CONTENT_DELAY_TIME ) )\n        end\n\n        seqArray:addObject( CCCallFuncN:create( function() \n            -- Add the seprater\n            local bottom = ImageView:create()\n            bottom:loadTexture(\"images/guang.png\")\n            bottom:setFlipY(true)\n            bottom:setLayoutParameter( layoutParameter )\n            bottom:setZOrder( zOrder )\n            contentContainer:addChild( bottom )\n            contentHeight = contentHeight + bottom:getSize().height\n\n            bottom:setOpacity( 0 )\n            mWidget:runAction( CCTargetedAction:create( bottom, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )\n\n            updateContentContainer( contentHeight, bottom )\n        end ) )\n        seqArray:addObject( CCDelayTime:create( CONTENT_DELAY_TIME ) )\n    end\n\n    seqArray:addObject( CCCallFuncN:create( function()\n        if contentContainer:getChildrenCount() == 0 then\n            local content = SceneManager.widgetFromJsonFile(\"scenes/MatchListEmptyIndi.json\")\n            content:setLayoutParameter( layoutParameter )\n            contentContainer:addChild( content )\n            contentHeight = contentHeight + content:getSize().height\n            updateContentContainer( contentHeight, content )\n        end\n    end ) )\n\n    mWidget:runAction( CCSequence:create( seqArray ) )\nend\n\nfunction updateContentContainer( contentHeight, addContent )\n    local contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n\n    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n    local layout = tolua.cast( contentContainer, \"Layout\" )\n    layout:requestDoLayout()\n\n    if mTheFirstDate ~= nil then\n        if addContent:getZOrder() < mTheFirstDate:getZOrder() then\n            local y = contentContainer:getInnerContainer():getPositionY() + addContent:getSize().height\n            contentContainer:jumpToDestination( ccp( 0, y ) )\n        end\n    end\nend\n\nfunction enterMatch( match )\n    if match[\"PredictionsPlayed\"] == match[\"PredictionsAvailable\"] then\n        EventManager:postEvent( Event.Show_Error_Message, { \"You have completed this match.\" } )\n        return\n    end\n\n    Logic:setSelectedMatch( match )\n    EventManager:postEvent( Event.Enter_Match )\nend\n\nfunction leagueSelectedCallback( leagueId )\n    hideOptionAnim( function()\n        EventManager:postEvent( Event.Enter_Match_List, { LeagueConfig.getConfigId( leagueId ) } )\n    end )\nend\n\nfunction helperInitMatchInfo( content, matchInfo )\n    local team1 = tolua.cast( content:getChildByName(\"team1\"), \"ImageView\" )\n    local team2 = tolua.cast( content:getChildByName(\"team2\"), \"ImageView\" )\n    local team1Name = tolua.cast( content:getChildByName(\"team1Name\"), \"Label\" )\n    local team2Name = tolua.cast( content:getChildByName(\"team2Name\"), \"Label\" )\n    local friendNum = tolua.cast( content:getChildByName(\"friendNum\"), \"Label\" )\n    local fhNum = tolua.cast( content:getChildByName(\"fhNum\"), \"Label\" )\n    local played = tolua.cast( content:getChildByName(\"played\"), \"Label\" )\n    \n    -- Load the team logo\n    team1:loadTexture( TeamConfig.getLogo( TeamConfig.getConfigIdByKey( matchInfo[\"HomeTeamId\"] ) ) )\n    team2:loadTexture( TeamConfig.getLogo( TeamConfig.getConfigIdByKey( matchInfo[\"AwayTeamId\"] ) ) )\n\n    -- Load the team names\n    local teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( matchInfo[\"HomeTeamId\"] ) )\n    if string.len( teamName ) > 20 then\n        team1Name:setFontSize( 20 )\n    end\n    team1Name:setText( teamName )\n    teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( matchInfo[\"AwayTeamId\"] ) )\n    if string.len( teamName ) > 20 then\n        team2Name:setFontSize( 20 )\n    end\n    team2Name:setText( teamName )\n\n    local time = tolua.cast( content:getChildByName(\"time\"), \"Label\" )\n    local score = tolua.cast( content:getChildByName(\"score\"), \"Label\" )\n    time:setFontName(\"fonts/Newgtbxc.ttf\")\n    score:setFontName(\"fonts/Newgtbxc.ttf\")\n    if matchInfo[\"HomeGoals\"] >= 0 and matchInfo[\"AwayGoals\"] >= 0 then\n        score:setText( string.format( score:getStringValue(), matchInfo[\"HomeGoals\"], matchInfo[\"AwayGoals\"] ) )\n        time:setEnabled( false )\n    else\n        time:setText( os.date( \"%H:%M\", matchInfo[\"StartTime\"] ) )\n        score:setEnabled( false )\n    end\n\n    if matchInfo[\"FriendsPlayed\"] > 0 then\n        friendNum:setText( matchInfo[\"FriendsPlayed\"] )\n    else\n        friendNum:setText(\"0\")\n    end\n    fhNum:setText( matchInfo[\"TotalUsersPlayed\"] )\n    played:setText( string.format( played:getStringValue(), matchInfo[\"PredictionsPlayed\"], matchInfo[\"PredictionsAvailable\"] ) )\n\n    local isGameStart = matchInfo[\"StartTime\"] > os.time()\n    if isGameStart then\n        content:setTouchEnabled( true )\n    else\n        content:setTouchEnabled( false )\n    end\nend\n\nfunction optionEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        if mOptionPanelShown then\n            hideOptionAnim()\n        else\n            showOptionAnim()\n        end\n    end\nend\n\nfunction onTopLevelTouch( eventType, x, y )\n    print( \"onTopLevelTouch\" )\n\n    if eventType == TOUCH_EVENT_ENDED then\n        local touchBeginPoint = sender:getTouchStartPos()\n        local touchEndPoint = sender:getTouchEndPos()\n        print( touchBeginPoint.x - touchEndPoint.x )\n        \n    end\nend\n\n\nlocal startPosX, startPosY\nfunction onTopLevelTouch( eventType, x, y )\n    if eventType == \"began\" then\n        startPosX, startPosY = x, y\n        return true\n    elseif eventType == \"ended\" then\n        if startPosX - x > MIN_MOVE_DISTANCE and mOptionPanelShown == true then\n            -- Swap to Left\n            hideOptionAnim()\n        elseif x - startPosX > MIN_MOVE_DISTANCE and mOptionPanelShown == false then\n            -- Swap to Right\n            showOptionAnim()\n        end\n    end\nend\n\nfunction showOptionAnim( callbackFunc )\n    local optionBt = mWidget:getChildByName(\"option\")\n    optionBt:setTouchEnabled( false )\n    mTopLayer:setTouchEnabled( false )\n\n    local seqArray = CCArray:create()\n    seqArray:addObject( CCMoveBy:create( OPTION_MOVE_TIME, ccp( OPTION_VIEW_OFFSET_X, 0 ) ) )\n    seqArray:addObject( CCCallFuncN:create( function()\n        optionBt:setTouchEnabled( true )\n        mTopLayer:setTouchEnabled( true )\n        mOptionPanelShown = true\n\n        if callbackFunc ~= nil then\n            callbackFunc()\n        end\n    end ) )\n    mWidget:runAction( CCSequence:create( seqArray ) )\nend\n\nfunction hideOptionAnim( callbackFunc )\n    local optionBt = mWidget:getChildByName(\"option\")\n    optionBt:setTouchEnabled( false )\n    mTopLayer:setTouchEnabled( false )\n\n    local seqArray = CCArray:create()\n    seqArray:addObject( CCMoveBy:create( OPTION_MOVE_TIME, ccp( OPTION_VIEW_OFFSET_X * (-1), 0 ) ) )\n    seqArray:addObject( CCCallFuncN:create( function()\n        optionBt:setTouchEnabled( true )\n        mTopLayer:setTouchEnabled( true )\n        mOptionPanelShown = false\n\n        if callbackFunc ~= nil then\n            callbackFunc()\n        end\n    end ) )\n    mWidget:runAction( CCSequence:create( seqArray ) )\nend\n","scripts.actions.EnterHistoryAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal RequestUtils = require(\"scripts.RequestUtils\")\n\n\nlocal mUserId = Logic:getUserId()\nlocal mUserName = \"\"\n\nfunction action( param )\n    local historyMainScene = require(\"scripts.views.HistoryMainScene\")\n    if historyMainScene.isFrameShown() then\n        return \n    end                                                             \n\n\tlocal step = 1\n    \n    mUserId = Logic:getUserId()\n    if param ~= nil and param[1] ~= nil and param[2] ~= nil then\n        mUserId = param[1]\n        mUserName = param[2]\n    end\n\n\tlocal url = RequestUtils.GET_COUPON_HISTORY_REST_CALL..\"?userId=\"..mUserId..\"&step=\"..step\n\n    local requestInfo = {}\n    requestInfo.requestData = \"\"\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( response )\n    local CouponHistoryData = require(\"scripts.data.CouponHistoryData\").CouponHistoryData\n    local couponHistory = CouponHistoryData:new( response )\n    \n    local historyMainScene = require(\"scripts.views.HistoryMainScene\")\n    historyMainScene.loadFrame( mUserId, mUserName, couponHistory )\nend\n","scripts.SMIS":"module(..., package.seeall)\n\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal FileUtils = require(\"scripts.FileUtils\")\n\nlocal FOLDER = \"SMI/\"\n\n-- Return the local file path if the file exist.\n-- Otherwise download it, save it locally and return the file path.\nfunction getSMImagePath( fileUrl, handler )\n\tlocal fileName = fileUrl\n\t\n\tlocal toBeRemove = string.find(fileName, \"?\")\n\tif toBeRemove ~= nil then\n\t\t\tfileName = string.sub(fileName, 1, toBeRemove - 1)\n\tend\n\n\tlocal list = RequestUtils.split( fileName, \"/\" )\n\tfileName = list[table.getn( list )]\n\n\tlocal fileUtils = CCFileUtils:sharedFileUtils()\n\tlocal path = fileUtils:getWritablePath()..FOLDER..fileName\n\tif fileUtils:isFileExist( path ) then\n\t\thandler( path )\n\telse\n\t\tlocal successHandler = function( body )\n\t\t\tFileUtils.writeStringToFile( FOLDER..fileName, body )\n\t\t\thandler( path )\n\t\tend\n\n\t\tlocal failedHandler = function()\n\t\t\thandler( nil )\n\t\tend\n\n\t\tdownloadSMImage( fileUrl, successHandler, failedHandler )\n\tend\nend\n\nfunction downloadSMImage( fileUrl, onRequestSuccess, onRequestFailed )\n\tlocal handler = function( isSucceed, body, header, status, errorBuffer )\n        print( \"Http reponse: \"..status..\" and errorBuffer: \"..errorBuffer )\n\n        if status == RequestUtils.HTTP_200 then\n            onRequestSuccess( body )\n        else\n            onRequestFailed()\n        end\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:sendHttpRequest( fileUrl, handler )\nend\n","scripts.views.FAQScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\n\n\nlocal mWidget\n\nfunction loadFrame()\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/FAQ.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget( widget )\n\n    local backBt = widget:getChildByName(\"back\")\n    backBt:addTouchEventListener( backEventHandler )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n        WebviewDelegate:sharedDelegate():openWebpage( \"http://www.baidu.com\", 0, 40, 320, 528 )\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction isFrameShown()\n    return mWidget ~= nil\nend\n\nfunction backEventHandler( sender,eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        WebviewDelegate:sharedDelegate():closeWebpage()\n        EventManager:popHistory()\n    end\nend\n","scripts.actions.EnterViewSelectedLeaguesAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal SelectedLeaguesScene = require(\"scripts.views.SelectedLeaguesScene\")\n    SelectedLeaguesScene.loadFrame()\nend\n","scripts.SceneManager":"module(..., package.seeall)\n\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal CheckFilesVersionAction = require(\"scripts.actions.CheckFilesVersionAction\")\nlocal EnterMatchListAction = require(\"scripts.actions.EnterMatchListAction\")\nlocal EnterMatchAction = require(\"scripts.actions.EnterMatchAction\")\nlocal EnterPredictionConfirmAction = require(\"scripts.actions.EnterPredictionConfirmAction\")\nlocal EnterPredTotalConfirmAction = require(\"scripts.actions.EnterPredTotalConfirmAction\")\nlocal EnterLoginNRegAction = require(\"scripts.actions.EnterLoginNRegAction\")\nlocal EnterRegisterAction = require(\"scripts.actions.EnterRegisterAction\")\nlocal EnterRegisterNameAction = require(\"scripts.actions.EnterRegisterNameAction\")\nlocal EnterLoginAction = require(\"scripts.actions.EnterLoginAction\")\nlocal EnterForgotPasswordAction = require(\"scripts.actions.EnterForgotPasswordAction\")\nlocal EnterSelFavTeamAction = require(\"scripts.actions.EnterSelFavTeamAction\")\nlocal EnterNextPredictionAction = require(\"scripts.actions.EnterNextPredictionAction\")\nlocal EnterHistoryAction = require(\"scripts.actions.EnterHistoryAction\")\nlocal EnterHistoryDetailAction = require(\"scripts.actions.EnterHistoryDetailAction\")\nlocal EnterLeaderboardAction = require(\"scripts.actions.EnterLeaderboardAction\")\nlocal EnterLeaderboardListAction = require(\"scripts.actions.EnterLeaderboardListAction\")\nlocal EnterSettingsAction = require(\"scripts.actions.EnterSettingsAction\")\nlocal EnterFAQAction = require(\"scripts.actions.EnterFAQAction\")\nlocal EnterCreateCompetitionAction = require(\"scripts.actions.EnterCreateCompetitionAction\")\nlocal EnterViewSelectedLeaguesAction = require(\"scripts.actions.EnterViewSelectedLeaguesAction\")\nlocal EnterCompetitionLeaguesAction = require(\"scripts.actions.EnterCompetitionLeaguesAction\")\nlocal EnterCompetitionDetailAction = require(\"scripts.actions.EnterCompetitionDetailAction\")\nlocal DoRegisterAction = require(\"scripts.actions.DoRegisterAction\")\nlocal DoLoginAction = require(\"scripts.actions.DoLoginAction\")\nlocal DoRegisterNameAction = require(\"scripts.actions.DoRegisterNameAction\")\nlocal DoFBConnectAction = require(\"scripts.actions.DoFBConnectAction\")\nlocal DoFBConnectWithUserAction = require(\"scripts.actions.DoFBConnectWithUserAction\")\nlocal DoPostPredictionsAction = require(\"scripts.actions.DoPostPredictionsAction\")\nlocal DoPostFavTeamAction = require(\"scripts.actions.DoPostFavTeamAction\")\nlocal DoLogOutAction = require(\"scripts.actions.DoLogOutAction\")\nlocal DoCreateCompetitionAction = require(\"scripts.actions.DoCreateCompetitionAction\")\nlocal DoJoinCompetitionAction = require(\"scripts.actions.DoJoinCompetitionAction\")\nlocal ShowErrorMessageAction = require(\"scripts.actions.ShowErrorMessageAction\")\nlocal ShowInfoAction = require(\"scripts.actions.ShowInfoAction\")\nlocal LoadMoreInLeaderboardAction = require(\"scripts.actions.LoadMoreInLeaderboardAction\")\nlocal LoadMoreInHistoryAction = require(\"scripts.actions.LoadMoreInHistoryAction\")\nlocal LoadMoreInCompetitionDetailAction = require(\"scripts.actions.LoadMoreInCompetitionDetailAction\")\n\nTOUCH_PRIORITY_ZERO = 0\nTOUCH_PRIORITY_MINUS_ONE = -1\n\nlocal mSceneGameLayer\nlocal mWidgets = {}\t\t-- Store widget show in the list to save time loading the same json file.\n\nfunction init()\n\tlocal eglView = CCEGLView:sharedOpenGLView()\n\tif CCApplication:sharedApplication():getTargetPlatform() == kTargetWindows then\n\t\teglView:setFrameSize( 541, 960 )\n\tend\n\teglView:setDesignResolutionSize( 640, 1136, kResolutionShowAll )\n\n\tlocal sceneGame = CCScene:create()\n\tlocal director = CCDirector:sharedDirector()\n    if director:getRunningScene() ~= nil then\n    \tdirector:replaceScene( sceneGame )\n    else\n    \tdirector:runWithScene( sceneGame )\n    end\n    \n    mSceneGameLayer = TouchGroup:create()\n    sceneGame:addChild( mSceneGameLayer )\n\n    initEvents()\nend\n\nfunction initEvents()\n\tEventManager:registerEventHandler( Event.Check_File_Version, CheckFilesVersionAction )\n\tEventManager:registerEventHandler( Event.Enter_Login_N_Reg, EnterLoginNRegAction )\n\tEventManager:registerEventHandler( Event.Enter_Register, EnterRegisterAction )\n\tEventManager:registerEventHandler( Event.Enter_Register_Name, EnterRegisterNameAction )\n\tEventManager:registerEventHandler( Event.Enter_Login, EnterLoginAction )\n\tEventManager:registerEventHandler( Event.Enter_Forgot_Password, EnterForgotPasswordAction )\n\tEventManager:registerEventHandler( Event.Enter_Match_List, EnterMatchListAction )\n\tEventManager:registerEventHandler( Event.Enter_Match, EnterMatchAction )\n\tEventManager:registerEventHandler( Event.Enter_Prediction_Confirm, EnterPredictionConfirmAction )\n\tEventManager:registerEventHandler( Event.Enter_Pred_Total_Confirm, EnterPredTotalConfirmAction )\n\tEventManager:registerEventHandler( Event.Enter_Sel_Fav_Team, EnterSelFavTeamAction )\n\tEventManager:registerEventHandler( Event.Enter_Next_Prediction, EnterNextPredictionAction )\n\tEventManager:registerEventHandler( Event.Enter_History, EnterHistoryAction )\n\tEventManager:registerEventHandler( Event.Enter_History_Detail, EnterHistoryDetailAction )\n\tEventManager:registerEventHandler( Event.Enter_Leaderboard, EnterLeaderboardAction )\n\tEventManager:registerEventHandler( Event.Enter_Leaderboard_List, EnterLeaderboardListAction )\n\tEventManager:registerEventHandler( Event.Enter_Settings, EnterSettingsAction )\n\tEventManager:registerEventHandler( Event.Enter_FAQ, EnterFAQAction )\n\tEventManager:registerEventHandler( Event.Enter_Create_Competition, EnterCreateCompetitionAction )\n\tEventManager:registerEventHandler( Event.Enter_View_Selected_Leagues, EnterViewSelectedLeaguesAction )\n\tEventManager:registerEventHandler( Event.Enter_Competition_Leagues, EnterCompetitionLeaguesAction )\n\tEventManager:registerEventHandler( Event.Enter_Competition_Detail, EnterCompetitionDetailAction )\n\tEventManager:registerEventHandler( Event.Do_Register, DoRegisterAction )\n\tEventManager:registerEventHandler( Event.Do_Register_Name, DoRegisterNameAction )\n\tEventManager:registerEventHandler( Event.Do_Login, DoLoginAction )\n\tEventManager:registerEventHandler( Event.Do_FB_Connect, DoFBConnectAction )\n\tEventManager:registerEventHandler( Event.Do_FB_Connect_With_User, DoFBConnectWithUserAction )\n\tEventManager:registerEventHandler( Event.Do_Post_Predictions, DoPostPredictionsAction )\n\tEventManager:registerEventHandler( Event.Do_Post_Fav_Team, DoPostFavTeamAction )\n\tEventManager:registerEventHandler( Event.Do_Log_Out, DoLogOutAction )\n\tEventManager:registerEventHandler( Event.Do_Create_Competition, DoCreateCompetitionAction )\n\tEventManager:registerEventHandler( Event.Do_Join_Competition, DoJoinCompetitionAction )\n\tEventManager:registerEventHandler( Event.Show_Error_Message, ShowErrorMessageAction )\n\tEventManager:registerEventHandler( Event.Show_Info, ShowInfoAction )\n\tEventManager:registerEventHandler( Event.Load_More_In_Leaderboard, LoadMoreInLeaderboardAction )\n\tEventManager:registerEventHandler( Event.Load_More_In_History, LoadMoreInHistoryAction )\n\tEventManager:registerEventHandler( Event.Load_More_In_Competition_Detail, LoadMoreInCompetitionDetailAction )\nend\n\nfunction clearNAddWidget( widget )\n\tmSceneGameLayer:clear()\n\taddWidget( widget )\nend\n\nfunction clear()\n\tmSceneGameLayer:clear()\nend\n\nfunction addWidget( widget )\n\tmSceneGameLayer:addWidget( widget )\nend\n\nfunction removeWidget( widget )\n\tmSceneGameLayer:removeWidget( widget )\nend\n\nfunction widgetFromJsonFile( fileName )\n\tif mWidgets[fileName] == nil then\n\t\tlocal content = GUIReader:shareReader():widgetFromJsonFile( fileName )\n\t\tcontent:retain()\n\t\tmWidgets[fileName] = content\n\tend\n\treturn mWidgets[fileName]:clone()\nend\n","scripts.actions.EnterHistoryDetailAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal historyDetailScene = require(\"scripts.views.HistoryDetailScene\")\n    historyDetailScene.loadFrame( param[1], param[2] )\nend\n","scripts.actions.DoPostPredictionsAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal Constants = require(\"scripts.Constants\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\n\nfunction action( param )\n    if Logic:getPredictions():getSize() > 0 then\n        postPredictionData()\n    else\n        EventManager:postEvent( Event.Enter_Match_List )\n    end\nend\n\nfunction postPredictionData()\n\tlocal requestContentText = Logic:getPredictions():toString()\n\n    local url = RequestUtils.POST_COUPONS_REST_CALL\n\n    local requestInfo = {}\n    requestInfo.requestData = requestContentText\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess, onRequestFailed )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )\n    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    \n    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    local balance = jsonResponse[\"Balance\"]\n\n    Logic:resetPredictions()\n    Logic:setBalance( balance )\n    EventManager:postEvent( Event.Enter_Match_List )\nend\n\nfunction onRequestFailed( jsonResponse )\n    local errorBuffer = jsonResponse[\"Message\"]\n    EventManager:postEvent( Event.Show_Error_Message, { errorBuffer, postPredictionData } )\nend\n","scripts.actions.ShowInfoAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal errorMessage = require(\"scripts.views.ErrorMessage\")\n    errorMessage.loadFrame()\n    errorMessage.setTitle( param[3] or \"Info\" )\n    errorMessage.setErrorMessage( param[1], param[2] )\nend\n","scripts.actions.DoJoinCompetitionAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal Constants = require(\"scripts.Constants\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\nfunction action( param )\n\n    local token = param[1]\n\n    if string.len( token ) == 0 then\n        RequestUtils.onRequestFailed( \"Token cannot be blank.\" )\n        return\n    end\n\n    local requestContent = { JoinToken = token }\n    local requestContentText = Json.encode( requestContent )\n    \n    local url = RequestUtils.POST_JOIN_COMPETITION_REST_CALL\n\n    local requestInfo = {}\n    requestInfo.requestData = requestContentText\n    requestInfo.url = url\n\n     local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )\n    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    if jsonResponse == true then\n        print(  )\n    end\nend\n","scripts.views.ScorePrediction":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal TeamConfig = require(\"scripts.config.Team\")\nlocal MarketConfig = require(\"scripts.config.Market\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal MarketsForGameData = require(\"scripts.data.MarketsForGameData\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\n\nlocal mWidget\nlocal mMatch\nlocal mMarketsData\n\nlocal MIN_MOVE_DISTANCE = 100\nlocal SCALE_BASE = 0.6\nlocal SCALE_UP_OFFSET_MAX = 0.2\nlocal SCALE_DOWN_OFFSET_MAX = -0.2\nlocal OPACITY = 255\n\nfunction loadFrame()\n    mMatch = Logic:getSelectedMatch()\n    mMarketsData = Logic:getCurMarketInfo():getMarketAt( Logic:getCurDisplayMarketIndex() )\n\n    local widget = GUIReader:shareReader():widgetFromJsonFile( getWidgetConfigFile() )\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    mWidget:addTouchEventListener( onFrameTouch )\n    SceneManager.clearNAddWidget( widget )\n\n    local backBt = widget:getChildByName(\"Back\")\n    local skipBt = widget:getChildByName(\"skip\")\n    backBt:addTouchEventListener( backEventHandler )\n    skipBt:addTouchEventListener( skipEventHandler )\n\n    helperInitMarketInfo( widget )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction getWidgetConfigFile()\n    local marketType = MarketsForGameData.getMarketType( mMarketsData )\n\n    if marketType == MarketConfig.MARKET_TYPE_TOTAL_GOAL then\n        return \"scenes/WTGBMTPrediction.json\"\n    elseif marketType == MarketConfig.MARKET_TYPE_ASIAN_HANDICAP then\n        return \"scenes/WTWBEGPrediction.json\"\n    end\n\n    return \"scenes/WTCBMTPrediction.json\"\nend\n\nfunction selectYes()\n    local yes = tolua.cast( mWidget:getChildByName(\"yes\"), \"ImageView\" )\n    makePrediction(\n        MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION ),\n        MarketsForGameData.getOddIdForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION ),\n        helperGetTheAnswer( true ),\n        yes:getTextureFile() )\nend\n\nfunction selectNo()\n    local no = tolua.cast( mWidget:getChildByName(\"no\"), \"ImageView\" )\n    makePrediction(\n        MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION ),\n        MarketsForGameData.getOddIdForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION ),\n        helperGetTheAnswer( false ),\n        no:getTextureFile() )\nend\n\nfunction skipEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        SceneManager.clear()\n        EventManager:postEvent( Event.Enter_Next_Prediction )\n    end\nend\n\nfunction backEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        EventManager:postEvent( Event.Do_Post_Predictions )\n    end\nend\n\nfunction makePrediction( rewards, oddId, answer, answerIcon )\n    local seqArray = CCArray:create()\n    seqArray:addObject( CCDelayTime:create( 0.1 ) )\n    seqArray:addObject( CCCallFuncN:create( function()\n        --EventManager:postEvent( Event.Enter_Prediction_Confirm, { answer, rewards, oddId, answerIcon } )\n\n        Logic:addPrediction( oddId, answer, rewards, answerIcon )\n        EventManager:postEvent( Event.Enter_Next_Prediction )\n    end ) )\n\n    mWidget:runAction( CCSequence:create( seqArray ) )\n    \nend\n\nfunction helperInitMarketInfo( content )\n    local team1Name = tolua.cast( content:getChildByName(\"team1Name\"), \"Label\" )\n    local team2Name = tolua.cast( content:getChildByName(\"team2Name\"), \"Label\" )\n    local yes = tolua.cast( mWidget:getChildByName(\"yes\"), \"ImageView\" )\n    local no = tolua.cast( mWidget:getChildByName(\"no\"), \"ImageView\" )\n    local answer1Point = tolua.cast( yes:getChildByName(\"answer1Point\"), \"Label\" )\n    local answer2Point = tolua.cast( no:getChildByName(\"answer2Point\"), \"Label\" )\n    local stake = tolua.cast( content:getChildByName(\"stake\"), \"Label\" )\n    local balance = tolua.cast( content:getChildByName(\"balance\"), \"Label\" )\n    \n    team1Name:setText( TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) ) )\n    team2Name:setText( TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) ) )\n    answer1Point:setText( MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION )..\" points\" )\n    answer2Point:setText( MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION )..\" points\" )\n    stake:setText( string.format( stake:getStringValue(), Constants.STAKE ) )\n    balance:setText( string.format( balance:getStringValue(), Logic:getBalance() - Logic:getUncommitedBalance() ) )\n\n    helperInitQuestion( content )\nend\n\nfunction helperInitQuestion( content )\n    local marketType = MarketsForGameData.getMarketType( mMarketsData )\n    local question = tolua.cast( content:getChildByName(\"question\"), \"Label\" )\n\n    local line = MarketsForGameData.getMarketLine( mMarketsData )\n    if marketType == MarketConfig.MARKET_TYPE_TOTAL_GOAL then\n        question:setText( string.format( question:getStringValue(), math.ceil( line ) ) )\n    elseif marketType == MarketConfig.MARKET_TYPE_ASIAN_HANDICAP then\n        local teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) )\n        if line < 0 then\n            teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) )\n            line = line * ( -1 )\n        end \n        question:setText( string.format( question:getStringValue(), teamName, math.ceil( line ) ) )\n    end\nend\n\nfunction helperGetTheAnswer( answerId )\n    local marketType = MarketsForGameData.getMarketType( mMarketsData )\n\n    local line = MarketsForGameData.getMarketLine( mMarketsData )\n    if marketType == MarketConfig.MARKET_TYPE_TOTAL_GOAL then\n        if answerId then\n            return string.format( \"Total goals will be %d or more.\", math.ceil( line ) )\n        else\n            return string.format( \"Total goals will less than %d.\", math.ceil( line ) )\n        end\n    elseif marketType == MarketConfig.MARKET_TYPE_ASIAN_HANDICAP then\n        local teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) )\n        if line < 0 then\n            teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) )\n            line = line * ( -1 )\n        end \n        \n        if answerId then\n            return string.format( \"%s will win by %d goals or more.\", teamName, math.ceil( line ) )\n        else\n            return string.format( \"%s will not win by %d goals or more.\", teamName, math.ceil( line ) )\n        end\n    end\nend\n\nfunction onFrameTouch( sender, eventType )\n    local yes = tolua.cast( mWidget:getChildByName(\"yes\"), \"ImageView\" )\n    local no = tolua.cast( mWidget:getChildByName(\"no\"), \"ImageView\" )\n    if eventType == TOUCH_EVENT_ENDED then\n        local touchBeginPoint = sender:getTouchStartPos()\n        local touchEndPoint = sender:getTouchEndPos()\n        if touchBeginPoint.x - touchEndPoint.x > MIN_MOVE_DISTANCE then\n            -- Swap to Left\n            selectNo()\n        elseif touchBeginPoint.x - touchEndPoint.x < MIN_MOVE_DISTANCE * (-1) then\n            -- Swap to Right\n            selectYes()\n        else\n            yes:setScale( SCALE_BASE )\n            no:setScale( SCALE_BASE )\n            yes:setOpacity( OPACITY )\n            no:setOpacity( OPACITY )\n        end\n    elseif eventType == TOUCH_EVENT_MOVED then\n        local touchBeginPoint = sender:getTouchStartPos()\n        local touchMovPoint = sender:getTouchMovePos()\n\n        local scalePercentage = math.abs( touchBeginPoint.x - touchMovPoint.x ) / MIN_MOVE_DISTANCE\n        if scalePercentage > 1 then\n            scalePercentage = 1\n        end\n        if touchBeginPoint.x - touchMovPoint.x > 0 then\n            no:setScale( scalePercentage * SCALE_UP_OFFSET_MAX + SCALE_BASE )\n            yes:setScale( scalePercentage * SCALE_DOWN_OFFSET_MAX + SCALE_BASE )\n            no:setOpacity( OPACITY )\n            yes:setOpacity( OPACITY / 3 )\n        else\n            yes:setScale( scalePercentage * SCALE_UP_OFFSET_MAX + SCALE_BASE )\n            no:setScale( scalePercentage * SCALE_DOWN_OFFSET_MAX + SCALE_BASE )\n            yes:setOpacity( OPACITY )\n            no:setOpacity( OPACITY / 3 )\n        end\n    end\nend\n","scripts.views.Navigator":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\n\n\nlocal mWidget\nlocal mLastSelectedId = 0\nlocal NAV_BT_NUM = 4\n\nlocal TAB_EVENT_LIST = {\n\tEvent.Enter_Match_List,\n\tEvent.Enter_Leaderboard,\n\tEvent.Enter_History,\n\tEvent.Enter_Settings,\n}\n\nfunction loadFrame( parent )\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/Navigator.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    parent:addChild( widget )\n\n    for i = 1, NAV_BT_NUM do\n    \tlocal navBt = widget:getChildByName(\"nav\"..i)\n    \tnavBt:addTouchEventListener( navEventHandler )\n    end\n\n    if mLastSelectedId == 0 then\n    \tmLastSelectedId = 1\n    end\n    chooseNav( mLastSelectedId )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction navEventHandler( sender, eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n\t\tlocal navIndex = 1\n\t\tfor i = 1, NAV_BT_NUM do\n\t\t\tif sender == mWidget:getChildByName(\"nav\"..i) then\n\t\t\t\tnavIndex = i\n\t\t\tend\n\t\tend\n\n\t\tchooseNav( navIndex, true )\n\tend\nend\n\nfunction chooseNav( index, postMessage )\n\tmLastSelectedId = index\n\tpostMessage = postMessage or false\n\tfor i = 1, NAV_BT_NUM do\n\t\tlocal navBt = mWidget:getChildByName(\"nav\"..i)\n\t\tif i == index then\n\t\t\tnavBt:setFocused( true )\n\t\telse\n\t\t\tnavBt:setFocused( false )\n\t\tend\n\tend\n\n\tif postMessage then\n\t\tEventManager:postEvent( TAB_EVENT_LIST[index] )\n\tend\nend\n","scripts.data.CouponHistoryData":"module(..., package.seeall)\n\nCouponHistoryData = {}\n\n--[[\n{\n   \"open\":[\n      {\n         \"GameId\":642,\n         \"HomeTeamId\":229,\n         \"AwayTeamId\":244,\n         \"Result\":null,\n         \"ROI\":-1.0,\n         \"Profit\":0.00,\n         \"WinPercentage\":0.0,\n         \"GameCouponsDTOs\":[\n            {\n               \"MarketTypeId\":1,\n               \"CouponId\":992,\n               \"Line\":null,\n               \"OutcomeSide\":1,\n               \"Odd\":2.12,\n               \"Stake\":1000.00,\n               \"Won\":false,\n               \"Profit\":0.00\n            },\n            {\n               \"MarketTypeId\":2,\n               \"CouponId\":993,\n               \"Line\":2.5,\n               \"OutcomeSide\":2,\n               \"Odd\":1.95,\n               \"Stake\":1000.00,\n               \"Won\":false,\n               \"Profit\":0.00\n            },\n            {\n               \"MarketTypeId\":3,\n               \"CouponId\":994,\n               \"Line\":-0.5,\n               \"OutcomeSide\":1,\n               \"Odd\":2.20,\n               \"Stake\":1000.00,\n               \"Won\":false,\n               \"Profit\":0.00\n            }\n         ]\n      }\n   ],\n   \"closed\":[\n\n   ],\n   \"balance\":1000\n}\n--]]\n\nfunction CouponHistoryData:new( rawDataObj )\n\tlocal obj = {\n\t\tOpenCoupon = rawDataObj[\"open\"],\n    ClosedCoupon = rawDataObj[\"closed\"],\n    Balance = rawDataObj[\"balance\"],\n\t}\n\n\tsetmetatable(obj, self)\n    self.__index = self\n    \n    obj.__newindex = function(t, k, v) assert(false, \"CouponHistoryData--\"..k .. \"__newindex not exist\") end\n    \n    return obj \nend\n\nfunction CouponHistoryData:getOpenData()\n  return self.OpenCoupon\nend\n\nfunction CouponHistoryData:getClosedData()\n  return self.ClosedCoupon\nend\n\nfunction CouponHistoryData:getBalance()\n  return self.Balance\nend\n","scripts.Logic":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal FileUtils = require(\"scripts.FileUtils\")\nlocal Coupons = require(\"scripts.data.Coupons\").Coupons\nlocal Constants = require(\"scripts.Constants\")\n\n-- Singleton of logic\nlocal MATCH_PREDICTION = \"matchPrediction\"\nlocal SCORE_PREDICTION = \"scorePrediction\"\nlocal SUB_PREDICTION = \"sub\"\n\nlocal ACCOUNT_INFO_FILE = \"ai.txt\"\nlocal ACCOUNT_INFO_EMAIL = \"email\"\nlocal ACCOUNT_INFO_PASSWORD = \"password\"\n\nlocal instance\n\nfunction getInstance()\n\tif instance == nil then\n\t\tinstance = Logic:new()\n\n\t\tlocal savedAccountInfo = FileUtils.readStringFromFile( ACCOUNT_INFO_FILE )\n\t\tif savedAccountInfo ~= nil and string.len( savedAccountInfo ) > 0 then\n\t\t\tlocal accountInfo = Json.decode( savedAccountInfo )\n\t\t\tprint( savedAccountInfo )\n\t\t\tinstance:setUserInfo( accountInfo[ACCOUNT_INFO_EMAIL], accountInfo[ACCOUNT_INFO_PASSWORD], 0, \"\" )\n\t\tend\n\tend\n\n\treturn instance\nend\n\nLogic = {}\n\nfunction Logic:new()\n\tif instance ~= nil then\n\t\tassert( false )\n\t\treturn instance\n\tend\n\t\n\tlocal obj = {\n\t\tmPoint = 5000,\n\t\tmSelectedMatch = nil,\t--DS: see MatchListData\n\t\tmCurDisplayMarketIndex = 0,\n\t\tmCurMarketInfo = nil,\t-- DS: see MarketsForGameData\n\t\tmCoupons = Coupons:new(),  -- DS: Coupons\n\t\tmPreviousLeagueSelected = 0,\n\t\tmSelectedLeagues = nil,\n\t\tsessionToken = 0,\n\t\temail = \"\",\n\t\tpassword = \"\",\n\t\tuserId = \"\",\n\t\tdisplayName = \"\",\n\t\tpictureUrl = nil,\n\t\tstartLeagueId = 0,\n\t\tbalance = 0,\n\t\tFbId = nil,\n\t}\n    \n    setmetatable(obj, self)\n    self.__index = self\n    \n    obj.__newindex = function(t, k, v) assert(false, \"Logic--\"..k .. \"__newindex not exist\") end\n    \n    instance = obj\n    return obj \nend\n\nfunction Logic:getSelectedMatch()\n\treturn self.mSelectedMatch\nend\n\nfunction Logic:setSelectedMatch( match )\n\tself.mSelectedMatch = match\nend\n\nfunction Logic:getCurDisplayMarketIndex()\n\treturn self.mCurDisplayMarketIndex\nend\n\nfunction Logic:setCurDisplayMarketIndex( index )\n\tself.mCurDisplayMarketIndex = index\nend\n\nfunction Logic:getCurMarketInfo()\n\treturn self.mCurMarketInfo\nend\n\nfunction Logic:setCurMarketInfo( info )\n\tself.mCurMarketInfo = info\n\tself.mCurDisplayMarketIndex = 0\nend\n\n\nfunction Logic:getPoint()\n\treturn self.mPoint\nend\n\nfunction Logic:setPoint( p )\n\tself.mPoint = p\nend\n\nfunction Logic:consumePoint( v )\n\tif self.mPoint > v then\n\t\tself:setPoint( self.mPoint - v )\n\telse\n\t\tself:setPoint( 0 )\n\tend\nend\n\nfunction Logic:getSelectedLeagues()\n\treturn self.mSelectedLeagues\nend\n\nfunction Logic:setSelectedLeagues( selectedLeagues )\n\tself.mSelectedLeagues = selectedLeagues\nend\n\nfunction Logic:setUserInfo( email, password, sessionToken, userId )\n\tself.email = email\n\tself.password = password\n\tself.sessionToken = sessionToken\n\tself.userId = userId\n\n\tlocal accountInfo = {}\n\taccountInfo[ACCOUNT_INFO_EMAIL] = email\n\taccountInfo[ACCOUNT_INFO_PASSWORD] = password\n\tFileUtils.writeStringToFile( ACCOUNT_INFO_FILE, Json.encode( accountInfo ) )\nend\n\nfunction Logic:getEmail()\n\treturn self.email\nend\n\nfunction Logic:getPassword()\n\treturn self.password\nend\n\nfunction Logic:getAuthSessionString()\n\treturn \"Authorization: FH-Token \"..self.sessionToken\nend\n\nfunction Logic:getUserId()\n\treturn self.userId\nend\n\nfunction Logic:addPrediction( prediciton, answer, reward, answerIcon )\n\tprint( string.format( \"Make Prediction: %d with answer[%s], reward[%d] and answerIcon[%s]\", prediciton, answer, reward, answerIcon ) )\n\tself.mCoupons:addCoupon( prediciton, answer, reward, answerIcon )\nend\n\nfunction Logic:setPredictionMetadata( message, shareOnFacebook )\n\tself.mCoupons:setMessage( message )\n\tself.mCoupons:setShareOnFacebook( shareOnFacebook )\nend\n\nfunction Logic:getPredictions()\n\treturn self.mCoupons\nend\n\nfunction Logic:resetPredictions()\n\tself.mCoupons = Coupons:new()\nend\n\nfunction Logic:getPreviousLeagueSelected()\n\treturn self.mPreviousLeagueSelected\nend\n\nfunction Logic:setPreviousLeagueSelected( id )\n\tself.mPreviousLeagueSelected = id\nend\n\nfunction Logic:getDisplayName()\n\treturn self.displayName\nend\n\nfunction Logic:setDisplayName( name )\n\tself.displayName = name\nend\n\nfunction Logic:getPictureUrl()\n\treturn self.pictureUrl\nend\n\nfunction Logic:setPictureUrl( url )\n\tself.pictureUrl = url\nend\n\nfunction Logic:getStartLeagueId()\n\treturn self.startLeagueId\nend\n\nfunction Logic:setStartLeagueId( id )\n\tself.startLeagueId = id\nend\n\nfunction Logic:setBalance( balance )\n\tself.balance = balance\nend\n\nfunction Logic:getBalance()\n\treturn self.balance\nend\n\nfunction Logic:getUncommitedBalance()\n\treturn self.mCoupons:getSize() * Constants.STAKE\nend\n\nfunction Logic:setFbId( id )\n\tself.FbId = id\nend\n\nfunction  Logic:getFbId()\n\treturn self.FbId\nend\n","scripts.actions.EnterPredTotalConfirmAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal PredTotalConfirmScene = require(\"scripts.views.PredTotalConfirmScene\")\n    PredTotalConfirmScene.loadFrame()\nend\n","scripts.views.CompetitionDetailScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal Navigator = require(\"scripts.views.Navigator\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal SMIS = require(\"scripts.SMIS\")\n\n\nlocal mWidget\nlocal mCompetitionId\nlocal mSubType\nlocal mStep\nlocal mCurrentTotalNum\nlocal mCompetitionCodeString\n\n-- DS for competitionDetail see CompetitionDetail\nfunction loadFrame( competitionDetail, subType, competitionId )\n    mCompetitionId = competitionId\n    mSubType = subType\n\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/CompetitionLeaderboard.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget( widget )\n\n    Navigator.loadFrame( widget )\n    local backBt = mWidget:getChildByName(\"back\")\n    backBt:addTouchEventListener( backEventHandler )\n    local shareBt = mWidget:getChildByName(\"share\")\n    shareBt:addTouchEventListener( shareEventHandler )\n\n    -- Init the title\n    local title = tolua.cast( mWidget:getChildByName(\"title\"), \"Label\" )\n    title:setText( competitionDetail:getName() )\n\n    -- Init the content\n    initContent( competitionDetail )\n    mStep = 1\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction backEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        EventManager:popHistory()\n    end\nend\n\nfunction initContent( competitionDetail )\n\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n    contentContainer:removeAllChildrenWithCleanup( true )\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n    local contentHeight = 0\n\n    -- Add the competition detail info\n    local content = GUIReader:shareReader():widgetFromJsonFile(\"scenes/CompetitionLeaderboardInfo.json\")\n    local time = tolua.cast( content:getChildByName(\"time\"), \"Label\" )\n    local description = tolua.cast( content:getChildByName(\"description\"), \"Label\" )\n    local codeText = tolua.cast( content:getChildByName(\"codeText\"), \"Label\" )\n\n    time:setText( string.format( time:getStringValue(), \n                os.date( \"%m/%d/%Y\", competitionDetail:getStartTime() ), \n                os.date( \"%m/%d/%Y\", competitionDetail:getEndTime() ) ) )\n    mCompetitionCodeString = string.format( codeText:getStringValue(), competitionDetail:getJoinToken() )\n    codeText:setText( mCompetitionCodeString )\n    description:setText( competitionDetail:getDescription() )\n\n    content:setLayoutParameter( layoutParameter )\n    contentContainer:addChild( content )\n    contentHeight = contentHeight + content:getSize().height\n\n    local showLeague = content:getChildByName(\"SelectLeague\")\n    showLeague:addTouchEventListener( showLeagueEventHandler )\n    local copyCodeBt = content:getChildByName(\"codeButton\")\n    copyCodeBt:addTouchEventListener( copyCodeEventHandler )\n\n    -- Add the leaderboard info\n    local leaderboardInfo = competitionDetail:getDto()\n    for i = 1, table.getn( leaderboardInfo ) do\n    \tlocal eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                contentClick( leaderboardInfo[i] )\n            end\n        end\n\n        local content = SceneManager.widgetFromJsonFile(\"scenes/LeaderboardListContent.json\")\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n        initLeaderboardContent( i, content, leaderboardInfo[i] )\n        content:addTouchEventListener( eventHandler )\n    end\n    mCurrentTotalNum = table.getn( leaderboardInfo )\n\n    -- Add the \"More\" button\n    contentHeight = contentHeight + addMoreButton( contentContainer, layoutParameter ):getSize().height\n\n    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n    local layout = tolua.cast( contentContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n\nfunction showLeagueEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        EventManager:postEvent( Event.Enter_Competition_Leagues, { mCompetitionId } )\n    end\nend\n\nfunction copyCodeEventHandler( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        Analytics:sharedDelegate():copyToPasteboard( mCompetitionCodeString )\n        EventManager:postEvent( Event.Show_Info, { \"Join code is copied.\" } )\n    end\nend\n\nfunction shareEventHandler( sender, eventTYpe )\n    if eventType == TOUCH_EVENT_ENDED then\n        \n    end\nend\n\nfunction addMoreButton( contentContainer, layoutParameter )\n    local content = SceneManager.widgetFromJsonFile(\"scenes/MoreContent.json\")\n    content:setLayoutParameter( layoutParameter )\n    contentContainer:addChild( content )\n    content:addTouchEventListener( loadMore )\n    content:setName(\"More\")\n\n    return content\nend\n\nfunction initLeaderboardContent( i, content, info )\n    local name = tolua.cast( content:getChildByName(\"name\"), \"Label\" )\n    local score = tolua.cast( content:getChildByName(\"score\"), \"Label\" )\n    local index = tolua.cast( content:getChildByName(\"index\"), \"Label\" )\n    local logo = tolua.cast( content:getChildByName(\"logo\"), \"ImageView\" )\n\n    if info[\"DisplayName\"] == nil then\n        name:setText( \"Unknow name\" )\n    else\n        name:setText( info[\"DisplayName\"] )\n    end\n    score:setText( string.format( mSubType[\"description\"], info[mSubType[\"dataColumnId\"]] ) )\n    index:setText( i )\n\n\n    local seqArray = CCArray:create()\n    seqArray:addObject( CCDelayTime:create( i * 0.2 ) )\n    seqArray:addObject( CCCallFuncN:create( function()\n        if info[\"PictureUrl\"] ~= nil then\n            local handler = function( filePath )\n                if filePath ~= nil and mWidget ~= nil then\n                    logo:loadTexture( filePath )\n                    logo:setScale( 1 )\n                end\n            end\n            SMIS.getSMImagePath( info[\"PictureUrl\"], handler )\n        end\n    end ) )\n\n    mWidget:runAction( CCSequence:create( seqArray ) )\nend\n\nfunction loadMore( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        mStep = mStep + 1\n        EventManager:postEvent( Event.Load_More_In_Competition_Detail, { mCompetitionId, mStep } )\n    end\nend\n\nfunction loadMoreContent( leaderboardInfo )\n    local contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n\n    -- Remove the \"More\" button\n    local moreButton = contentContainer:getChildByName(\"More\")\n    moreButton:removeFromParent()\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n    local contentHeight = contentContainer:getInnerContainerSize().height\n\n    for i = 1, table.getn( leaderboardInfo ) do\n        local eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                contentClick( leaderboardInfo[i] )\n            end\n        end\n\n        local content = SceneManager.widgetFromJsonFile(\"scenes/LeaderboardListContent.json\")\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n        initLeaderboardContent( mCurrentTotalNum + i, content, leaderboardInfo[i] )\n        content:addTouchEventListener( eventHandler )\n    end\n    mCurrentTotalNum = mCurrentTotalNum + table.getn( leaderboardInfo )\n\n    if table.getn( leaderboardInfo ) > 0 then\n        -- Add back the \"More\" button\n        addMoreButton( contentContainer, layoutParameter )\n    end\n\n    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n    local layout = tolua.cast( contentContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n\nfunction contentClick( info )\n    local id = info[\"Id\"]\n    local name = \"Unknow name\"\n    if info[\"DisplayName\"] ~= nil then\n        name = info[\"DisplayName\"]\n    end\n    EventManager:postEvent( Event.Enter_History, { id, name } )\nend\n","scripts.views.LeaderboardListScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal Navigator = require(\"scripts.views.Navigator\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal TeamConfig = require(\"scripts.config.Team\")\nlocal LeaderboardConfig = require(\"scripts.config.Leaderboard\")\nlocal SMIS = require(\"scripts.SMIS\")\n\n\nlocal mWidget\nlocal mLeaderboardId\nlocal mSubType\nlocal mStep\nlocal mCurrentTotalNum\n\n-- DS for subType see LeaderboardConfig\nfunction loadFrame( leaderboardInfo, leaderboardId, subType )\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/LeaderboardList.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget( widget )\n\n    Navigator.loadFrame( widget )\n    local backBt = mWidget:getChildByName(\"back\")\n    backBt:addTouchEventListener( backEventHandler )\n\n    mLeaderboardId = leaderboardId\n    mSubType = subType\n\n    initTitles()\n    initContent( leaderboardInfo )\n    mStep = 1\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction backEventHandler( sender,eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        --EventManager:postEvent( Event.Enter_Leaderboard )\n        EventManager:popHistory()\n    end\nend\n\nfunction initTitles()\n    local title = tolua.cast( mWidget:getChildByName(\"title\"), \"Label\" )\n    local subTitle = tolua.cast( mWidget:getChildByName(\"subTitle\"), \"Label\" )\n\n    title:setText( LeaderboardConfig.LeaderboardType[mLeaderboardId][\"displayName\"] )\n    subTitle:setText( string.format( subTitle:getStringValue(), mSubType[\"title\"] ) )\nend\n\nfunction initContent( leaderboardInfo )\n\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n    contentContainer:removeAllChildrenWithCleanup( true )\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n    local contentHeight = 0\n\n    for i = 1, table.getn( leaderboardInfo ) do\n    \tlocal eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                contentClick( leaderboardInfo[i] )\n            end\n        end\n\n        local content = SceneManager.widgetFromJsonFile(\"scenes/LeaderboardListContent.json\")\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n        initLeaderboardContent( i, content, leaderboardInfo[i] )\n        content:addTouchEventListener( eventHandler )\n    end\n    mCurrentTotalNum = table.getn( leaderboardInfo )\n\n    -- Add the \"More\" button\n    contentHeight = contentHeight + addMoreButton( contentContainer, layoutParameter ):getSize().height\n\n    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n    local layout = tolua.cast( contentContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n\nfunction addMoreButton( contentContainer, layoutParameter )\n    local content = SceneManager.widgetFromJsonFile(\"scenes/MoreContent.json\")\n    content:setLayoutParameter( layoutParameter )\n    contentContainer:addChild( content )\n    content:addTouchEventListener( loadMore )\n    content:setName(\"More\")\n\n    return content\nend\n\nfunction initLeaderboardContent( i, content, info )\n    local name = tolua.cast( content:getChildByName(\"name\"), \"Label\" )\n    local score = tolua.cast( content:getChildByName(\"score\"), \"Label\" )\n    local index = tolua.cast( content:getChildByName(\"index\"), \"Label\" )\n    local logo = tolua.cast( content:getChildByName(\"logo\"), \"ImageView\" )\n\n    if info[\"DisplayName\"] == nil then\n        name:setText( \"Unknow name\" )\n    else\n        name:setText( info[\"DisplayName\"] )\n    end\n    score:setText( string.format( mSubType[\"description\"], info[mSubType[\"dataColumnId\"]] ) )\n    index:setText( i )\n\n\n    local seqArray = CCArray:create()\n    seqArray:addObject( CCDelayTime:create( i * 0.2 ) )\n    seqArray:addObject( CCCallFuncN:create( function()\n        if info[\"PictureUrl\"] ~= nil then\n            local handler = function( filePath )\n                if filePath ~= nil and mWidget ~= nil then\n                    logo:loadTexture( filePath )\n                    logo:setScale( 1 )\n                end\n            end\n            SMIS.getSMImagePath( info[\"PictureUrl\"], handler )\n        end\n    end ) )\n\n    mWidget:runAction( CCSequence:create( seqArray ) )\nend\n\nfunction loadMore( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        mStep = mStep + 1\n        EventManager:postEvent( Event.Load_More_In_Leaderboard, { leaderboardId, mSubType, mStep } )\n    end\nend\n\nfunction loadMoreContent( leaderboardInfo )\n    local contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n\n    -- Remove the \"More\" button\n    local moreButton = contentContainer:getChildByName(\"More\")\n    moreButton:removeFromParent()\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n    local contentHeight = contentContainer:getInnerContainerSize().height\n\n    for i = 1, table.getn( leaderboardInfo ) do\n        local eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                contentClick( leaderboardInfo[i] )\n            end\n        end\n\n        local content = SceneManager.widgetFromJsonFile(\"scenes/LeaderboardListContent.json\")\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n        initLeaderboardContent( mCurrentTotalNum + i, content, leaderboardInfo[i] )\n        content:addTouchEventListener( eventHandler )\n    end\n    mCurrentTotalNum = mCurrentTotalNum + table.getn( leaderboardInfo )\n\n    if table.getn( leaderboardInfo ) > 0 then\n        -- Add back the \"More\" button\n        addMoreButton( contentContainer, layoutParameter )\n    end\n\n    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n    local layout = tolua.cast( contentContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n\nfunction contentClick( info )\n    local id = info[\"Id\"]\n    local name = \"Unknow name\"\n    if info[\"DisplayName\"] ~= nil then\n        name = info[\"DisplayName\"]\n    end\n    EventManager:postEvent( Event.Enter_History, { id, name } )\nend\n","scripts.actions.EnterRegisterNameAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal registerNameScene = require(\"scripts.views.RegisterNameScene\")\n    registerNameScene.loadFrame()\n\n    if param ~= nil then\n    \tlocal userName = param[1]\n\t    if userName ~= nil then\n\t    \tprint(\"Add user name:\"..userName)\n\t    \tregisterNameScene.setUserName( userName )\n\t    end\n    end\nend\n","scripts.actions.CheckFilesVersionAction":"module(..., package.seeall)\n\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal FileUtils = require(\"scripts.FileUtils\")\nlocal MD5 = require(\"MD5\")\n\nlocal fileList = {\n\t\"config/countries.txt\",\n\t\"config/leagues.txt\",\n\t\"config/teams.txt\",\n\t\"config/leagueteams.txt\",\n}\n\nlocal MD5ConfigIDList = {\n\t\"CountryConfigMd5\",\n\t\"LeagueConfigMd5\",\n\t\"TeamConfigMd5\",\n\t\"LeagueTeamConfigMd5\",\n}\n\nlocal CDNFileNameList = {\n\t\"countries.txt\",\n\t\"leagues.txt\",\n\t\"teams.txt\",\n\t\"leagueteams.txt\",\n}\n\nlocal mConfigMd5Info\nlocal mFinishEvent\nlocal mCurrentFileIndex\n\nfunction action( param )\n\tmConfigMd5Info = param[1]\n\tmFinishEvent = param[2]\n\n\tmCurrentFileIndex = 0\n\tcheckNext()\nend\n\nfunction checkNext()\n\tmCurrentFileIndex = mCurrentFileIndex + 1\n\tif mCurrentFileIndex <= table.getn( fileList ) then\n\t\tcheckFile( mCurrentFileIndex )\t\n\telse\n\t\t-- Init the configure files.\n\t\tConnectingMessage.loadFrame( \"Login success.\\nLoading data, please wait...\" )\n\n\t\tlocal loadDataTaskSeqArray = CCArray:create()\n\t\tloadDataTaskSeqArray:addObject( CCDelayTime:create( 1 ) )\n\t\tloadDataTaskSeqArray:addObject( CCCallFuncN:create( function()\n\t\t\tlocal LeagueTeamConfig = require(\"scripts.config.LeagueTeams\")\n\t        local CountryConfig = require(\"scripts.config.Country\")\n\t        local LeagueConfig = require(\"scripts.config.League\")\n\t        local TeamConfig = require(\"scripts.config.Team\")\n\n\t        EventManager:postEvent( mFinishEvent )\n\t\tend ) )\n\n\t\tCCDirector:sharedDirector():getRunningScene():runAction( CCSequence:create( loadDataTaskSeqArray ) )\n\tend\nend\n\nfunction checkFile( fileIndex )\n\tlocal file = fileList[fileIndex]\n\tlocal MD5ConfigId = MD5ConfigIDList[fileIndex]\n\tlocal serverMD5 = mConfigMd5Info[MD5ConfigId]\n\tif serverMD5 == nil then\n\t\tprint( \"Checking \"..file..\", but server MD5 is nil.\" )\n\t\tcheckNext()\n\t\treturn\n\tend\n\n\t-- Compare the md5 value\n\t-- Re-download the file if not match\n\tlocal fileContent = FileUtils.readStringFromFile( file )\n\tlocal localMD5 = MD5.sumhexa( fileContent )\n\tprint( \"Checking \"..file..\": \"..serverMD5..\" | \"..localMD5 )\n\tif serverMD5 ~= localMD5 then\n\t\tlocal handler = function( isSucceed, body, header, status, errorBuffer )\n\t        print( \"Http reponse: \"..status..\" and errorBuffer: \"..errorBuffer )\n\t        ConnectingMessage.selfRemove()\n\t        if status == RequestUtils.HTTP_200 then\n\t            onRequestSuccess( file, body )\n\t        else\n\t            onRequestFailed( errorBuffer )\n\t        end\n\t    end\n\n\t    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n\t    print(\"Downloading from: \"..RequestUtils.CDN_SERVER_IP..CDNFileNameList[fileIndex])\n\t    httpRequest:sendHttpRequest( RequestUtils.CDN_SERVER_IP..CDNFileNameList[fileIndex], handler )\n\n\t    ConnectingMessage.loadFrame( \"Updating \"..file..\"...\" )\n\telse\n\t\tcheckNext()\n\tend\nend\n\nfunction onRequestSuccess( fileName, fileContent )\n\tprint(\"Update complete for file: \"..fileName)\n    FileUtils.writeStringToFile( fileName, fileContent )\n\n    checkNext()\nend\n\nfunction onRequestFailed( errorBuffer )\n\tif errorBuffer == \"\" then\n\t\terrorBuffer = \"Update file failed.\"\n\tend\n    EventManager:postEvent( Event.Show_Error_Message, { errorBuffer, checkNext } )\nend\n","scripts.actions.DoLoginAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal Constants = require(\"scripts.Constants\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\n\nlocal mEmail = \"test126@abc.com\"\nlocal mPassword = \"test126\"\n\n\nfunction action( param )\n\n    mEmail, mPassword = param[1], param[2]\n\n    if string.len( mEmail ) == 0 then\n        RequestUtils.onRequestFailed( \"Email is blank.\" )\n        return\n    end\n    if string.len( mPassword ) == 0 then\n        RequestUtils.onRequestFailed( \"Password is blank.\" )\n        return\n    end\n\n    local requestContent = { Email = mEmail, Password = mPassword, useDev = RequestUtils.USE_DEV }\n    local requestContentText = Json.encode( requestContent )\n    \n    local url = RequestUtils.EMAIL_LOGIN_REST_CALL\n\n    local requestInfo = {}\n    requestInfo.requestData = requestContentText\n    requestInfo.url = url\n\n     local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )\n    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )\n    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    local sessionToken = jsonResponse[\"ProfileDto\"][\"SessionToken\"]\n    local userId = jsonResponse[\"ProfileDto\"][\"Id\"]\n    local configMd5Info = jsonResponse[\"ProfileDto\"][\"ConfigMd5Info\"]\n    local displayName = jsonResponse[\"ProfileDto\"][\"DisplayName\"]\n    local pictureUrl = jsonResponse[\"ProfileDto\"][\"PictureUrl\"]\n    local startLeagueId = jsonResponse[\"ProfileDto\"][\"StartLeagueId\"]\n    local balance = jsonResponse[\"ProfileDto\"][\"Balance\"]\n    local FbId = jsonResponse[\"ProfileDto\"][\"FbId\"]\n\n    local Logic = require(\"scripts.Logic\").getInstance()\n    Logic:setUserInfo( mEmail, mPassword, sessionToken, userId )\n    Logic:setDisplayName( displayName )\n    Logic:setPictureUrl( pictureUrl )\n    Logic:setStartLeagueId( startLeagueId )\n    Logic:setBalance( balance )\n    Logic:setFbId( FbId )\n\n    local finishEvent = Event.Enter_Sel_Fav_Team\n    if displayName == nil then\n        finishEvent = Event.Enter_Register_Name\n    end\n    EventManager:postEvent( Event.Check_File_Version, { configMd5Info, finishEvent } )\nend\n","scripts.actions.ShowErrorMessageAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal errorMessage = require(\"scripts.views.ErrorMessage\")\n    errorMessage.loadFrame()\n    errorMessage.setErrorMessage( param[1], param[2] )\nend\n","scripts.config.Leaderboard":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\n\nLeaderboardType = {\n\t{ [\"displayName\"] = \"Top Performers\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"top-performers.png\", [\"request\"] = RequestUtils.GET_MAIN_LEADERBOARD_REST_CALL },\n\t\n\t{ [\"displayName\"] = \"Friends\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"friends.png\", [\"request\"] = RequestUtils.GET_FRIENDS_LEADERBOARD_REST_CALL },\n\t\n--[[\n\t{ [\"displayName\"] = \"Followers\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"followers.png\" },\n\n\t{ [\"displayName\"] = \"Monthly\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"monthly.png\" },\n\t\n\t{ [\"displayName\"] = \"Competitions\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"competition.png\" },\n\t\n\t{ [\"displayName\"] = \"Prediction Types\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"prediction-types.png\" },\n--]]\n}\n\nLeaderboardSubType = {\n\t{ [\"sortType\"] = 1, [\"dataColumnId\"] = \"Roi\", [\"title\"] = \"Roi\", [\"description\"] = \"%d%% won\", },\n\t{ [\"sortType\"] = 2, [\"dataColumnId\"] = \"WinPercentage\", [\"title\"] = \"Win %\", [\"description\"] = \"%d%% won\", },\n\t{ [\"sortType\"] = 3, [\"dataColumnId\"] = \"Profit\", [\"title\"] = \"Profit\", [\"description\"] = \"%d won\", },\n}\n","scripts.data.MatchListData":"module(..., package.seeall)\n\nMatchListData = {}\n\n--[[\n\n[\n    {\n        \"date\": \"2014/4/25\",\n        \"dateDisplay\": \"April 25, Thursday\",\n        \"matches\": [\n            {\n                \"Id\": 4077,\n                \"HomeTeamId\": 2744,\n                \"AwayTeamId\": 2942,\n                \"StartTime\": 1398311338\n                \"HomeGoals\": 2,\n                \"AwayGoals\": 3,\n                \"PredictionsPlayed\": 0,\n                \"PredictionsAvailable\": 0\n            },\n            {\n                \"Id\": 4555,\n                \"HomeTeamId\": 1573,\n                \"AwayTeamId\": 6914,\n                \"StartTime\": 1398311338\n                \"HomeGoals\": 2,\n                \"AwayGoals\": 3,\n                \"PredictionsPlayed\": 0,\n                \"PredictionsAvailable\": 0\n            },\n            {\n                \"Id\": 4083,\n                \"HomeTeamId\": 10310,\n                \"AwayTeamId\": 58760,\n                \"StartTime\": 1398311338\n                \"HomeGoals\": 2,\n                \"AwayGoals\": 3,\n                \"PredictionsPlayed\": 0,\n                \"PredictionsAvailable\": 0\n            }\n        ]\n    },\n\n    {\n        \"date\": \"2014/4/27\",\n        \"dateDisplay\": \"April 27, Saturday\",\n        \"matches\": [\n            {\n                \"Id\": 4077,\n                \"HomeTeamId\": 2744,\n                \"AwayTeamId\": 2942,\n                \"StartTime\": 1398311338\n                \"HomeGoals\": 2,\n                \"AwayGoals\": 3,\n                \"PredictionsPlayed\": 0,\n                \"PredictionsAvailable\": 0\n            },\n            {\n                \"Id\": 4555,\n                \"HomeTeamId\": 1573,\n                \"AwayTeamId\": 6914,\n                \"StartTime\": 1398311338\n                \"HomeGoals\": 2,\n                \"AwayGoals\": 3,\n                \"PredictionsPlayed\": 0,\n                \"PredictionsAvailable\": 0\n            },\n            {\n                \"Id\": 4083,\n                \"HomeTeamId\": 10310,\n                \"AwayTeamId\": 58760,\n                \"StartTime\": 1398311338\n                \"HomeGoals\": 2,\n                \"AwayGoals\": 3,\n                \"PredictionsPlayed\": 0,\n                \"PredictionsAvailable\": 0\n            }\n        ]\n    }\n]\n\n--]]\n\nfunction MatchListData:new()\n\tlocal obj = {\n\t\tmatchDateList = {}\n\t}\n\n\tsetmetatable(obj, self)\n    self.__index = self\n    \n    obj.__newindex = function(t, k, v) assert(false, \"MatchListData--\"..k .. \"__newindex not exist\") end\n    \n    return obj \nend\n\nfunction MatchListData:getOrCreateMatchListOnDate( date, dateDisplay )\n\tfor k,v in pairs( self.matchDateList ) do\n\t\tif v[\"date\"] == date then\n\t\t\treturn v\n\t\tend\n\tend\n\n\tlocal matchDate = {}\n\tmatchDate[\"date\"] = date\n\tmatchDate[\"dateDisplay\"] = dateDisplay\n\tmatchDate[\"matches\"] = {}\n\ttable.insert( self.matchDateList, matchDate )\n\treturn matchDate\nend\n\nfunction MatchListData:addMatch( match )\n\tlocal startTimeNum = match[\"StartTime\"]\n    local startTimeDate = os.date(\"%y\", startTimeNum) * 10000 + os.date(\"%m\", startTimeNum) * 100 + os.date(\"%d\", startTimeNum)\n    local startTimeDisplay = os.date( \"%B %d, %A\", startTimeNum )\n\n    local matchDate = self:getOrCreateMatchListOnDate( startTimeDate, startTimeDisplay )\n    table.insert( matchDate[\"matches\"], match )\nend\n\nfunction MatchListData:getMatchDateList()\n\treturn self.matchDateList\nend\n","scripts.actions.LoadMoreInCompetitionDetailAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal CompetitionDetail = require(\"scripts.data.CompetitionDetail\").CompetitionDetail\n\nfunction action( param )\n    local url = RequestUtils.GET_COMPETITION_DETAIL_REST_CALL\n\n    local competitionId = param[1]\n    local step = param[2]\n    local sortType = 1\n    \n\n    url = url..\"?competitionId=\"..competitionId..\"&sortType=\"..sortType..\"&step=\"..step\n\n    local requestInfo = {}\n    requestInfo.requestData = \"\"\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    local competitionDetail = CompetitionDetail:new( jsonResponse )\n\n    local CompetitionDetailScene = require(\"scripts.views.CompetitionDetailScene\")\n    CompetitionDetailScene.loadMoreContent( competitionDetail:getDto() )\nend\n","scripts.actions.EnterLoginAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal loginScene = require(\"scripts.views.LoginScene\")\n    loginScene.loadFrame()\nend\n","scripts.actions.EnterLeaderboardListAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal LeaderboardConfig = require(\"scripts.config.Leaderboard\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\nlocal mLeaderboardId\nlocal mSubType = LeaderboardConfig.LeaderboardSubType[1]\n\nfunction action( param )\n\tmLeaderboardId = param[1]\n\tlocal leaderboardType = param[2]\n\tlocal step = 1\n\n\tlocal url = LeaderboardConfig.LeaderboardType[mLeaderboardId][\"request\"]\n\t-- Todo change the url for friends leaderboard when that is done.\n\tif leaderboardType == 1 then\n\t\tmSubType = LeaderboardConfig.LeaderboardSubType[1]\n\telseif leaderboardType == 2 then\n\t\t-- Todo change to played type\n\telseif leaderboardType == 3 then\n\t\tmSubType = LeaderboardConfig.LeaderboardSubType[3]\n\telseif leaderboardType == 4 then\n\t\tmSubType = LeaderboardConfig.LeaderboardSubType[2]\n\tend\n\n\turl = url..\"?sortType=\"..mSubType[\"sortType\"]..\"&step=\"..step\n\n    local requestInfo = {}\n    requestInfo.requestData = \"\"\n    requestInfo.url = url\n\n\tlocal handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( response )\n    local leaderboardListScene = require(\"scripts.views.LeaderboardListScene\")\n    leaderboardListScene.loadFrame( response, mLeaderboardId, mSubType )\nend\n","scripts.views.SettingsScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal Navigator = require(\"scripts.views.Navigator\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal SettingsConfig = require(\"scripts.config.Settings\")\n\nlocal mWidget\n\n\nfunction loadFrame()\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/SettingsHome.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget( widget )\n\n    Navigator.loadFrame( widget )\n\n    initContent()\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction isFrameShown()\n    return mWidget ~= nil\nend\n\nfunction initContent()\n\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n    contentContainer:removeAllChildrenWithCleanup( true )\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n    local contentHeight = 0\n\n    for i = 1, table.getn( SettingsConfig.SettingsItem ) do\n    \tlocal eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                EventManager:postEvent( SettingsConfig.SettingsItem[i][\"event\"] )\n            end\n        end\n\n        local content = SceneManager.widgetFromJsonFile(\"scenes/SettingsHomeContent.json\")\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n        content:addTouchEventListener( eventHandler )\n        initSettingsItemContent( content, SettingsConfig.SettingsItem[i] )\n    end\n\n    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n    local layout = tolua.cast( contentContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n\nfunction initSettingsItemContent( content, info )\n    local name = tolua.cast( content:getChildByName(\"name\"), \"Label\" )\n\n    name:setText( info[\"itemName\"] )\nend\n","scripts.actions.EnterRegisterAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal registerScene = require(\"scripts.views.RegisterScene\")\n    registerScene.loadFrame()\nend\n","scripts.views.RegisterScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ViewUtils = require(\"scripts.views.ViewUtils\")\n\nlocal EMAIL_CONTAINER_NAME = \"emailContainer\"\nlocal PASSWORD_CONTAINER_NAME = \"passwordContainer1\"\nlocal PASSWORD_CONF_CONTAINER_NAME = \"passwordContainer2\"\n\nlocal mWidget\nlocal inputWidth = 400\nlocal inputHeight = 50\n\nfunction loadFrame()\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/Register.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget(widget)\n\n    local backBt = widget:getChildByName(\"back\")\n    local registerBt = widget:getChildByName(\"register\")\n\n    backBt:addTouchEventListener( backEventHandler )\n    registerBt:addTouchEventListener( registerEventHandler )\n\n    local emailInput = ViewUtils.createTextInput( mWidget:getChildByName( EMAIL_CONTAINER_NAME ), \"E-mail address\" )\n    local passwordInput = ViewUtils.createTextInput( mWidget:getChildByName( PASSWORD_CONTAINER_NAME ), \"Password\" )\n    local passwordConfInput = ViewUtils.createTextInput( mWidget:getChildByName( PASSWORD_CONF_CONTAINER_NAME ), \"Confirm Password\" )\n\n    passwordInput:setInputFlag( kEditBoxInputFlagPassword )\n    passwordConfInput:setInputFlag( kEditBoxInputFlagPassword )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction backEventHandler( sender,eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n        --EventManager:postEvent( Event.Enter_Login_N_Reg )\n        EventManager:popHistory()\n    end\nend\n\nfunction registerEventHandler( sender,eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n        local email = mWidget:getChildByName( EMAIL_CONTAINER_NAME ):getNodeByTag( 1 ):getText()\n        local pass = mWidget:getChildByName( PASSWORD_CONTAINER_NAME ):getNodeByTag( 1 ):getText()\n        local passConf = mWidget:getChildByName( PASSWORD_CONF_CONTAINER_NAME ):getNodeByTag( 1 ):getText()\n\n        EventManager:postEvent( Event.Do_Register, { email, pass, passConf } )\n    end\nend\n","scripts.actions.EnterFAQAction":"module(..., package.seeall)\n\nfunction action( param )\n\tlocal FAQScene = require(\"scripts.views.FAQScene\")\n\tif FAQScene.isFrameShown() then\n\t\treturn\n\tend\n    FAQScene.loadFrame()\nend\n","scripts.actions.EnterMatchListAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\nfunction action( param )\n    local leagueId = Logic:getStartLeagueId()\n    if Logic:getPreviousLeagueSelected() > 0 then\n        leagueId = Logic:getPreviousLeagueSelected()\n    end\n\n    if param ~= nil and param[1] ~= nil then\n        leagueId = param[1]\n    end\n\n    Logic:setPreviousLeagueSelected( leagueId )\n\n    local url = RequestUtils.GET_UPCOMING_GAMES_BY_LEAGUE_REST_CALL..\"?leagueId=\"..leagueId\n\n    local requestInfo = {}\n    requestInfo.requestData = \"\"\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess, onRequestFailed )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\n\n--[[\n    local JsonConfigReader = require(\"scripts.config.JsonConfigReader\")\n    local config = JsonConfigReader.read( \"config/matchList.json\" )\n    onRequestSuccess( config )\n--]]\nend\n\nfunction onRequestSuccess( matchList )\n    local MatchListData = require(\"scripts.data.MatchListData\").MatchListData\n\n    -- Sort the match according to its start time.\n    local currentTime = os.time()\n    local currentDate = os.time{year=os.date(\"%Y\", currentTime), month=os.date(\"%m\", currentTime), day=os.date(\"%d\", currentTime), hour=0}\n    table.sort( matchList, function ( n1, n2 )\n        if n1[\"StartTime\"] < n2[\"StartTime\"] then\n            if n2[\"StartTime\"] < currentDate then\n                return false\n            elseif n1[\"StartTime\"] < currentDate then\n                return false\n            else\n                return true\n            end\n        elseif  n1[\"StartTime\"] > n2[\"StartTime\"] then\n            if n1[\"StartTime\"] < currentDate then\n                return true\n            elseif n2[\"StartTime\"] < currentDate then\n                return true\n            else\n                return false\n            end\n        else\n            return false\n        end\n    end )\n\n    -- Group and sort.\n    local sortedMatchList = MatchListData:new()\n    for k,v in pairs( matchList ) do\n        sortedMatchList:addMatch( v )\n    end\n\n\tlocal matchListScene = require(\"scripts.views.MatchListScene\")\n    if matchListScene.isShown() then\n        matchListScene.initMatchList( sortedMatchList )\n    else\n        matchListScene.loadFrame( sortedMatchList )\n    end\n    \nend\n\nfunction onRequestFailed( jsonResponse )\n    local errorBuffer = jsonResponse[\"Message\"]\n    local MatchListData = require(\"scripts.data.MatchListData\").MatchListData\n    local matchList = MatchListData:new()\n    local matchListScene = require(\"scripts.views.MatchListScene\")\n    if matchListScene.isShown() then\n        matchListScene.initMatchList( matchList )\n    else\n        matchListScene.loadFrame( matchList )\n    end\n    \n    EventManager:postEvent( Event.Show_Error_Message, { errorBuffer } )\nend\n","scripts.views.HistoryDetailScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal Navigator = require(\"scripts.views.Navigator\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal MarketConfig = require(\"scripts.config.Market\")\nlocal TeamConfig = require(\"scripts.config.Team\")\nlocal Constants = require(\"scripts.Constants\")\n\nlocal CONTENT_FADEIN_TIME = 1\n\nlocal mWidget\nlocal mIsOpen\nlocal mGameCouponsDTOs\n\nlocal mHomeTeamId\nlocal mAwayTeamId\n\n-- DS for matchInof, see CouponHistoryData\nfunction loadFrame( isOpen, matchInfo )\n\tmIsOpen = isOpen\n    mGameCouponsDTOs = matchInfo[\"GameCouponsDTOs\"]\n\n    local widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/HistoryDetail.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget( widget )\n\n    Navigator.loadFrame( widget )\n\n    local backBt = mWidget:getChildByName(\"back\")\n    backBt:addTouchEventListener( backEventHandler )\n\n    helperInitMatchInfo( mWidget, matchInfo )\n    initContent()\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction backEventHandler( sender,eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        --EventManager:postEvent( Event.Enter_History )\n        EventManager:popHistory()\n    end\nend\n\nfunction initContent()\n    local contentWidgetFile = \"scenes/HistoryDetailClosedContent.json\"\n    if mIsOpen then\n        contentWidgetFile = \"scenes/HistoryDetailOpenContent.json\"\n    end\n\n\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n    contentContainer:removeAllChildrenWithCleanup( true )\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n    local contentHeight = 0\n\n    local seqArray = CCArray:create()\n\n    for i = 1, table.getn( mGameCouponsDTOs ) do\n        seqArray:addObject( CCCallFuncN:create( function()\n            local content = GUIReader:shareReader():widgetFromJsonFile( contentWidgetFile )\n            content:setLayoutParameter( layoutParameter )\n            contentContainer:addChild( content )\n            contentHeight = contentHeight + content:getSize().height\n            --content:addTouchEventListener( eventHandler )\n            initCouponInfo( content, mGameCouponsDTOs[i] )\n\n\n            content:setOpacity( 0 )\n            content:setCascadeOpacityEnabled( true )\n            mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )\n        end ) )\n        seqArray:addObject( CCDelayTime:create( 0.2 ) )\n    end\n\n    seqArray:addObject( CCCallFuncN:create( function()\n        contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n        local layout = tolua.cast( contentContainer, \"Layout\" )\n        layout:requestDoLayout()\n    end ) )\n\n    mWidget:runAction( CCSequence:create( seqArray ) )\nend\n\nfunction helperInitMatchInfo( content, matchInfo )\n    mHomeTeamId = TeamConfig.getConfigIdByKey( matchInfo[\"HomeTeamId\"] )\n    mAwayTeamId = TeamConfig.getConfigIdByKey( matchInfo[\"AwayTeamId\"] )\n\n    local team1Name = tolua.cast( content:getChildByName(\"team1Name\"), \"Label\" )\n    local team2Name = tolua.cast( content:getChildByName(\"team2Name\"), \"Label\" )\n\n    team1Name:setText( TeamConfig.getTeamName( mHomeTeamId ) )\n    team2Name:setText( TeamConfig.getTeamName( mAwayTeamId ) )\n    team1Name:setFontName(\"fonts/Newgtbxc.ttf\")\n    team2Name:setFontName(\"fonts/Newgtbxc.ttf\")\nend\n\nfunction initCouponInfo( content, info )\n    local answer = tolua.cast( content:getChildByName(\"answer\"), \"Label\" )\n    local winLoseLabel = tolua.cast( content:getChildByName(\"winLoseLabel\"), \"Label\" )\n    local points = tolua.cast( content:getChildByName(\"points\"), \"Label\" )\n    local stake = tolua.cast( content:getChildByName(\"stake\"), \"Label\" )\n    local choice = tolua.cast( content:getChildByName(\"choice\"), \"ImageView\" )\n    local statusBar = tolua.cast( content:getChildByName(\"statusBar\"), \"Button\" )\n\n    -- Init the answer string.\n    local marketType = info[\"MarketTypeId\"]\n    local line = info[\"Line\"]\n    local answerId = ( info[\"OutcomeSide\"] == 1 )\n\n    local answerString\n    local choiceImage\n    if marketType == MarketConfig.MARKET_TYPE_MATCH then\n        if answerId then\n            answerString = TeamConfig.getTeamName( mHomeTeamId )..\" to win.\"\n            choiceImage = TeamConfig.getLogo( mHomeTeamId )\n        else\n            answerString = TeamConfig.getTeamName( mAwayTeamId )..\" to win.\"\n            choiceImage = TeamConfig.getLogo( mAwayTeamId )\n        end\n    elseif marketType == MarketConfig.MARKET_TYPE_TOTAL_GOAL then\n        if answerId then\n            answerString = string.format( \"Total goals will be %d or more.\", math.ceil( line ) )\n            choiceImage = Constants.PREDICTION_CHOICE_IMAGE_PATH..\"Will-total-goals-be-more-than-xx-yes.png\"\n        else\n            answerString = string.format( \"Total goals will less than %d.\", math.ceil( line ) )\n            choiceImage = Constants.PREDICTION_CHOICE_IMAGE_PATH..\"Will-total-goals-be-more-than-xx-no.png\"\n        end\n    elseif marketType == MarketConfig.MARKET_TYPE_ASIAN_HANDICAP then\n        local teamName = TeamConfig.getTeamName( mAwayTeamId )\n        if line < 0 then\n            teamName = TeamConfig.getTeamName( mHomeTeamId )\n            line = line * ( -1 )\n        end \n        \n        if answerId then\n            answerString = string.format( \"%s will win by %d goals or more.\", teamName, math.ceil( line ) )\n            choiceImage = Constants.PREDICTION_CHOICE_IMAGE_PATH..\"Will-xx_team-score-a-goal-yes.png\"\n        else\n            answerString = string.format( \"%s will not win by %d goals or more.\", teamName, math.ceil( line ) )\n            choiceImage = Constants.PREDICTION_CHOICE_IMAGE_PATH..\"Will-xx_team-score-a-goal-no.png\"\n        end\n    end\n\n    answer:setText( answerString )\n    choice:loadTexture( choiceImage )\n    stake:setText( string.format( stake:getStringValue(), info[\"Stake\"] ) )\n\n    if mIsOpen == false then\n        if info[\"Won\"] then\n            statusBar:setFocused( true )\n            winLoseLabel:setText(\"Won:\")\n            points:setText( string.format( points:getStringValue(), info[\"Stake\"] * ( info[\"Odd\"] - 1 ) ) )\n        else\n            statusBar:setBright( false )\n            winLoseLabel:setText(\"Lost:\")\n            points:setText( string.format( points:getStringValue(), info[\"Stake\"] ) )\n        end\n    else\n        points:setText( string.format( points:getStringValue(), info[\"Stake\"] * ( info[\"Odd\"] - 1 ) ) )\n    end\nend\n","scripts.actions.EnterLeaderboardAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal Logic = require(\"scripts.Logic\").getInstance()\nlocal Competitions = require(\"scripts.data.Competitions\").Competitions\n\nfunction action( param )\n    local url = RequestUtils.GET_COMPETITION_LIST_REST_CALL\n\n    local requestInfo = {}\n    requestInfo.requestData = \"\"\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n\tlocal compList = Competitions:new( jsonResponse )\n\n    local leaderboardMainScene = require(\"scripts.views.LeaderboardMainScene\")\n\tif leaderboardMainScene.isFrameShown() then\n\t\treturn\n\tend\n    leaderboardMainScene.loadFrame( compList )\nend\n","scripts.views.RegisterNameScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ViewUtils = require(\"scripts.views.ViewUtils\")\n\nlocal USERNAME_CONTAINER_NAME = \"usernameContainer\"\nlocal FIRSTNAME_CONTAINER_NAME = \"firstnameContainer\"\nlocal LASTNAME_CONTAINER_NAME = \"lastnameContainer\"\n\nlocal mWidget\nlocal inputWidth = 400\nlocal inputHeight = 50\n\nfunction loadFrame()\n\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/RegisterName.json\")\n    mWidget = widget\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget(widget)\n\n    local confirmBt = widget:getChildByName(\"confirm\")\n    confirmBt:addTouchEventListener( confirmEventHandler )\n\n    ViewUtils.createTextInput( mWidget:getChildByName( USERNAME_CONTAINER_NAME ), \"Username\" )\n    ViewUtils.createTextInput( mWidget:getChildByName( FIRSTNAME_CONTAINER_NAME ), \"First name (Optional)\" )\n    ViewUtils.createTextInput( mWidget:getChildByName( LASTNAME_CONTAINER_NAME ), \"Last name (Optional)\" )\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction setUserName( name )\n    mWidget:getChildByName( USERNAME_CONTAINER_NAME ):getNodeByTag( 1 ):setText( name )\nend\n\nfunction confirmEventHandler( sender,eventType )\n\tif eventType == TOUCH_EVENT_ENDED then\n        local userName = mWidget:getChildByName( USERNAME_CONTAINER_NAME ):getNodeByTag( 1 ):getText()\n        local firstName = mWidget:getChildByName( FIRSTNAME_CONTAINER_NAME ):getNodeByTag( 1 ):getText()\n        local lastName = mWidget:getChildByName( LASTNAME_CONTAINER_NAME ):getNodeByTag( 1 ):getText()\n\n        EventManager:postEvent( Event.Do_Register_Name, { userName, firstName, lastName } )\n    end\nend\n","scripts.events.EventManager":"module(..., package.seeall)\n\nlocal Event = require(\"scripts.events.Event\")\n\nlocal instance\n\nfunction getInstance()\n\tif instance == nil then\n\t\tinstance = EventManager:new()\n\tend\n\n\treturn instance\nend\n\nEventManager = {}\n\nfunction EventManager:new()\n\tif instance ~= nil then\n\t\tassert( false )\n\t\treturn instance\n\tend\n\t\n\tlocal obj = {\n\t\tmEventHandler = {},\n\t\tmEventHistory = {}\n\t}\n    \n    setmetatable(obj, self)\n    self.__index = self\n    \n    obj.__newindex = function(t, k, v) assert(false, \"EventManager--\"..k .. \"__newindex not exist\") end\n    \n    instance = obj\n    return obj \nend\n\nfunction EventManager:registerEventHandler( eventId, action )\n\tself.mEventHandler[eventId] = action\nend\n\nfunction EventManager:postEvent( eventId, param )\n\tif self.mEventHandler[eventId] == nil then\n\t\tprint( \"Event id = \"..Event.GetEventNameById( eventId )..\" has no action.\" )\n\telse\n\t\tprint( \"Event id = \"..Event.GetEventNameById( eventId )..\" handled.\" )\n\t\tself:addHistory( eventId, param )\n\t\tself.mEventHandler[eventId].action( param )\n\tend\nend\n\nfunction EventManager:addHistory( eventId, param )\n\tlocal eventName = Event.GetEventNameById( eventId )\n\tif Event.EventDosenotTrackList[eventName] == nil then\n\t\tprint(\"Track: \"..eventName)\n\t\tlocal history = {\n\t\t\t[\"eventId\"] = eventId,\n\t\t\t[\"param\"] = param\n\t\t}\n\n\t\ttable.insert( self.mEventHistory, history )\n\telse\n\t\tprint(\"Does not track: \"..eventName)\n\tend\nend\n\nfunction EventManager:popHistory()\n\ttable.remove( self.mEventHistory ) -- Throw away the current one.\n\tlocal lastHistory = table.remove( self.mEventHistory ) \n\tif lastHistory ~= nil then\n\t\tself:postEvent( lastHistory[\"eventId\"], lastHistory[\"param\"] )\n\telse\n\t\tprint( \"Dose not have history event.\" )\n\tend\nend\n\nfunction EventManager:popHistoryWithoutExec()\n\ttable.remove( self.mEventHistory )\nend\n","scripts.actions.DoFBConnectAction":"module(..., package.seeall)\n\nlocal Constants = require(\"scripts.Constants\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal Json = require(\"json\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\n\n\nfunction action( param )\n\tlocal Json = require(\"json\")\n\tlocal RequestUtils = require(\"scripts.RequestUtils\")\n\n    local successHandler = function( accessToken )\n        if accessToken == nil then\n            -- To handle user reject to the oAuth.\n            onFBConnectFailed()\n        else\n            print(\"Get login result \"..accessToken)\n            onFBConnectSuccess( accessToken )\n        end\n    end\n\n    FacebookDelegate:sharedDelegate():login( successHandler, successHandler )\nend\n\nfunction onFBConnectFailed()\n\nend\n\nfunction onFBConnectSuccess( accessToken )\n    local requestContent = { SocialNetworkType = 0, AuthToken = accessToken, useDev = RequestUtils.USE_DEV }\n    local requestContentText = Json.encode( requestContent )\n    \n    local url = RequestUtils.FB_LOGIN_REST_CALL\n    \n    local requestInfo = {}\n    requestInfo.requestData = requestContentText\n    requestInfo.url = url\n\n    local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )\n    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )\n    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    local sessionToken = jsonResponse[\"SessionToken\"]\n    local userId = jsonResponse[\"Id\"]\n    local configMd5Info = jsonResponse[\"ConfigMd5Info\"]\n    local displayName = jsonResponse[\"DisplayName\"]\n    local pictureUrl = jsonResponse[\"PictureUrl\"]\n    local startLeagueId = jsonResponse[\"StartLeagueId\"]\n    local balance = jsonResponse[\"Balance\"]\n    local FbId = jsonResponse[\"FbId\"]\n\n    local Logic = require(\"scripts.Logic\").getInstance()\n    Logic:setUserInfo( \"\", \"\", sessionToken, userId )\n    Logic:setDisplayName( displayName )\n    Logic:setPictureUrl( pictureUrl )\n    Logic:setStartLeagueId( startLeagueId )\n    Logic:setBalance( balance )\n    Logic:setFbId( FbId )\n    \n    local finishEvent = Event.Enter_Sel_Fav_Team\n    if displayName == nil then\n        finishEvent = Event.Enter_Register_Name\n    end\n\n    EventManager:postEvent( Event.Check_File_Version, { configMd5Info, finishEvent } )\nend\n","scripts.FileUtils":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\n\nfunction writeStringToFile( fileName, str )\n\tlocal fileUtils = CCFileUtils:sharedFileUtils()\n\tlocal writePath = fileUtils:getWritablePath()..fileName\n\n\tcreateFolderRecur( fileUtils:getWritablePath(), fileName )\n\n\tlocal fileHandle, errorCode = io.open( writePath, \"w+\" )\n\t--print( \"Write to: \"..writePath )\n\tif fileHandle == nil then\n\t\tassert( false, \"Write failed to file\"..fileName..\" with error: \"..errorCode )\n\t\treturn\n\tend\n\n\tfileHandle:write( str )\n\tfileHandle:close()\nend\n\nfunction createFolderRecur( existFolder, toCreateFolder )\n\tprint(\"createFolderRecur: \"..existFolder..\"|\"..toCreateFolder)\n\tlocal pos = string.find( toCreateFolder, \"/\" )\n\tif pos ~= nil then\n\t\tlocal folderToCreate = existFolder..string.sub( toCreateFolder, 1, pos )\n\t\tif lfs.mkdir( folderToCreate ) then\n\t\t\tcreateFolderRecur( folderToCreate, string.sub( toCreateFolder, pos + 1 ) )\n\t\tend\n\tend\nend\n\n-- 1. check the writable path\n-- 2. check the file in the package\nfunction readStringFromFile( fileName )\n\tlocal text = \"\"\n\tlocal fileUtils = CCFileUtils:sharedFileUtils()\n\t\tlocal path = fileUtils:getWritablePath()..fileName\n\tif fileUtils:isFileExist( path ) then\n\t\tprint(\"Read local file from: \"..path)\n\n\t\tlocal fileHandler, errorCode = io.open( path, \"r\" )\n\t\t--print( \"Read from: \"..path )\n\t\tif fileHandler == nil then\n\t\t\tassert( false, \"Read failed from file\"..fileName..\" with error: \"..errorCode )\n\t\t\treturn \"\"\n\t\tend\n\t\t\n\t\ttext = fileHandler:read(\"*all\")\n\t\tfileHandler:close()\n\telse\n\t\tlocal fileName = fileUtils:fullPathForFilename( fileName )\n\t\tprint(\"Read file from package: \"..fileName)\n\t\ttext = fileUtils:getFileData( fileName, \"r\", 0 )\n\tend\n\n\n\treturn text\nend\n\n","scripts.data.Competitions":"module(..., package.seeall)\n\nCompetitions = {}\n\n--[[\nData structure:\n\n[\n\n   {\n\n      \"Id\": 2,\n\n      \"Name\": \"tttt\",\n\n      \"Description\": \"tttt\",\n\n      \"StartTime\": \"1403249853\",\n\n      \"EndTime\": \"1418313600\",\n\n      \"Open\": true,\n\n      \"OwnedByMe\": true,\n\n      \"OwningUserName\": \"Test001\"\n\n   }\n\n]\n\n--]]\n\nfunction Competitions:new( list )\n\tlocal obj = {\n\t\tList = list,\n\t}\n\n\tsetmetatable(obj, self)\n    self.__index = self\n    \n    obj.__newindex = function(t, k, v) assert(false, \"Competitions--\"..k .. \"__newindex not exist\") end\n    \n    return obj \nend\n\nfunction Competitions:getSize()\n    return table.getn( self.List )\nend\n\nfunction Competitions:get( index )\n    return self.List[index]\nend\n","scripts.views.HistoryMainScene":"module(..., package.seeall)\n\nlocal SceneManager = require(\"scripts.SceneManager\")\nlocal Navigator = require(\"scripts.views.Navigator\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal TeamConfig = require(\"scripts.config.Team\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\n\nlocal CONTENT_FADEIN_TIME = 1\n\nlocal mWidget\nlocal mStep\n\n-- DS for couponHistory see CouponHistoryData\nfunction loadFrame( userId, userName, couponHistory )\n    if userId == Logic:getUserId() then\n        mWidget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/HistoryHome.json\")\n        local totalPoints = tolua.cast( mWidget:getChildByName(\"totalPoints\"), \"Label\" )\n        totalPoints:setText( string.format( totalPoints:getStringValue(), couponHistory:getBalance() ) )\n    else\n        mWidget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/HistoryHomeForOthers.json\")\n        local name = tolua.cast( mWidget:getChildByName(\"name\"), \"Label\" )\n        name:setText( userName )\n        local totalPoints = tolua.cast( mWidget:getChildByName(\"totalPoints\"), \"Label\" )\n        totalPoints:setText( string.format( totalPoints:getStringValue(), couponHistory:getBalance() ) )\n\n        local backEventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                EventManager:popHistory()\n            end\n        end\n\n        local backBt = mWidget:getChildByName(\"Back\")\n        backBt:addTouchEventListener( backEventHandler )\n    end\n\t\n    mWidget:registerScriptHandler( EnterOrExit )\n    SceneManager.clearNAddWidget( mWidget )\n\n    Navigator.loadFrame( mWidget )\n\n    initContent( couponHistory )\n    mStep = 1\nend\n\nfunction EnterOrExit( eventType )\n    if eventType == \"enter\" then\n    elseif eventType == \"exit\" then\n        mWidget = nil\n    end\nend\n\nfunction isFrameShown()\n    return mWidget ~= nil\nend\n\nfunction initContent( couponHistory )\n\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n    contentContainer:removeAllChildrenWithCleanup( true )\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n    local contentHeight = 0\n\n    local seqArray = CCArray:create()\n\n    -- Add the open predictions \n    seqArray:addObject( CCCallFuncN:create( function()\n        local content = GUIReader:shareReader():widgetFromJsonFile(\"scenes/HistoryMainTitle.json\")\n        local titleText = tolua.cast( content:getChildByName(\"titleText\"), \"Label\" )\n        titleText:setText( \"Open Predictions\" )\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n\n        content:setOpacity( 0 )\n        content:setCascadeOpacityEnabled( true )\n        mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )\n    end ) )\n    seqArray:addObject( CCDelayTime:create( 0.2 ) )\n\n    for i = 1, table.getn( couponHistory:getOpenData() ) do\n    \tlocal eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                predictionClicked( true, couponHistory:getOpenData()[i] )\n            end\n        end\n\n        seqArray:addObject( CCCallFuncN:create( function()\n            -- Add the open matches\n            local content = SceneManager.widgetFromJsonFile(\"scenes/HistoryMainMatchContent.json\")\n            content:setLayoutParameter( layoutParameter )\n            contentContainer:addChild( content )\n            contentHeight = contentHeight + content:getSize().height\n            local bt = content:getChildByName(\"match\")\n            bt:addTouchEventListener( eventHandler )\n            helperInitPredictionCommon( content, couponHistory:getOpenData()[i] )\n            helperInitOpenPrediction( content, couponHistory:getOpenData()[i] )\n\n            content:setOpacity( 0 )\n            content:setCascadeOpacityEnabled( true )\n            mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )\n        end ) )\n        seqArray:addObject( CCDelayTime:create( 0.2 ) )\n    end\n\n    -- Add the closed predictions\n    seqArray:addObject( CCCallFuncN:create( function()\n        local content = GUIReader:shareReader():widgetFromJsonFile(\"scenes/HistoryMainTitle.json\")\n        local titleText = tolua.cast( content:getChildByName(\"titleText\"), \"Label\" )\n        titleText:setText( \"Closed Predictions\" )\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n\n        content:setOpacity( 0 )\n        content:setCascadeOpacityEnabled( true )\n        mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )\n    end ) )\n    seqArray:addObject( CCDelayTime:create( 0.2 ) )\n\n    for i = 1, table.getn( couponHistory:getClosedData() ) do\n    \tlocal eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                predictionClicked( false, couponHistory:getClosedData()[i] )\n            end\n        end\n\n        seqArray:addObject( CCCallFuncN:create( function()\n            -- Add the open matches\n            local content = SceneManager.widgetFromJsonFile(\"scenes/HistoryMainMatchContent.json\")\n            content:setLayoutParameter( layoutParameter )\n            contentContainer:addChild( content )\n            contentHeight = contentHeight + content:getSize().height\n            local bt = content:getChildByName(\"match\")\n            bt:addTouchEventListener( eventHandler )\n            helperInitPredictionCommon( content, couponHistory:getClosedData()[i] )\n            helperInitClosedPrediction( content, couponHistory:getClosedData()[i] )\n\n            content:setOpacity( 0 )\n            content:setCascadeOpacityEnabled( true )\n            mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )\n        end ) )\n        seqArray:addObject( CCDelayTime:create( 0.2 ) )\n    end\n\n    seqArray:addObject( CCCallFuncN:create( function()\n        if table.getn( couponHistory:getClosedData() ) > 0 then\n            -- Add the \"More\" button\n            contentHeight = contentHeight + addMoreButton( contentContainer, layoutParameter ):getSize().height\n        end\n\n        contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n        local layout = tolua.cast( contentContainer, \"Layout\" )\n        layout:requestDoLayout()\n    end ) )\n\n    mWidget:runAction( CCSequence:create( seqArray ) )\nend\n\nfunction predictionClicked( isOpen, matchInfo )\n\tEventManager:postEvent( Event.Enter_History_Detail, { isOpen, matchInfo } )\nend\n\nfunction addMoreButton( contentContainer, layoutParameter )\n    local content = SceneManager.widgetFromJsonFile(\"scenes/MoreContent.json\")\n    content:setLayoutParameter( layoutParameter )\n    contentContainer:addChild( content )\n    content:addTouchEventListener( loadMore )\n    content:setName(\"More\")\n\n    return content\nend\n\nfunction loadMore( sender, eventType )\n    if eventType == TOUCH_EVENT_ENDED then\n        mStep = mStep + 1\n        EventManager:postEvent( Event.Load_More_In_History, { mStep } )\n    end\nend\n\nfunction loadMoreContent( couponHistory )\n    local contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )\n\n    -- Remove the \"More\" button\n    local moreButton = contentContainer:getChildByName(\"More\")\n    moreButton:removeFromParent()\n\n    local layoutParameter = LinearLayoutParameter:create()\n    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)\n    local contentHeight = contentContainer:getInnerContainerSize().height\n\n    for i = 1, table.getn( couponHistory:getClosedData() ) do\n        local eventHandler = function( sender, eventType )\n            if eventType == TOUCH_EVENT_ENDED then\n                predictionClicked( false, couponHistory:getClosedData()[i] )\n            end\n        end\n\n        -- Add the open matches\n        local content = SceneManager.widgetFromJsonFile(\"scenes/HistoryMainMatchContent.json\")\n        content:setLayoutParameter( layoutParameter )\n        contentContainer:addChild( content )\n        contentHeight = contentHeight + content:getSize().height\n        local bt = content:getChildByName(\"match\")\n        bt:addTouchEventListener( eventHandler )\n        helperInitPredictionCommon( content, couponHistory:getClosedData()[i] )\n        helperInitClosedPrediction( content, couponHistory:getClosedData()[i] )\n    end\n\n    if table.getn( couponHistory:getClosedData() ) > 0 then\n        -- Add back the \"More\" button\n        addMoreButton( contentContainer, layoutParameter )\n    end\n\n    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )\n    local layout = tolua.cast( contentContainer, \"Layout\" )\n    layout:requestDoLayout()\nend\n\nfunction helperInitPredictionCommon( content, matchInfo )\n    local team1 = tolua.cast( content:getChildByName(\"team1\"), \"ImageView\" )\n    local team2 = tolua.cast( content:getChildByName(\"team2\"), \"ImageView\" )\n    local team1Name = tolua.cast( content:getChildByName(\"team1Name\"), \"Label\" )\n    local team2Name = tolua.cast( content:getChildByName(\"team2Name\"), \"Label\" )\n    \n    team1:loadTexture( TeamConfig.getLogo( TeamConfig.getConfigIdByKey( matchInfo[\"HomeTeamId\"] ) ) )\n    team2:loadTexture( TeamConfig.getLogo( TeamConfig.getConfigIdByKey( matchInfo[\"AwayTeamId\"] ) ) )\n    team1Name:setText( TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( matchInfo[\"HomeTeamId\"] ) ) )\n    team2Name:setText( TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( matchInfo[\"AwayTeamId\"] ) ) )\n    team1Name:setFontName(\"fonts/Newgtbxc.ttf\")\n    team2Name:setFontName(\"fonts/Newgtbxc.ttf\")\nend\n\nfunction helperInitOpenPrediction( content, matchInfo )\n    local points = tolua.cast( content:getChildByName(\"points\"), \"Label\" )\n    local pointsTitle = tolua.cast( content:getChildByName(\"pointsTitle\"), \"Label\" )\n    local roi = tolua.cast( content:getChildByName(\"roi\"), \"Label\" )\n    local winPercentage = tolua.cast( content:getChildByName(\"winPercentage\"), \"Label\" )\n    local pointWinInd = tolua.cast( content:getChildByName(\"pointWinInd\"), \"Button\" )\n    local score = tolua.cast( content:getChildByName(\"score\"), \"Label\" )\n\n    --points:setText( \"-\" )\n    --roi:setText( string.format( roi:getStringValue(), 0 ) )\n    --winPercentage:setText( string.format( winPercentage:getStringValue(), \"%\" ) )\n    points:setEnabled( false )\n    pointsTitle:setEnabled( false )\n    roi:setEnabled( false )\n    winPercentage:setEnabled( false )\n    pointWinInd:setEnabled( false )\n    score:setEnabled( false )\nend\n\nfunction helperInitClosedPrediction( content, matchInfo )\n    local points = tolua.cast( content:getChildByName(\"points\"), \"Label\" )\n    local roi = tolua.cast( content:getChildByName(\"roi\"), \"Label\" )\n    local winPercentage = tolua.cast( content:getChildByName(\"winPercentage\"), \"Label\" )\n    local vs = tolua.cast( content:getChildByName(\"VS\"), \"Label\" )\n    local pointWinInd = tolua.cast( content:getChildByName(\"pointWinInd\"), \"Button\" )\n    local statusBar = tolua.cast( content:getChildByName(\"statusBar\"), \"Button\" )\n    local score = tolua.cast( content:getChildByName(\"score\"), \"Label\" )\n    \n    if matchInfo[\"Profit\"] >= 0 then\n        statusBar:setFocused( true )\n    else\n        pointWinInd:setBright( false )\n        statusBar:setBright( false )\n    end\n\n    points:setText( matchInfo[\"Profit\"] )\n    roi:setText( string.format( roi:getStringValue(), matchInfo[\"Roi\"] ) )\n    winPercentage:setText( string.format( winPercentage:getStringValue(), matchInfo[\"WinPercentage\"] ) )\n    vs:setEnabled( false )\n    score:setText( matchInfo[\"Result\"] )\nend\n","scripts.actions.DoCreateCompetitionAction":"module(..., package.seeall)\n\nlocal Json = require(\"json\")\nlocal Constants = require(\"scripts.Constants\")\nlocal EventManager = require(\"scripts.events.EventManager\").getInstance()\nlocal Event = require(\"scripts.events.Event\").EventList\nlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")\nlocal RequestUtils = require(\"scripts.RequestUtils\")\nlocal Logic = require(\"scripts.Logic\").getInstance()\n\nfunction action( param )\n\n    local name, description, endTime, selectedLeagues = param[1], param[2], param[3], param[4]\n\n    if string.len( name ) == 0 then\n        RequestUtils.onRequestFailed( \"Title cannot blank.\" )\n        return\n    end\n    if string.len( description ) == 0 then\n        RequestUtils.onRequestFailed( \"Description cannot be blank.\" )\n        return\n    end\n\n    if endTime < os.time() then\n        RequestUtils.onRequestFailed( \"The end date cannot be in the past.\" )\n        return\n    end\n\n    if table.getn( selectedLeagues ) == 0 then\n        RequestUtils.onRequestFailed( \"Selected League cannot be blank.\" )\n        return\n    end\n\n    local requestContent = { Name = name, \n                            Description = description, \n                            EndTime = endTime, \n                            AllowedLeaguesIds = selectedLeagues }\n    local requestContentText = Json.encode( requestContent )\n    print( requestContentText )\n    \n    local url = RequestUtils.POST_CREATE_COMPETITION_REST_CALL\n\n    local requestInfo = {}\n    requestInfo.requestData = requestContentText\n    requestInfo.url = url\n\n     local handler = function( isSucceed, body, header, status, errorBuffer )\n        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )\n    end\n\n    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )\n    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )\n    httpRequest:addHeader( Logic:getAuthSessionString() )\n    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )\n    httpRequest:sendHttpRequest( url, handler )\n\n    ConnectingMessage.loadFrame()\nend\n\nfunction onRequestSuccess( jsonResponse )\n    local competitionId = jsonResponse[\"CompetitionId\"]\n    local joinToken = jsonResponse[\"JoinToken\"]\n\n    EventManager:popHistoryWithoutExec()    -- Remove the create competition event in history. So that it can back direct to the Community scene.\n    EventManager:postEvent( Event.Enter_Competition_Detail, { competitionId } )\nend\n"}