{"scripts.views.PredTotalConfirmScene":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local SceneManager = require(\"scripts.SceneManager\")local Logic = require(\"scripts.Logic\").getInstance()local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal mWidgetfunction loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/PredFinalConfirm.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    mWidget:addTouchEventListener( bgEventHandler )    SceneManager.addWidget(widget)\tinitContent()    local confirmBt = widget:getChildByName(\"confirm\")    confirmBt:addTouchEventListener( confirmEventHandler )    local cancelBt = widget:getChildByName(\"cancel\")    cancelBt:addTouchEventListener( cancelEventHandler )    local facebook = mWidget:getChildByName(\"facebook\")    facebook:addTouchEventListener( facebookEventHandler )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction bgEventHandler( sender, eventType )\t-- Do nothing, just blockendfunction confirmEventHandler( sender, eventType )\tif eventType == TOUCH_EVENT_ENDED then\t\tlocal facebook = tolua.cast( mWidget:getChildByName(\"facebook\"), \"CheckBox\" )\t\tLogic:setPredictionMetadata( \"\", facebook:getSelectedState() )\t    EventManager:postEvent( Event.Do_Post_Predictions )\tendendfunction cancelEventHandler( sender, eventType )\tif eventType == TOUCH_EVENT_ENDED then\t\tLogic:resetPredictions()    \tEventManager:postEvent( Event.Enter_Match_List )\tendendfunction facebookEventHandler( sender, eventType )\tif eventType == TOUCH_EVENT_ENDED then\t\tlocal facebook = tolua.cast( mWidget:getChildByName(\"facebook\"), \"CheckBox\" )\t\tif facebook:getSelectedState() == false and Logic:getFbId() == false then\t\t\tlocal successHandler = function()\t\t\t\t-- Nothing to do.\t\t\tend\t\t\tlocal failedHandler = function( selectedState )\t\t\t\tfacebook:setSelectedState( selectedState )\t\t\tend\t\t\tEventManager:postEvent( Event.Do_FB_Connect_With_User, { successHandler, failedHandler } )\t\tend\tendendfunction initContent()\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"resultContainer\"), \"ScrollView\" )    contentContainer:removeAllChildrenWithCleanup( true )    local layoutParameter = LinearLayoutParameter:create()    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)    local contentHeight = 0    local predictions = Logic:getPredictions()\tfor i = 1, predictions:getSize() do\t\tlocal content = SceneManager.widgetFromJsonFile(\"scenes/PredFinalConfirmContent.json\")\t\tif i == 1 then\t\t\tlocal bg = tolua.cast( content:getChildByName(\"bg\"), \"ImageView\" )\t\t\tbg:loadTexture( \"scenes/PredictionConfirm/bg-1.png\" )\t\tend\t\tlocal coupon = predictions:get( i )\t\tlocal question = tolua.cast( content:getChildByName(\"Question\"), \"Label\" )\t\tlocal reward = tolua.cast( content:getChildByName(\"Reward\"), \"Label\" )\t\tlocal stake = tolua.cast( content:getChildByName(\"stake\"), \"Label\" )\t\tlocal answerIcon = tolua.cast( content:getChildByName(\"answerIcon\"), \"ImageView\" )\t\tquestion:setFontName( \"Newgtbxc\" )\t\treward:setFontName( \"Newgtbxc\" )\t\tquestion:setText( coupon[\"Answer\"] )\t\treward:setText( string.format( reward:getStringValue(), coupon[\"Reward\"] ) )\t\tstake:setText( string.format( stake:getStringValue(), coupon[\"Stake\"] ) )\t\tanswerIcon:loadTexture( coupon[\"AnswerIcon\"] )        content:setLayoutParameter( layoutParameter )        contentContainer:addChild( content )        contentHeight = contentHeight + content:getSize().height\tend\t-- Update the size of the scroll view so that it locate just above the facebook button.\tlocal originSize = contentContainer:getSize()\tif originSize.height > contentHeight then\t\tcontentContainer:setSize( CCSize:new( originSize.width, contentHeight ) )\t\tcontentContainer:setTouchEnabled( false )\tend\tcontentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )    local layout = tolua.cast( contentContainer, \"Layout\" )    layout:requestDoLayout()end","scripts.data.MarketsForGameData":"module(..., package.seeall)local MarketConfig = require(\"scripts.config.Market\")MarketsForGameData = {}--[[[    {        \"marketTypeId\": 25,        \"Line\": null,        \"odds\": [            {                \"Id\": 2303086,                \"Odd\": 4,                \"OutcomeUIPosition\": 1            },            {                \"Id\": 2303100,                \"Odd\": 1.83,                \"OutcomeUIPosition\": 2            }        ]    },    {        \"marketTypeId\": 26,        \"Line\": 2.5,        \"odds\": [            {                \"Id\": 2303110,                \"Odd\": 1.7,                \"OutcomeUIPosition\": 1            },            {                \"Id\": 2303116,                \"Odd\": 2.1,                \"OutcomeUIPosition\": 2            }        ]    },    {        \"marketTypeId\": 27,        \"Line\": 0.5,        \"odds\": [            {                \"Id\": 2397661,                \"Odd\": 2.02,                \"OutcomeUIPosition\": 1            },            {                \"Id\": 2397666,                \"Odd\": 1.86,                \"OutcomeUIPosition\": 2            }        ]    }]--]]function MarketsForGameData:new( list )\tlocal match = nil\tlocal matchIndex = 0\tfor k, v in pairs( list ) do\t\tlocal market = v\t\tif market[\"marketTypeId\"] == MarketConfig.MARKET_TYPE_MATCH then\t\t\tmatch = market\t\t\tmatchIndex = k\t\tend\tend\tif match ~= nil then\t\ttable.remove( list, matchIndex )\tend\tlocal obj = {\t\tmatchMarket = match,\t\tmarketList = list\t}\tsetmetatable(obj, self)    self.__index = self        obj.__newindex = function(t, k, v) assert(false, \"MatchListData--\"..k .. \"__newindex not exist\") end        return obj endfunction MarketsForGameData:getMatchMarket()\treturn self.matchMarketendfunction MarketsForGameData:getNum()\treturn table.getn( self.marketList )endfunction MarketsForGameData:getMarketAt( index )\treturn self.marketList[index]end-- Get the market info which contains the given couponIdfunction MarketsForGameData:getMarketInfoByCouponId( couponId )    for k, v in pairs( self.matchMarket[\"odds\"] ) do        local odds = v        if odds[\"Id\"] == couponId then            return self.matchMarket        end    end    for i = 1, self:getNum() do        local market = self:getMarketAt(i)        for k, v in pairs( market[\"odds\"] ) do            local odds = v            if odds[\"Id\"] == couponId then                return market            end        end    end    return nilend-- Getters for inner data structurefunction getMarketType( market )    return market[\"marketTypeId\"]endfunction getMarketLine( market )    return market[\"Line\"]endfunction getOddConfigForType( market, oddsType )    for k, v in pairs( market[\"odds\"] ) do        local odds = v        if odds[\"OutcomeUIPosition\"] == oddsType then            return odds        end    end    return nilendfunction getOddIdForType( market, oddsType )    local oddsConfig = getOddConfigForType( market, oddsType )        if oddsConfig ~= nil then        return oddsConfig[\"Id\"]    end    return 0endfunction getOddsForType( market, oddsType )\tlocal oddsConfig = getOddConfigForType( market, oddsType )\t\tif oddsConfig ~= nil then\t\treturn oddsConfig[\"Odd\"] * 1000\tend\treturn 0end","scripts.views.MatchPredictionScene":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local SceneManager = require(\"scripts.SceneManager\")local TeamConfig = require(\"scripts.config.Team\")local MarketConfig = require(\"scripts.config.Market\")local Logic = require(\"scripts.Logic\").getInstance()local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal MarketsForGameData = require(\"scripts.data.MarketsForGameData\")local mWidgetlocal mMatchlocal mMarketsDatalocal MIN_MOVE_DISTANCE = 100local SCALE_BASE = 0.8local SCALE_UP_OFFSET_MAX = 0.2local SCALE_DOWN_OFFSET_MAX = -0.2local OPACITY = 255function loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/MatchPrediction.json\")    mMatch = Logic:getSelectedMatch()    mMarketsData = Logic:getCurMarketInfo():getMatchMarket()    local backBt = widget:getChildByName(\"Back\")    backBt:addTouchEventListener( backEventHandler )    helperInitMatchInfo( widget )    widget:addTouchEventListener( onFrameTouch )    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget(widget)endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction selectTeam1Win()    local team1 = tolua.cast( mWidget:getChildByName(\"team1\"), \"ImageView\" )    makePrediction(        MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION ),        MarketsForGameData.getOddIdForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION ),        TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) )..\" to win.\",        team1:getTextureFile() )endfunction selectTeam2Win()    local team2 = tolua.cast( mWidget:getChildByName(\"team2\"), \"ImageView\" )    makePrediction(        MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION ),        MarketsForGameData.getOddIdForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION ),        TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) )..\" to win.\",        team2:getTextureFile() )endfunction backEventHandler( sender, eventType )    if eventType == TOUCH_EVENT_ENDED then        --EventManager:postEvent( Event.Enter_Match_List )        EventManager:popHistory()    endendfunction makePrediction( rewards, oddId, answer, answerIcon )    local seqArray = CCArray:create()    seqArray:addObject( CCDelayTime:create( 0.1 ) )    seqArray:addObject( CCCallFuncN:create( function()        --EventManager:postEvent( Event.Enter_Prediction_Confirm, { answer, rewards, oddId, answerIcon } )        Logic:addPrediction( oddId, answer, rewards, answerIcon )        EventManager:postEvent( Event.Enter_Next_Prediction )    end ) )    mWidget:runAction( CCSequence:create( seqArray ) )    endfunction helperUpdatePoint( content )    local point = Logic:getPoint()    local pointLabel = tolua.cast( content:getChildByName(\"myPoint\"), \"Label\" )    pointLabel:setText( point )endfunction helperInitMatchInfo( content, marketsData )    local team1 = tolua.cast( content:getChildByName(\"team1\"), \"ImageView\" )    local team2 = tolua.cast( content:getChildByName(\"team2\"), \"ImageView\" )    local team1Name = tolua.cast( content:getChildByName(\"team1Name\"), \"Label\" )    local team2Name = tolua.cast( content:getChildByName(\"team2Name\"), \"Label\" )    local team1WinPoint = tolua.cast( team1:getChildByName(\"team1WinPoint\"), \"Label\" )    local team2WinPoint = tolua.cast( team2:getChildByName(\"team2WinPoint\"), \"Label\" )    local stake = tolua.cast( content:getChildByName(\"stake\"), \"Label\" )    local balance = tolua.cast( content:getChildByName(\"balance\"), \"Label\" )    team1:loadTexture( TeamConfig.getLogo( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) ) )    team2:loadTexture( TeamConfig.getLogo( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) ) )    team1Name:setText( TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) ) )    team2Name:setText( TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) ) )    team1WinPoint:setText( MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION )..\" points\" )    team2WinPoint:setText( MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION )..\" points\" )    stake:setText( string.format( stake:getStringValue(), Constants.STAKE ) )    balance:setText( string.format( balance:getStringValue(), Logic:getBalance() - Logic:getUncommitedBalance() ) )endfunction onFrameTouch( sender, eventType )    local team1 = tolua.cast( mWidget:getChildByName(\"team1\"), \"ImageView\" )    local team2 = tolua.cast( mWidget:getChildByName(\"team2\"), \"ImageView\" )    if eventType == TOUCH_EVENT_ENDED then        local touchBeginPoint = sender:getTouchStartPos()        local touchEndPoint = sender:getTouchEndPos()        if touchBeginPoint.x - touchEndPoint.x > MIN_MOVE_DISTANCE then            -- Swap to Left            selectTeam2Win()        elseif touchBeginPoint.x - touchEndPoint.x < MIN_MOVE_DISTANCE * (-1) then            -- Swap to Right            selectTeam1Win()        else            team1:setScale( SCALE_BASE )            team2:setScale( SCALE_BASE )            team1:setOpacity( OPACITY )            team2:setOpacity( OPACITY )        end    elseif eventType == TOUCH_EVENT_MOVED then        local touchBeginPoint = sender:getTouchStartPos()        local touchMovPoint = sender:getTouchMovePos()        local scalePercentage = math.abs( touchBeginPoint.x - touchMovPoint.x ) / MIN_MOVE_DISTANCE        if scalePercentage > 1 then            scalePercentage = 1        end        if touchBeginPoint.x - touchMovPoint.x > 0 then            team2:setScale( scalePercentage * SCALE_UP_OFFSET_MAX + SCALE_BASE )            team1:setScale( scalePercentage * SCALE_DOWN_OFFSET_MAX + SCALE_BASE )            team2:setOpacity( OPACITY )            team1:setOpacity( OPACITY / 3 )        else            team1:setScale( scalePercentage * SCALE_UP_OFFSET_MAX + SCALE_BASE )            team2:setScale( scalePercentage * SCALE_DOWN_OFFSET_MAX + SCALE_BASE )            team1:setOpacity( OPACITY )            team2:setOpacity( OPACITY / 3 )        end    endend","scripts.actions.LoadMoreInLeaderboardAction":"module(..., package.seeall)local Json = require(\"json\")local ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal RequestUtils = require(\"scripts.RequestUtils\")local LeaderboardConfig = require(\"scripts.config.Leaderboard\")local Logic = require(\"scripts.Logic\").getInstance()local mLeaderboardIdlocal mSubTypefunction action( param )\tmLeaderboardId = param[1]\tmSubType = param[2]\tlocal step = param[3]\tlocal url = RequestUtils.GET_MAIN_LEADERBOARD_REST_CALL..\"?sortType=\"..mSubType[\"sortType\"]..\"&step=\"..step    local requestInfo = {}    requestInfo.requestData = \"\"    requestInfo.url = url\tlocal handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )    httpRequest:addHeader( Logic:getAuthSessionString() )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( response )    local leaderboardListScene = require(\"scripts.views.LeaderboardListScene\")    leaderboardListScene.loadMoreContent( response )end","scripts.config.Country":"module(..., package.seeall)local JsonConfigReader = require(\"scripts.config.JsonConfigReader\")local LeagueConfig = require(\"scripts.config.League\")local Constants = require(\"scripts.Constants\")local DoLogReport = require(\"scripts.actions.DoLogReport\")local FILE_NAME = \"config/countries.txt\"local mConfig = {}local mIndex = {}local mConfigNum = 0function init()\tif mConfigNum > 0 then \t\treturn\tend\tprint(\"Read Country config.\")\tlocal filter = function( v )\t\treturn v[\"isActive\"]\tend\tmConfig, mConfigNum, mIndex = JsonConfigReader.read( FILE_NAME, \"Id\", filter )\tprint( \"Read active country number: \"..mConfigNum )\tfor i = 1, LeagueConfig.getConfigNum() do\t\tlocal countryId = LeagueConfig.getCountryId( i )\t\taddLeague( getConfigIdByKey( countryId ), i )\tend\tfor i = 1, getConfigNum() do\t\tif getLeagueList( i ) == nil then\t\t\tassert( \"County \"..getCountryName( i )..\" has no league.\" )\t\telse\t\t\tprint( \"County \"..getCountryName( i )..\" has \"..table.getn( getLeagueList( i ) )..\" leagues.\" )\t\tend\tendendfunction getConfig( id )\tassert( mConfig[id] ~= nil, FILE_NAME..\" dosen't has \"..id )\treturn mConfig[id]endfunction getConfigIdByKey( key )\tif mIndex[key] == nil then\t\tlocal log = FILE_NAME..\" dosen't has \"..key\t\tprint( log )\t\tDoLogReport.reportConfigError( log )\t\treturn nil\tend\treturn mIndex[key]endfunction getConfigNum()\treturn mConfigNumend--[[\tProvide additional getters.--]]function getCountryCode( id )\tlocal config = getConfig( id )\treturn config[\"countryCode\"]endfunction getCountryName( id )\tlocal config = getConfig( id )\tif config[\"countryName\"] ~= nil then\t\treturn config[\"countryName\"]\telse\t\treturn config[\"countryCode\"]\tendendfunction isActive( id )\tlocal config = getConfig( id )\treturn config[\"isActive\"]endfunction addLeague( id, leagueId )\tlocal config = getConfig( id )\tif config[\"leagueList\"] == nil then\t\tconfig[\"leagueList\"] = {}\tend\ttable.insert( config[\"leagueList\"], leagueId )endfunction getLeagueList( id )\tlocal config = getConfig( id )\treturn config[\"leagueList\"]endfunction getLogo( id )\tlocal config = getConfig( id )\tif config ~= nil then\t\tlocal fileUtils = CCFileUtils:sharedFileUtils()\t\tlocal filePath = fileUtils:fullPathForFilename( Constants.COUNTRY_IMAGE_PATH..config[\"Id\"]..\".png\" )\t\tprint( \"Countries \"..filePath )\t\tif fileUtils:isFileExist( filePath ) then\t\t\treturn Constants.COUNTRY_IMAGE_PATH..config[\"Id\"]..\".png\"\t\telse\t\t\treturn Constants.COUNTRY_IMAGE_PATH..\"default.png\"\t\tend\telse\t\treturn Constants.COUNTRY_IMAGE_PATH..\"default.png\"\tendendinit()","scripts.views.SelFavTeamScene":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local SceneManager = require(\"scripts.SceneManager\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal LeagueConfig = require(\"scripts.config.League\")local TeamConfig = require(\"scripts.config.Team\")local LeagueTeamConfig = require(\"scripts.config.LeagueTeams\")local LeagueListScene = require(\"scripts.views.LeagueListScene\")local TEAM_NUM = 20local mWidgetlocal mDisplayLeagueIdlocal mLeagueIdlocal mTeamIdfunction loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/FavouriteTeam.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.addWidget( widget )    LeagueListScene.loadFrame( \"scenes/FavouriteCountryContent.json\", \"scenes/FavouriteLeagueContent.json\",         tolua.cast( mWidget:getChildByName(\"countryList\"), \"ScrollView\" ), leagueSelected )    -- Disable the ok button    local okBt = widget:getChildByName(\"ok\")    okBt:addTouchEventListener( okEventHandler )    okBt:setBright( false )    -- Set the default one.    leagueSelected( 1 )    local leagueName = tolua.cast( mWidget:getChildByName(\"leagueName\"), \"Label\" )    leagueName:setText( \"Please select your favourite team.\" )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction okEventHandler( sender, eventType )    if eventType == TOUCH_EVENT_ENDED then        print(\"Favourite Team is: \"..mTeamId..\" in league: \"..mLeagueId)        EventManager:postEvent( Event.Do_Post_Fav_Team, { mTeamId, mLeagueId } )    endendfunction leagueSelected( leagueId )    mDisplayLeagueId = LeagueConfig.getConfigId( leagueId )    print( \"leagueSelected: \"..mDisplayLeagueId )--[[    -- Update the country list    local countryContainer = tolua.cast( mWidget:getChildByName(\"countryList\"), \"ScrollView\" )    for i = 1, LeagueConfig.getConfigNum() do        local country = countryContainer:getChildByTag( i )        if i == leagueId then            country:setOpacity( 255 )        else            country:setOpacity( 100 )        end    end--]]        -- Update the team list.    local teamList = LeagueTeamConfig.getConfig( LeagueConfig.getConfigId( leagueId ) )    local teamListLength = table.getn( teamList )    local teamContainer = tolua.cast( mWidget:getChildByName(\"teamList\"), \"ScrollView\" )    teamContainer:removeAllChildren()    local layoutParameter = LinearLayoutParameter:create()    layoutParameter:setGravity(LINEAR_GRAVITY_LEFT)    local contentHeight = 0    for i = 1, ( teamListLength + 1 ) / 2 do        local content = GUIReader:shareReader():widgetFromJsonFile(\"scenes/Team.json\")        for j = 1, 2 do            local teamIndex = ( i - 1 ) * 2 + j            local eventHandler = function( sender, eventType )                if eventType == TOUCH_EVENT_ENDED then                    local teamId = TeamConfig.getConfigIdByKey( teamList[teamIndex][\"teamId\"] )                    teamSelected( teamId )                end            end            local teamButton = tolua.cast( content:getChildByName(\"team\"..j), \"Button\" )            local teamName = tolua.cast( content:getChildByName(\"team\"..j..\"Name\"), \"Label\" )            if teamIndex > teamListLength then                teamName:setVisible( false )                teamButton:setVisible( false )            else                local teamId = TeamConfig.getConfigIdByKey( teamList[teamIndex][\"teamId\"] )                teamButton:loadTextureNormal( TeamConfig.getLogo( teamId ) )                teamButton:addTouchEventListener( eventHandler )                teamName:setText( TeamConfig.getTeamName( teamId ) )            end                    end        content:setLayoutParameter( layoutParameter )        teamContainer:addChild( content )        contentHeight = contentHeight + content:getSize().height    end    teamContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )endfunction teamSelected( index )    print(\"Team Selected: \"..index)    mLeagueId = mDisplayLeagueId    mTeamId = TeamConfig.getTeamId( index )    local teamSelected = tolua.cast( mWidget:getChildByName(\"leagueName\"), \"Label\" )    teamSelected:setText( \"Your favourite team: \"..TeamConfig.getTeamName( index ) )    local okBt = mWidget:getChildByName(\"ok\")    okBt:setBright( true )end","scripts.actions.EnterNextPredictionAction":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal Logic = require(\"scripts.Logic\").getInstance()local SceneManager = require(\"scripts.SceneManager\")function action( param )\tlocal marketInfo = Logic:getCurMarketInfo()\tlocal curDisplayMarketIndex = Logic:getCurDisplayMarketIndex()\tcurDisplayMarketIndex = curDisplayMarketIndex + 1\tLogic:setCurDisplayMarketIndex( curDisplayMarketIndex )\tif curDisplayMarketIndex > marketInfo:getNum() then\t\tEventManager:postEvent( Event.Enter_Pred_Total_Confirm )\telse\t\tprint( \"Display the next prediction: \"..curDisplayMarketIndex )\t\tlocal ScorePrediction = require(\"scripts.views.ScorePrediction\")\t\tlocal matchMarketData = marketInfo:getMarketAt( curDisplayMarketIndex )\t\tSceneManager.clear()\t\tScorePrediction.loadFrame( matchMarketData )\tendend","scripts.actions.DoLogReport":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local PROJECT_ID = \"544021a2e18b11e3923422000ab5bb50\"local ACCOUNT_ID = \"sXq6y8k3RoWKE8pyCSEJfZH9LsTc3MmCv9wjNMVjx3zhSFZN-H9Vu0_VveSM2ITwFMxJF5nYlD4=\"local SPLUNK_LOG_IP = \"https://api.p3js-eqtr.data.splunkstorm.com/1/inputs/http\"function reportConfigError( log )    report( log, \"configError\" )endfunction reportNetworkError( log )    report( log, \"networkError\" )endfunction reportLog( log )\treport( log, \"clientLog\" )endfunction reportError( log )\treport( log, \"clientError\" )endfunction report( log, sourceType )\tlocal handler = function( isSucceed, body, header, status, errorBuffer )    end\tlocal httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )    httpRequest:addHeader( Constants.CONTENT_TYPE_PLAINTEXT )    httpRequest:setUserpwd( \"samyu:\"..ACCOUNT_ID )    httpRequest:getRequest():setRequestData( log, string.len( log ) )    local url = SPLUNK_LOG_IP    url = url..\"?index=\"..PROJECT_ID    url = url..\"&sourcetype=\"..sourceType    httpRequest:sendHttpRequest( url, handler )end","scripts.views.LeaderboardMainScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local Navigator = require(\"scripts.views.Navigator\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal TeamConfig = require(\"scripts.config.Team\")local LeaderboardConfig = require(\"scripts.config.Leaderboard\")local SUB_CONTENT_HEIGHT = 187local mWidget-- DS for couponHistory see CouponHistoryDatafunction loadFrame( couponHistory )\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/LeaderboardScene.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget( widget )    Navigator.loadFrame( widget )    initContent( couponHistory )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction isFrameShown()    return mWidget ~= nilendfunction initContent( couponHistory )\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )    contentContainer:removeAllChildrenWithCleanup( true )    local layoutParameter = LinearLayoutParameter:create()    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)    local contentHeight = 0    for i = 1, table.getn( LeaderboardConfig.LeaderboardType ) do    \tlocal eventHandler = function( sender, eventType )            if eventType == TOUCH_EVENT_ENDED then                contentClick( i )            end        end        local content = SceneManager.widgetFromJsonFile(\"scenes/LeaderboardContent.json\")        content:setLayoutParameter( layoutParameter )        contentContainer:addChild( content )        contentHeight = contentHeight + content:getSize().height        local bt = content:getChildByName(\"button\")        bt:addTouchEventListener( eventHandler )        initLeaderboardContent( content, LeaderboardConfig.LeaderboardType[i] )        -- Add sub        local subContent = SceneManager.widgetFromJsonFile(\"scenes/LeaderboardSubContent.json\")        subContent:setLayoutParameter( layoutParameter )        contentContainer:addChild( subContent )        subContent:setName( \"subContent\"..i )        for j = 1, 4 do            local eventHandler = function( sender, eventType )                if eventType == TOUCH_EVENT_ENDED then                    subContentClick( i, j )                end            end            local button = subContent:getChildByName(\"button\"..j)            button:addTouchEventListener( eventHandler )        end    end    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )    local layout = tolua.cast( contentContainer, \"Layout\" )    layout:requestDoLayout()endfunction initLeaderboardContent( content, info )    local name = tolua.cast( content:getChildByName(\"name\"), \"Label\" )    local logo = tolua.cast( content:getChildByName(\"logo\"), \"ImageView\" )    name:setText( info[\"displayName\"] )    logo:loadTexture( info[\"logo\"] )endfunction contentClick( id )    local contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )    local subContent = contentContainer:getChildByName( \"subContent\"..id )    local originSize = subContent:getSize()    if originSize.height > 0 then        subContent:setSize( CCSize:new( originSize.width, 0 ) )        contentContainer:setInnerContainerSize( CCSize:new( 0, contentContainer:getInnerContainerSize().height - SUB_CONTENT_HEIGHT ) )    else        subContent:setSize( CCSize:new( originSize.width, SUB_CONTENT_HEIGHT ) )        contentContainer:setInnerContainerSize( CCSize:new( 0, contentContainer:getInnerContainerSize().height + SUB_CONTENT_HEIGHT ) )    end        local layout = tolua.cast( contentContainer, \"Layout\" )    layout:requestDoLayout()endfunction subContentClick( id, subId )    EventManager:postEvent( Event.Enter_Leaderboard_List, { id, subId } )end","scripts.config.League":"module(..., package.seeall)local JsonConfigReader = require(\"scripts.config.JsonConfigReader\")local DoLogReport = require(\"scripts.actions.DoLogReport\")local FILE_NAME = \"config/leagues.txt\"local mConfig = {}local mIndex = {}local mConfigNum = 0function init()\tif mConfigNum > 0 then \t\treturn\tend\tprint(\"Read League config.\")\tlocal filter = function( v )\t\treturn v[\"isActive\"]\tend\tmConfig, mConfigNum = JsonConfigReader.read( FILE_NAME, \"Id\", filter )\tprint( \"Read active league number: \"..mConfigNum )endfunction getConfig( id )\tassert( mConfig[id] ~= nil, FILE_NAME..\" dosen't has \"..id )\treturn mConfig[id]endfunction getConfigIdByKey( key )\tif mIndex[key] == nil then\t\tlocal log = FILE_NAME..\" dosen't has \"..key\t\tprint( log )\t\tDoLogReport.reportConfigError( log )\t\treturn nil\tend\treturn mIndex[key]endfunction getConfigNum()\treturn mConfigNumend--[[\tProvide additional getters.--]]function getConfigId( id )\tlocal config = getConfig( id )\treturn config[\"Id\"]endfunction getCountryId( id )\tlocal config = getConfig( id )\treturn config[\"countryId\"]endfunction getLogo( id )\tlocal config = getConfig( id )\treturn config[\"Id\"]..\".png\"endfunction getLeagueName( id )\tlocal config = getConfig( id )\treturn config[\"leagueName\"]endfunction getThumbUrl( id )\tlocal config = getConfig( id )\treturn config[\"thumbUrl\"]endfunction isActive( id )\tlocal config = getConfig( id )\treturn config[\"isActive\"]endinit()","scripts.views.ForgotPasswordScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ViewUtils = require(\"scripts.views.ViewUtils\")local EMAIL_CONTAINER_NAME = \"emailContainer\"local mWidgetfunction loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/ForgotPassword.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget(widget)    local okBt = widget:getChildByName(\"OK\")    local cancelBt = widget:getChildByName(\"cancel\")    okBt:addTouchEventListener( okEventHandler )    cancelBt:addTouchEventListener( cancelEventHandler )    local emailInput = ViewUtils.createTextInput( mWidget:getChildByName( EMAIL_CONTAINER_NAME ), \"E-mail address\" )    emailInput:setFontColor( ccc3( 0, 0, 0 ) )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction okEventHandler( sender,eventType )    if eventType == TOUCH_EVENT_ENDED then        local email = mWidget:getChildByName( EMAIL_CONTAINER_NAME ):getNodeByTag( 1 ):getText()        EventManager:postEvent( Event.Enter_Login )    endendfunction cancelEventHandler( sender,eventType )\tif eventType == TOUCH_EVENT_ENDED then        EventManager:postEvent( Event.Enter_Login )    endend","scripts.actions.EnterLoginNRegAction":"module(..., package.seeall)function action( param )\tlocal loginNRegScene = require(\"scripts.views.LoginNRegScene\")    loginNRegScene.loadFrame()end","scripts.actions.EnterMatchAction":"module(..., package.seeall)local Json = require(\"json\")local ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local Logic = require(\"scripts.Logic\").getInstance()local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal RequestUtils = require(\"scripts.RequestUtils\")function action( param )    local matchId = Logic:getSelectedMatch()[\"Id\"]    local url = RequestUtils.GET_GAME_MARKETS_REST_CALL..\"?gameId=\"..matchId    local requestInfo = {}    requestInfo.requestData = \"\"    requestInfo.url = url    local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )    httpRequest:addHeader( Logic:getAuthSessionString() )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()--[[    local JsonConfigReader = require(\"scripts.config.JsonConfigReader\")    local config = JsonConfigReader.read( \"config/market.json\" )    local match = { Id = 4077,                HomeTeamId = 2744,                AwayTeamId = 2942,                StartTime = 1398311338 }    Logic:setSelectedMatch( match )    onRequestSuccess( config )--]]endfunction onRequestSuccess( response )    local MarketsForGameData = require(\"scripts.data.MarketsForGameData\").MarketsForGameData        local marketInfo = MarketsForGameData:new( response )    Logic:setCurMarketInfo( marketInfo )        if marketInfo:getMatchMarket() ~= nil then        local matchPredictionScene = require(\"scripts.views.MatchPredictionScene\")        matchPredictionScene.loadFrame( marketInfo:getMatchMarket() )    elseif marketInfo:getNum() > 0 then        EventManager:postEvent( Event.Enter_Next_Prediction )    else        RequestUtils.onRequestFailed( \"You have completed this match.\" )    endend","scripts.RequestUtils":"module(..., package.seeall)local Json = require(\"json\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local DoLogReport = require(\"scripts.actions.DoLogReport\")HTTP_200 = 200HTTP_204 = 204SERVER_IP = \"http://fhapi-prod1.cloudapp.net\"FACEBOOK_GRAPH_IP = \"https://graph.facebook.com\"CDN_SERVER_IP = \"http://portalvhdss3c1vgx5mrzv.blob.core.windows.net/fhsettings/\"EMAIL_REGISTER_REST_CALL = SERVER_IP..\"/api/user/SignupWithEmail\"EMAIL_LOGIN_REST_CALL = SERVER_IP..\"/api/loginWithEmail\"SET_USER_METADATA_REST_CALL = SERVER_IP..\"/api/user/setUserMetaData\"FB_LOGIN_REST_CALL = SERVER_IP..\"/api/user/SignupWithFacebook\"FB_CONNECT_REST_CALL = SERVER_IP..\"/api/user/connectUserWithFacebook\"GET_ALL_UPCOMING_GAMES_REST_CALL = SERVER_IP..\"/api/games/allUpcoming\"GET_UPCOMING_GAMES_BY_LEAGUE_REST_CALL = SERVER_IP..\"/api/games/upcomingByLeague\"GET_GAME_MARKETS_REST_CALL = SERVER_IP..\"/api/markets/getMarketsForGame\"GET_COUPON_HISTORY_REST_CALL = SERVER_IP..\"/api/couponHistory/getUserCouponHistory\"GET_MAIN_LEADERBOARD_REST_CALL = SERVER_IP..\"/api/leaderboards/getMainLeaderboard\"GET_FRIENDS_LEADERBOARD_REST_CALL = SERVER_IP..\"/api/leaderboards/getFriendsLeaderboard\"POST_COUPONS_REST_CALL = SERVER_IP..\"/api/coupons/placeCoupons\"POST_FAV_TEAM_REST_CALL = SERVER_IP..\"/api/user/setFavoriteTeam\"FACEBOOK_FRIENDS_LIST_CALL = \"/me/friends?access_token=\"USE_DEV = falsefunction setServerIP( serverIp )    EMAIL_REGISTER_REST_CALL = serverIp..\"/api/user/SignupWithEmail\"    EMAIL_LOGIN_REST_CALL = serverIp..\"/api/loginWithEmail\"    SET_USER_METADATA_REST_CALL = serverIp..\"/api/user/setUserMetaData\"    FB_LOGIN_REST_CALL = serverIp..\"/api/user/SignupWithFacebook\"    FB_CONNECT_REST_CALL = serverIp..\"/api/user/connectUserWithFacebook\"    GET_ALL_UPCOMING_GAMES_REST_CALL = serverIp..\"/api/games/allUpcoming\"    GET_UPCOMING_GAMES_BY_LEAGUE_REST_CALL = serverIp..\"/api/games/upcomingByLeague\"    GET_GAME_MARKETS_REST_CALL = serverIp..\"/api/markets/getMarketsForGame\"    GET_COUPON_HISTORY_REST_CALL = serverIp..\"/api/couponHistory/getUserCouponHistory\"    GET_MAIN_LEADERBOARD_REST_CALL = serverIp..\"/api/leaderboards/getMainLeaderboard\"    GET_FRIENDS_LEADERBOARD_REST_CALL = serverIp..\"/api/leaderboards/getFriendsLeaderboard\"    POST_COUPONS_REST_CALL = serverIp..\"/api/coupons/placeCoupons\"    POST_FAV_TEAM_REST_CALL= serverIp..\"/api/user/setFavoriteTeam\"    CDN_SERVER_IP = \"http://portalvhdss3c1vgx5mrzv.blob.core.windows.net/fhdevsettings/\"    USE_DEV = trueendfunction createHeaderObject( headerStr )\tlocal headerList = split( headerStr, \"\\n\" )    local headers = {}    for k, v in pairs( headerList ) do        local headerObj = split( v, \": \" )        if table.getn( headerObj ) >= 2 then        \theaders[headerObj[1]] = headerObj[2]        end    end    return headersendfunction split(str, delim, maxNb)       -- Eliminate bad cases...       if string.find(str, delim) == nil then          return { str }      end      if maxNb == nil or maxNb < 1 then          maxNb = 0    -- No limit       end      local result = {}      local pat = \"(.-)\" .. delim .. \"()\"       local nb = 0      local lastPos       for part, pos in string.gfind(str, pat) do          nb = nb + 1          result[nb] = part           lastPos = pos           if nb == maxNb then break end      end      -- Handle the last field       if nb ~= maxNb then          result[nb + 1] = string.sub(str, lastPos)       end      return result   end function messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, successRequestID, successHandler, failedHandler )    print( \"Http reponse: \"..status..\" and errorBuffer: \"..errorBuffer )    print( \"Http reponse body: \"..body )        local jsonResponse = {}    if string.len( body ) > 0 then        jsonResponse = Json.decode( body )    else        jsonResponse[\"Message\"] = errorBuffer    end    ConnectingMessage.selfRemove()    if status == successRequestID then        if successHandler ~= nil then            successHandler( jsonResponse )        end    else        reportRequestFailed( requestInfo, jsonResponse[\"Message\"] )        if failedHandler ~= nil then            failedHandler( jsonResponse )        else            onRequestFailed( jsonResponse[\"Message\"] )        end    endendfunction reportRequestFailed( requestInfo, errorBuffer )    if errorBuffer == \"An error has occurred.\" then        local unknowErrorPostText = \"Get \"..errorBuffer..\" with request: \"..Json.encode( requestInfo )        print( unknowErrorPostText )        DoLogReport.reportNetworkError( unknowErrorPostText )    endendfunction onRequestFailed( errorBuffer )    EventManager:postEvent( Event.Show_Error_Message, { errorBuffer } )end","scripts.views.LoginScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ViewUtils = require(\"scripts.views.ViewUtils\")local Logic = require(\"scripts.Logic\")local EMAIL_CONTAINER_NAME = \"emailContainer\"local PASSWORD_CONTAINER_NAME = \"passwordContainer\"local mWidgetlocal inputWidth = 400local inputHeight = 50function loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/Signin.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget(widget)    local signinBt = widget:getChildByName(\"signin\")    local backBt = widget:getChildByName(\"back\")    local forgotPasswordBt = widget:getChildByName(\"forgotPassword\")    signinBt:addTouchEventListener( signinEventHandler )    backBt:addTouchEventListener( backEventHandler )    forgotPasswordBt:addTouchEventListener( forgotPasswordEventHandler )    local emailInput = ViewUtils.createTextInput( mWidget:getChildByName( EMAIL_CONTAINER_NAME ), \"E-mail address\" )    emailInput:setFontColor( ccc3( 0, 0, 0 ) )    local passwordInput = ViewUtils.createTextInput( mWidget:getChildByName( PASSWORD_CONTAINER_NAME ), \"Password\" )    passwordInput:setInputFlag( kEditBoxInputFlagPassword )    passwordInput:setFontColor( ccc3( 0, 0, 0 ) )    emailInput:setText( Logic.getInstance():getEmail() )    passwordInput:setText( Logic.getInstance():getPassword() )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction backEventHandler( sender,eventType )    if eventType == TOUCH_EVENT_ENDED then        --EventManager:postEvent( Event.Enter_Login_N_Reg )        EventManager:popHistory()    endendfunction signinEventHandler( sender,eventType )\tif eventType == TOUCH_EVENT_ENDED then        local email = mWidget:getChildByName( EMAIL_CONTAINER_NAME ):getNodeByTag( 1 ):getText()        local pass = mWidget:getChildByName( PASSWORD_CONTAINER_NAME ):getNodeByTag( 1 ):getText()        EventManager:postEvent( Event.Do_Login, { email, pass } )    endendfunction forgotPasswordEventHandler( sender, eventType )    if eventType == TOUCH_EVENT_ENDED then        EventManager:postEvent( Event.Enter_Forgot_Password )    endend","scripts.Constants":"module(..., package.seeall)CONTENT_TYPE_JSON = \"Content-Type: application/json\"CONTENT_TYPE_PLAINTEXT = \"Content-Type: text/plain\"IMAGE_PATH = \"images/\"TEAM_IMAGE_PATH = IMAGE_PATH..\"teams/\"LEAGUE_IMAGE_PATH = IMAGE_PATH..\"leagues/\"COUNTRY_IMAGE_PATH = IMAGE_PATH..\"countries/\"PREDICTION_CHOICE_IMAGE_PATH = \"scenes/MatchPrediction/\"LEADERBOARD_IMAGE_PATH = \"scenes/Leaderboards/\"DRAW = 0TEAM1_WIN = 1TEAM2_WIN = 2YES = 1NO = 2FONT_1 = \"fonts/Newgtbxc.ttf\"STAKE = 1000","scripts.actions.EnterForgotPasswordAction":"module(..., package.seeall)function action( param )\tlocal forgotPasswordScene = require(\"scripts.views.ForgotPasswordScene\")    forgotPasswordScene.loadFrame()end","scripts.config.Settings":"module(..., package.seeall)local Event = require(\"scripts.events.Event\").EventListSettingsItem = {\t{ [\"itemName\"] = \"Send feedback\", [\"event\"] = Event.Do_Send_Feedback, },\t{ [\"itemName\"] = \"Profile\", [\"event\"] = Event.Do_Send_Feedback, },\t{ [\"itemName\"] = \"Logout\", [\"event\"] = Event.Do_Send_Feedback, },\t{ [\"itemName\"] = \"FAQ\", [\"event\"] = Event.Enter_FAQ, },\t{ [\"itemName\"] = \"Send review\", [\"event\"] = Event.Do_Send_Feedback, },\t{ [\"itemName\"] = \"About\", [\"event\"] = Event.Do_Send_Feedback, },}","scripts.views.ViewUtils":"module(..., package.seeall)local inputWidth = 400local inputHeight = 50local FONT_NAME = \"Newgtbxc\"local FONT_SIZE = 30function createTextInput( container, placeholderText )    local textInput = CCEditBox:create( CCSizeMake( inputWidth, inputHeight ), CCScale9Sprite:create() )    container:addNode( textInput, 0, 1 )    textInput:setPosition( inputWidth / 2, inputHeight / 2 )    textInput:setFont(FONT_NAME, FONT_SIZE)    textInput:setPlaceHolder( placeholderText )    return textInputend","scripts.actions.DoFBConnectWithUserAction":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local Json = require(\"json\")local RequestUtils = require(\"scripts.RequestUtils\")local Logic = require(\"scripts.Logic\").getInstance()local mSuccessHandlerlocal mFailedHandlerfunction action( param )    mSuccessHandler = param[1]    mFailedHandler = param[2]\tlocal Json = require(\"json\")\tlocal RequestUtils = require(\"scripts.RequestUtils\")    local successHandler = function( accessToken )        if accessToken == nil then            -- To handle user reject to the oAuth.            onFBConnectFailed()        else            print(\"Get token \"..accessToken)            onFBConnectSuccess( accessToken )        end    end    FacebookDelegate:sharedDelegate():login( successHandler, successHandler )endfunction onFBConnectFailed()    mFailedHandler( true )endfunction onFBConnectSuccess( accessToken )    local requestContent = { SocialNetworkType = 0, AuthToken = accessToken, useDev = RequestUtils.USE_DEV }    local requestContentText = Json.encode( requestContent )        local url = RequestUtils.FB_CONNECT_REST_CALL        local requestInfo = {}    requestInfo.requestData = requestContentText    requestInfo.url = url    local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess, onRequestFailed )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )    httpRequest:addHeader( Logic:getAuthSessionString() )    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( jsonResponse )    Logic:setFbId( \"\" )    mSuccessHandler()endfunction onRequestFailed( jsonResponse )    local errorBuffer = jsonResponse[\"Message\"]    mFailedHandler( false )    EventManager:postEvent( Event.Show_Error_Message, { errorBuffer } )end","scripts.views.ConnectingMessage":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local SceneManager = require(\"scripts.SceneManager\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal mWidgetlocal mWaitingArmaturefunction loadFrame( message )    if mWidget == nil then        local widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/ConnectingMessage.json\")        widget:addTouchEventListener( onFrameTouch )        mWidget = widget        mWidget:registerScriptHandler( EnterOrExit )        SceneManager.addWidget( widget )        CCArmatureDataManager:sharedArmatureDataManager():addArmatureFileInfo(\"anims/waiting0.png\",\"anims/waiting0.plist\",\"anims/waiting.ExportJson\")        mWaitingArmature = CCArmature:create(\"waiting\")        mWaitingArmature:setPosition( ccp( 50, 50 ) )        mWaitingArmature:getAnimation():playWithIndex(0)        mWidget:getChildByName(\"animContainer\"):addNode( mWaitingArmature )    end    setMessage( message )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil        mWaitingArmature:getAnimation():stop()        mWaitingArmature = nil    endendfunction setMessage( message )    message = message or \"Connecting...\"    print( \"Load connecting message scene:\"..message )    local messageLabel = tolua.cast( mWidget:getChildByName(\"connectMessage\"), \"Label\" )    messageLabel:setText( message )endfunction selfRemove()    SceneManager.removeWidget( mWidget )endfunction onFrameTouch( sender, eventType )    -- Do nothing, just block touch event.end","scripts.views.LoginNRegScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal mWidgetfunction loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/LoginNReg.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget(widget)    local signinBt = widget:getChildByName(\"signin\")    local registerBt = widget:getChildByName(\"register\")    local facebookBt = widget:getChildByName(\"facebookConnect\")    local dev = widget:getChildByName(\"dev\")    signinBt:addTouchEventListener( signinEventHandler )    registerBt:addTouchEventListener( registerEventHandler )    facebookBt:addTouchEventListener( facebookEventHandler )    dev:addTouchEventListener( devEventHandler )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction signinEventHandler( sender,eventType )\tif eventType == TOUCH_EVENT_ENDED then        EventManager:postEvent( Event.Enter_Login )    endendfunction registerEventHandler( sender,eventType )\tif eventType == TOUCH_EVENT_ENDED then        EventManager:postEvent( Event.Enter_Register )    endendfunction facebookEventHandler( sender,eventType )    if eventType == TOUCH_EVENT_ENDED then        EventManager:postEvent( Event.Do_FB_Connect )     endendfunction devEventHandler( sender,eventType )    if eventType == TOUCH_EVENT_ENDED then         local RequestUtils = require(\"scripts.RequestUtils\")         RequestUtils.setServerIP(\"http://fhapi-dev1.cloudapp.net\")    endend","scripts.data.Coupons":"module(..., package.seeall)local Json = require(\"json\")Coupons = {}--[[Data need to be sent to server:{  \"CouponForms\":  [    {      \"OutcomeIds\" : [2435033],      \"Stake\" : 1000,    }  ],  \"Message\" : \"My first bet\",  \"ShareOnFacebook\" : false  }Whole Data :{  \"CouponForms\":  [    {      \"OutcomeIds\" : [2435033],      \"Stake\" : 1000,      \"Answer\" : \"Arsenal to win.\",       \"Reward\": 4000,       \"AnswerIcon\": \"XXXX.png\"    }  ],  \"Message\" : \"My first bet\",  \"ShareOnFacebook\" : false}--]]function Coupons:new()\tlocal obj = {\t\tCouponForms = {},    Message = \"\",    ShareOnFacebook = false\t}\tsetmetatable(obj, self)    self.__index = self        obj.__newindex = function(t, k, v) assert(false, \"Coupons--\"..k .. \"__newindex not exist\") end        return obj endfunction Coupons:addCoupon( id, answer, reward, answerIcon )    local idList = {}    table.insert( idList, id )    local coupon = {        OutcomeIds = idList,        Stake = 1000,        Answer = answer,        Reward = reward,        AnswerIcon = answerIcon    }    table.insert( self.CouponForms, coupon )endfunction Coupons:getSize()    return table.getn( self.CouponForms )endfunction Coupons:get( index )    return self.CouponForms[index]endfunction Coupons:setMessage( message )    self.Message = messageendfunction Coupons:setShareOnFacebook( share )    self.ShareOnFacebook = shareendfunction Coupons:toString()    local form = {}    for i, v in ipairs( self.CouponForms ) do        local coupon = {            OutcomeIds = v[\"OutcomeIds\"],            Stake = v[\"Stake\"],        }        table.insert( form, coupon )    end    return string.format( \"{\\\"CouponForms\\\":%s, \\\"Message\\\":\\\"%s\\\", \\\"ShareOnFacebook\\\":%s}\", Json.encode( form ), self.Message, self.ShareOnFacebook )end","scripts.actions.DoPostFavTeamAction":"module(..., package.seeall)local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local Logic = require(\"scripts.Logic\").getInstance()local mStartLeaguefunction action( param )\tlocal Json = require(\"json\")\tlocal RequestUtils = require(\"scripts.RequestUtils\")    local favTeamID = param[1]    mStartLeague = param[2]    local requestContent = { TeamId = favTeamID, LeagueId = mStartLeague }    local requestContentText = Json.encode( requestContent )        local url = RequestUtils.POST_FAV_TEAM_REST_CALL    local requestInfo = {}    requestInfo.requestData = requestContentText    requestInfo.url = url    local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )    httpRequest:addHeader( \"Content-Type: application/json\" )    httpRequest:addHeader( Logic:getAuthSessionString() )    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( jsonResponse )    Logic:setStartLeagueId( mStartLeague )    EventManager:postEvent( Event.Enter_Match_List )end","scripts.events.Event":"module(..., package.seeall)function CreatEnumTable( tbl, index )     assert( type( tbl ) == \"table\" )     local enumtbl = {}     local enumindex = index or 0     for i, v in ipairs( tbl ) do         enumtbl[v] = enumindex + i     end     return enumtbl end function GetEventNameById( id )\treturn EventNameList[id]endEventNameList = {     \"Check_File_Version\",    \"Enter_Login_N_Reg\",    \"Enter_Register\",    \"Enter_Register_Name\",    \"Enter_Login\",    \"Enter_Forgot_Password\",    \"Enter_Match_List\",    \"Enter_Match\",    \"Enter_Prediction_Confirm\",    \"Enter_Pred_Total_Confirm\",    \"Enter_Sel_Fav_Team\",    \"Enter_Next_Prediction\",    \"Enter_History\",    \"Enter_History_Detail\",    \"Enter_Leaderboard\",    \"Enter_Leaderboard_List\",    \"Enter_Settings\",    \"Enter_FAQ\",    \"Do_Register\",    \"Do_Register_Name\",    \"Do_Login\",    \"Do_FB_Connect\",    \"Do_FB_Connect_With_User\",    \"Do_Post_Predictions\",    \"Do_Post_Fav_Team\",    \"Do_Send_Feedback\",    \"Show_Error_Message\",    \"Load_More_In_Leaderboard\",    \"Load_More_In_History\",}EventNameDosenotTrackList = {     \"Do_Register\",    \"Do_Register_Name\",    \"Do_Login\",    \"Do_FB_Connect\",    \"Do_Post_Predictions\",    \"Do_Post_Fav_Team\",    \"Do_Send_Feedback\",    \"Check_File_Version\",    \"Show_Error_Message\",    \"Load_More_In_Leaderboard\",    \"Load_More_In_History\",}EventList = CreatEnumTable( EventNameList )EventDosenotTrackList = CreatEnumTable( EventNameDosenotTrackList )","scripts.views.ErrorMessage":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local SceneManager = require(\"scripts.SceneManager\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal mWidgetlocal mRetryCallfunction loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/ErrorMessage.json\")    local okBt = widget:getChildByName(\"ok\")    okBt:addTouchEventListener( okEventHandler )    widget:addTouchEventListener( onFrameTouch )    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.addWidget( widget )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction setErrorMessage( message, retryCall )    local errorMessage = tolua.cast( mWidget:getChildByName(\"errorMessage\"), \"Label\" )    errorMessage:setText( message )    mRetryCall = retryCallendfunction okEventHandler( sender, eventType )    if eventType == TOUCH_EVENT_ENDED then        SceneManager.removeWidget( mWidget )        if mRetryCall ~= nil then            mRetryCall()            mRetryCall = nil        end    endendfunction onFrameTouch( sender, eventType )    -- Do nothing, just block touch event.end","scripts.actions.EnterPredictionConfirmAction":"module(..., package.seeall)function action( param )\tlocal prediction, teamName, reward, answerIcon = param[1], param[2], param[3], param[4]\tlocal predConfirmScene = require(\"scripts.views.PredConfirmScene\")    predConfirmScene.loadFrame( prediction, teamName, reward, answerIcon )end","scripts.actions.DoRegisterNameAction":"module(..., package.seeall)local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local Logic = require(\"scripts.Logic\").getInstance()local mUserName = \"SamYu\"local mFirstName = \"Yu\"local mLastName = \"Zheng\"function action( param )\tlocal Json = require(\"json\")\tlocal RequestUtils = require(\"scripts.RequestUtils\")    mUserName, mFirstName, mLastName = param[1], param[2], param[3]    if string.len( mUserName ) == 0 then        RequestUtils.onRequestFailed( \"User name is blank.\" )        return    end    if mFirstName == nil then        mFirstName = \"\"    end    if mLastName == nil then        mLastName = \"\"    end    local requestContent = { DisplayName = mUserName, FirstName = mFirstName, LastName = mLastName, DoB = \"\" }    local requestContentText = Json.encode( requestContent )        local url = RequestUtils.SET_USER_METADATA_REST_CALL    local requestInfo = {}    requestInfo.requestData = requestContentText    requestInfo.url = url    local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )    httpRequest:addHeader( \"Content-Type: application/json\" )    httpRequest:addHeader( Logic:getAuthSessionString() )    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( jsonResponse )    EventManager:postEvent( Event.Enter_Sel_Fav_Team )end","scripts.views.PredConfirmScene":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local SceneManager = require(\"scripts.SceneManager\")local Logic = require(\"scripts.Logic\").getInstance()local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal mAnswerlocal mRewardlocal mOddIdlocal mAnswerIconlocal mWidgetlocal mTextInputfunction loadFrame( answer, reward, oddId, answerIcon )\tprint(answerIcon)\tmAnswer = answer\tmReward = reward\tmOddId = oddId\tmAnswerIcon = answerIcon\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/PredConfirm.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    mWidget:addTouchEventListener( bgEventHandler )    SceneManager.addWidget(widget)\tinitContent()        createTextInput()    local confirmBt = widget:getChildByName(\"confirm\")    confirmBt:addTouchEventListener( confirmEventHandler )    local cancelBt = widget:getChildByName(\"cancel\")    cancelBt:addTouchEventListener( cancelEventHandler )    local textDisplay = mWidget:getChildByName(\"Text\")\ttextDisplay:addTouchEventListener( inputEventHandler )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil        mTextInput = nil    endendfunction confirmEventHandler( sender, eventType )\tif eventType == TOUCH_EVENT_ENDED then\t\tlocal textDisplay = tolua.cast( mWidget:getChildByName(\"Text\"), \"Label\" )\t\tlocal comment = textDisplay:getStringValue()\t\tSceneManager.clear()\t\tLogic:addPrediction( mOddId, mAnswer, mReward, mAnswerIcon )\t    EventManager:postEvent( Event.Enter_Next_Prediction )\tendendfunction cancelEventHandler( sender, eventType )\tif eventType == TOUCH_EVENT_ENDED then\t\tSceneManager.removeWidget( mWidget )\tendendfunction bgEventHandler( sender, eventType )\t-- Do nothing, just blockendfunction inputEventHandler( sender, eventType )\tif eventType == TOUCH_EVENT_ENDED then\t\tmTextInput:touchDownAction( sender, eventType )\tendendfunction createTextInput()\tlocal container = mWidget:getChildByName(\"TextInput\")\tlocal inputDelegate = EditBoxDelegateForLua:create()\tinputDelegate:registerEventScriptHandler( EDIT_BOX_EVENT_TEXT_CHANGED, function ( textBox, text )\t\tlocal textDisplay = tolua.cast( mWidget:getChildByName(\"Text\"), \"Label\" )\t\ttextDisplay:setText( text )\tend )\tcontainer:addNode( tolua.cast( inputDelegate, \"CCNode\" ) )\tmTextInput = CCEditBox:create( CCSizeMake( 550, 35 ), CCScale9Sprite:create() )    container:addNode( mTextInput )    mTextInput:setPosition( 550 / 2, 35 / 2 )    mTextInput:setFontColor( ccc3( 0, 0, 0 ) )    mTextInput:setVisible( false )    mTextInput:setDelegate( inputDelegate.__CCEditBoxDelegate__ )    mTextInput:setTouchPriority( SceneManager.TOUCH_PRIORITY_MINUS_ONE )endfunction initContent()\tlocal question = tolua.cast( mWidget:getChildByName(\"Question\"), \"Label\" )\tlocal reward = tolua.cast( mWidget:getChildByName(\"Reward\"), \"Label\" )\tlocal answerIcon = tolua.cast( mWidget:getChildByName(\"answerIcon\"), \"ImageView\" )\tquestion:setFontName( \"Newgtbxc\" )\treward:setFontName( \"Newgtbxc\" )\tquestion:setText( mAnswer )\treward:setText( string.format( reward:getStringValue(), mReward ) )\tanswerIcon:loadTexture( mAnswerIcon )end","scripts.config.JsonConfigReader":"module(..., package.seeall)local Json = require(\"json\")local FileUtils = require(\"scripts.FileUtils\")function read( fileName, primaryKey, filter )\tfilter = filter or passAll\tif primaryKey == nil then\t\treturn readWithoutPrimaryKey( fileName, filter )\telse\t\treturn readWithPrimaryKey( fileName, primaryKey, filter )\tendendfunction readWithPrimaryKey( fileName, primaryKey, filter )\tlocal startTime = os.time()\tlocal config = {}\tlocal index = {}\tlocal configNum = 0\t-- Check if there is a local version\tlocal text = FileUtils.readStringFromFile( fileName )\tprint( \"Read file \"..fileName..\" took \"..( os.time() - startTime ) )\tstartTime = os.time()\t--print( text )\tlocal jsonObject = Json.decode( text )\tfor i, v in pairs( jsonObject ) do\t\tif filter( v ) then\t\t    table.insert( config, v )\t    \tconfigNum = configNum + 1\t    \tlocal id = v[primaryKey]\t\t    index[id] = configNum\t\tend\tend\tprint( \"Parse file \"..fileName..\" took \"..( os.time() - startTime ) )\treturn config, configNum, indexendfunction readWithoutPrimaryKey( fileName, filter )\tlocal config = {}\tlocal configNum = 0\tlocal text = FileUtils.readStringFromFile( fileName )\t--print( text )\tlocal jsonObject = Json.decode( text )\tfor i, v in pairs( jsonObject ) do\t\tif filter( v ) then\t\t\ttable.insert( config, v )\t    \tconfigNum = configNum + 1\t\tend\tend\treturn config, configNumendfunction passAll( v )\treturn trueendfunction readAndCombine( fileName, primaryKey )\tlocal config = {}\tlocal text = FileUtils.readStringFromFile( fileName )\t--print( text )\tlocal jsonObject = Json.decode( text )\tfor i, v in pairs( jsonObject ) do\t\tlocal id = v[primaryKey]\t\tif config[id] == nil then\t\t\tconfig[id] = {}\t\tend\t\ttable.insert( config[id], v )\tend\treturn configend","scripts.config.Market":"module(..., package.seeall)MARKET_TYPE_MATCH = 1MARKET_TYPE_TOTAL_GOAL = 2MARKET_TYPE_ASIAN_HANDICAP = 3ODDS_TYPE_ONE_OPTION = 1ODDS_TYPE_TWO_OPTION = 2","scripts.views.LeagueListScene":"module(..., package.seeall)local CountryConfig = require(\"scripts.config.Country\")local LeagueConfig = require(\"scripts.config.League\")local SceneManager = require(\"scripts.SceneManager\")local mCountryNum = CountryConfig.getConfigNum()local mCountryExpended = {}local COUNTRY_CONTENT_HEIGHT = 140local LEAGUE_CONTENT_HEIGHT = 60local mCountryWidgetlocal mLeagueWidgetlocal mLeagueListContainerlocal mLeagueSelectCallbackfunction loadFrame( countryWidget, leagueWidget, leagueListContainer, leagueSelectCallback )\tmCountryWidget = countryWidget\tmLeagueWidget = leagueWidget\tmLeagueListContainer = leagueListContainer\tmLeagueSelectCallback = leagueSelectCallback    local content = SceneManager.widgetFromJsonFile( mCountryWidget )    COUNTRY_CONTENT_HEIGHT = content:getSize().height    content = SceneManager.widgetFromJsonFile( mLeagueWidget )    LEAGUE_CONTENT_HEIGHT = content:getSize().height\thelperInitLeagueList()endfunction helperInitLeagueList()    local contentHeight = 0    for i = 1, mCountryNum do        mCountryExpended[i] = false        local eventHandler = function( sender, eventType )            if eventType == TOUCH_EVENT_ENDED then                -- Handler                if mCountryExpended[i] == true then                    mCountryExpended[i] = false                else                    mCountryExpended[i] = true                end                helperUpdateLeagueList( i )            end        end        local content = SceneManager.widgetFromJsonFile( mCountryWidget )        local countryName = tolua.cast( content:getChildByName(\"countryName\"), \"Label\" )        if countryName ~= nil then        \tcountryName:setText( CountryConfig.getCountryName( i ) )       \tend        content:addTouchEventListener( eventHandler )        content:setPosition( ccp( 0, ( i - 1 ) * COUNTRY_CONTENT_HEIGHT ) )        mLeagueListContainer:addChild( content )        content:setName( \"country\"..i )        local logo = tolua.cast( content:getChildByName(\"countryLogo\"), \"ImageView\" )        logo:loadTexture( CountryConfig.getLogo( i ) )        contentHeight = contentHeight + content:getSize().height        mLeagueListContainer:jumpToPercentVertical( 1 )    end    local scrollViewHeight = mLeagueListContainer:getSize().height    if contentHeight < scrollViewHeight then        local offset = scrollViewHeight - contentHeight        for i = 1, mCountryNum do            local countryLogo = mLeagueListContainer:getChildByName( \"country\"..i )            countryLogo:setPosition( ccp( countryLogo:getPositionX() , countryLogo:getPositionY() + offset ) )        end    else        mLeagueListContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )        end    local layout = tolua.cast( mLeagueListContainer, \"Layout\" )    layout:requestDoLayout()endfunction helperUpdateLeagueList( clickedCountryId )\tprint( \"helperUpdateLeagueList \"..clickedCountryId )    local leagueNum = table.getn( CountryConfig.getLeagueList( clickedCountryId ) )     -- Calculate the move offset    local moveOffsetX = 0    if mCountryExpended[clickedCountryId] == true then        moveOffsetX = leagueNum * LEAGUE_CONTENT_HEIGHT    else        moveOffsetX = leagueNum * (-LEAGUE_CONTENT_HEIGHT)    end    -- Move upper country and league logo's position        for i = clickedCountryId, mCountryNum do        local countryLogo = mLeagueListContainer:getChildByName( \"country\"..i )        countryLogo:setPosition( ccp( countryLogo:getPositionX() , countryLogo:getPositionY() + moveOffsetX ) )        local otherCountryLeagueNum = table.getn( CountryConfig.getLeagueList( i ) )         for j = 1, otherCountryLeagueNum do            local leagueLogo = mLeagueListContainer:getChildByName( \"country\"..i..\"_league\"..j )            if leagueLogo ~= nil then                leagueLogo:setPosition( ccp( leagueLogo:getPositionX() , leagueLogo:getPositionY() + moveOffsetX ) )            end        end    end    -- Add or remove league logos according to the status    if mCountryExpended[clickedCountryId] == true then        for i = 1, leagueNum do            local leagueId = CountryConfig.getLeagueList( clickedCountryId )[i]            local eventHandler = function( sender, eventType )                if eventType == TOUCH_EVENT_ENDED then                    mLeagueSelectCallback( leagueId )                end            end            local content = SceneManager.widgetFromJsonFile( mLeagueWidget )            local parent = mLeagueListContainer:getChildByName( \"country\"..clickedCountryId )            content:setPosition( ccp( 0, parent:getPositionY() - ( leagueNum - i + 1 ) * LEAGUE_CONTENT_HEIGHT ) )            mLeagueListContainer:addChild( content )            content:setName( \"country\"..clickedCountryId..\"_league\"..i )            content:addTouchEventListener( eventHandler )            local leagueName = tolua.cast( content:getChildByName(\"leagueName\"), \"Label\" )            leagueName:setText( LeagueConfig.getLeagueName( leagueId ) )        end    else        for i = 1, leagueNum do            local leagueLogo = mLeagueListContainer:getChildByName( \"country\"..clickedCountryId..\"_league\"..i )            mLeagueListContainer:removeChild( leagueLogo )        end    end         -- Update the max container size.    local originHeight = mLeagueListContainer:getInnerContainerSize().height    mLeagueListContainer:setInnerContainerSize( CCSize:new( 0, originHeight + moveOffsetX ) )    local layout = tolua.cast( mLeagueListContainer, \"Layout\" )    layout:requestDoLayout()end","scripts.config.LeagueTeams":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local JsonConfigReader = require(\"scripts.config.JsonConfigReader\")local DoLogReport = require(\"scripts.actions.DoLogReport\")local FILE_NAME = \"config/leagueteams.txt\"local mConfig = {}function init()\tprint(\"Read LeagueTeam config.\")\tmConfig = JsonConfigReader.readAndCombine( FILE_NAME, \"leagueId\" )endfunction getConfig( id )\tif id == nil then\t\treturn nil\tend\tif mConfig[id] == nil then\t\tlocal log = FILE_NAME..\" dosen't has \"..id\t\tprint( log )\t\tDoLogReport.reportConfigError( log )\t\treturn nil\tend\treturn mConfig[id]end--[[\tProvide additional getters.--]]init()","scripts.actions.DoRegisterAction":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local Json = require(\"json\")local RequestUtils = require(\"scripts.RequestUtils\")local mEmail = \"test126@abc.com\"local mPassword = \"test126\"local mPasswordConf = \"test126\"function action( param )    mEmail, mPassword, mPasswordConf = param[1], param[2], param[3]    if string.len( mEmail ) == 0 then        RequestUtils.onRequestFailed( \"Email is blank.\" )        return    end    if mPassword ~= mPasswordConf then        RequestUtils.onRequestFailed( \"Two passwords are not the same.\" )        return    end    if string.len( mPassword ) < 6 then        RequestUtils.onRequestFailed( \"Password too short.\" )        return    end    if string.len( mPassword ) > 160 then        RequestUtils.onRequestFailed( \"Password too long.\" )        return    end    if string.find( mEmail, \"([-%a%d%._]+)@([-%a%d.]+)\" ) == nil then        RequestUtils.onRequestFailed( \"Bad email format.\" )        return    end    local requestContent = { Email = mEmail, Password = mPassword, useDev = RequestUtils.USE_DEV }    local requestContentText = Json.encode( requestContent )        local url = RequestUtils.EMAIL_REGISTER_REST_CALL    local requestInfo = {}    requestInfo.requestData = requestContentText    requestInfo.url = url    local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( jsonResponse )    local sessionToken = jsonResponse[\"SessionToken\"]    local userId = jsonResponse[\"Id\"]    local configMd5Info = jsonResponse[\"ConfigMd5Info\"]    local displayName = jsonResponse[\"DisplayName\"]    local pictureUrl = jsonResponse[\"PictureUrl\"]    local startLeagueId = jsonResponse[\"StartLeagueId\"]    local balance = jsonResponse[\"Balance\"]    local FbId = jsonResponse[\"FbId\"]    local Logic = require(\"scripts.Logic\").getInstance()    Logic:setUserInfo( mEmail, mPassword, sessionToken, userId )    Logic:setDisplayName( displayName )    Logic:setPictureUrl( pictureUrl )    Logic:setStartLeagueId( startLeagueId )    Logic:setBalance( balance )    Logic:setFbId( FbId )    EventManager:postEvent( Event.Check_File_Version, { configMd5Info, Event.Enter_Register_Name } )end","scripts.actions.EnterSelFavTeamAction":"module(..., package.seeall)local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal Logic = require(\"scripts.Logic\").getInstance()function action( param )\tif Logic:getStartLeagueId() == 0 then\t\tlocal selFavTeamScene = require(\"scripts.views.SelFavTeamScene\")    \tselFavTeamScene.loadFrame()\telse\t    EventManager:postEvent( Event.Enter_Match_List )\tendend","scripts.config.Team":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local JsonConfigReader = require(\"scripts.config.JsonConfigReader\")local DoLogReport = require(\"scripts.actions.DoLogReport\")local FILE_NAME = \"config/teams.txt\"local mConfig = {}local mIndex = {}local mConfigNum = 0function init()\tif mConfigNum > 0 then \t\treturn\tend\tprint(\"Read Team config.\")\tmConfig, mConfigNum, mIndex = JsonConfigReader.read( FILE_NAME, \"Id\" )endfunction getConfig( id )\tif id == nil then\t\treturn nil\tend\tassert( mConfig[id] ~= nil, FILE_NAME..\" dosen't has \"..id )\treturn mConfig[id]endfunction getConfigIdByKey( key )\tif key == nil then\t\treturn nil\tend\tif mIndex[key] == nil then\t\tlocal log = FILE_NAME..\" dosen't has \"..key\t\tprint( log )\t\tDoLogReport.reportConfigError( log )\tend\treturn mIndex[key]endfunction getConfigNum()\treturn mConfigNumend--[[\tProvide additional getters.--]]function getTeamId( id )\tlocal config = getConfig( id )\tif config ~= nil then\t\treturn config[\"Id\"]\telse\t\treturn 0\tendendfunction getTeamName( id )\tlocal config = getConfig( id )\tif config ~= nil then\t\treturn config[\"teamName\"]\telse\t\tif id ~= nil then\t\t\treturn \"Unknow team: \"..id\t\telse\t\t\treturn \"Unknow team\"\t\tend\tendendfunction getLogo( id )\tlocal config = getConfig( id )\tif config ~= nil then\t\tlocal fileUtils = CCFileUtils:sharedFileUtils()\t\tlocal filePath = fileUtils:fullPathForFilename( Constants.TEAM_IMAGE_PATH..config[\"Id\"]..\".png\" )\t\tif fileUtils:isFileExist( filePath ) then\t\t\treturn Constants.TEAM_IMAGE_PATH..config[\"Id\"]..\".png\"\t\telse\t\t\treturn Constants.TEAM_IMAGE_PATH..\"default.png\"\t\tend\telse\t\treturn Constants.TEAM_IMAGE_PATH..\"default.png\"\tendendfunction getThumbUrl( id )\tlocal config = getConfig( id )\tif config ~= nil then\t\treturn config[\"thumbUrl\"]\telse\t\treturn \"Unknown\"\tend\tendinit()","scripts.actions.EnterSettingsAction":"module(..., package.seeall)function action( param )\tlocal SettingsScene = require(\"scripts.views.SettingsScene\")\tif SettingsScene.isFrameShown() then\t\treturn\tend    SettingsScene.loadFrame()end","scripts.actions.LoadMoreInHistoryAction":"module(..., package.seeall)local Json = require(\"json\")local ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local Logic = require(\"scripts.Logic\").getInstance()local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal RequestUtils = require(\"scripts.RequestUtils\")function action( param )    local step = param[1]        local url = RequestUtils.GET_COUPON_HISTORY_REST_CALL..\"?userId=\"..Logic:getUserId()..\"&step=\"..step    local requestInfo = {}    requestInfo.requestData = \"\"    requestInfo.url = url    local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )    httpRequest:addHeader( Logic:getAuthSessionString() )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( response )    local CouponHistoryData = require(\"scripts.data.CouponHistoryData\").CouponHistoryData    local couponHistory = CouponHistoryData:new( response )        local historyMainScene = require(\"scripts.views.HistoryMainScene\")    historyMainScene.loadMoreContent( couponHistory )end","scripts.views.MatchListScene":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local SceneManager = require(\"scripts.SceneManager\")local CountryConfig = require(\"scripts.config.Country\")local LeagueConfig = require(\"scripts.config.League\")local TeamConfig = require(\"scripts.config.Team\")local Navigator = require(\"scripts.views.Navigator\")local LeagueListScene = require(\"scripts.views.LeagueListScene\")local Logic = require(\"scripts.Logic\").getInstance()local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal SMIS = require(\"scripts.SMIS\")local mWidgetlocal mTopLayerlocal mTheFirstDate = nillocal MIN_MOVE_DISTANCE = 100local OPTION_MOVE_TIME = 0.5local OPTION_VIEW_OFFSET_X = 475local CONTENT_FADEIN_TIME = 0.1local CONTENT_DELAY_TIME = 0.2function isShown()    return mWidget ~= nilendfunction loadFrame( matchList )\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/MatchListScene.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget( widget )    Navigator.loadFrame( widget )    -- Init the match list according to the data.    initMatchList( matchList )    -- Init the league list    LeagueListScene.loadFrame( \"scenes/CountryListContent.json\", \"scenes/LeagueListContent.json\",         tolua.cast( mWidget:getChildByName(\"leagueList\"), \"ScrollView\" ), leagueSelectedCallback )    -- Option button    local optionBt = widget:getChildByName(\"option\")    optionBt:addTouchEventListener( optionEventHandler )    local userName = tolua.cast( widget:getChildByName(\"userName\"), \"Label\" )    userName:setText( Logic:getDisplayName() )        if Logic:getPictureUrl() ~= nil then        local handler = function( filePath )            if filePath ~= nil then                local userLogo = tolua.cast( widget:getChildByName(\"userPhoto\"), \"ImageView\" )                userLogo:loadTexture( filePath )                userLogo:setScale( 1 )            end        end        SMIS.getSMImagePath( Logic:getPictureUrl(), handler )    end    -- Init the toplayer to listen to the swap action.    mTopLayer = CCLayer:create()    mTopLayer:registerScriptTouchHandler( onTopLevelTouch, false, -100)    mTopLayer:setTouchEnabled( false )    mWidget:addNode( mTopLayer )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endend-- Param matchList is Object of MatchListDatafunction initMatchList( matchList )     local contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )    contentContainer:removeAllChildrenWithCleanup( true )    local layoutParameter = LinearLayoutParameter:create()    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)    local contentHeight = 0    local seqArray = CCArray:create()        mTheFirstDate = nil    for k,v in pairs( matchList:getMatchDateList() ) do        local matchDate = v        local zOrder = matchDate[\"date\"]        seqArray:addObject( CCCallFuncN:create( function()            -- Add the date            local content = SceneManager.widgetFromJsonFile(\"scenes/MatchDate.json\")            local dateDisplay = tolua.cast( content:getChildByName(\"date\"), \"Label\" )            dateDisplay:setText( matchDate[\"dateDisplay\"] )            content:setLayoutParameter( layoutParameter )            content:setZOrder( zOrder )            contentContainer:addChild( content )            contentHeight = contentHeight + content:getSize().height            if mTheFirstDate == nil then                mTheFirstDate = content            end            content:setOpacity( 0 )            content:setCascadeOpacityEnabled( true )            mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )            updateContentContainer( contentHeight, content )        end ) )        seqArray:addObject( CCDelayTime:create( CONTENT_DELAY_TIME ) )        seqArray:addObject( CCCallFuncN:create( function()            -- Add the seprater            local upper = ImageView:create()            upper:loadTexture(\"images/guang.png\")            upper:setLayoutParameter( layoutParameter )            upper:setZOrder( zOrder )            contentContainer:addChild( upper )            contentHeight = contentHeight + upper:getSize().height            upper:setOpacity( 0 )            mWidget:runAction( CCTargetedAction:create( upper, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )            updateContentContainer( contentHeight, upper )        end ) )        seqArray:addObject( CCDelayTime:create( CONTENT_DELAY_TIME ) )                for inK, inV in pairs( matchDate[\"matches\"] ) do            local eventHandler = function( sender, eventType )                if eventType == TOUCH_EVENT_ENDED then                    enterMatch( inV )                end            end            seqArray:addObject( CCCallFuncN:create( function()                 local content = SceneManager.widgetFromJsonFile(\"scenes/MatchListContent.json\")                helperInitMatchInfo( content, inV )                content:setLayoutParameter( layoutParameter )                content:setZOrder( zOrder )                contentContainer:addChild( content )                contentHeight = contentHeight + content:getSize().height                content:addTouchEventListener( eventHandler )                content:setOpacity( 0 )                content:setCascadeOpacityEnabled( true )                mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )                updateContentContainer( contentHeight, content )            end ) )            seqArray:addObject( CCDelayTime:create( CONTENT_DELAY_TIME ) )        end        seqArray:addObject( CCCallFuncN:create( function()             -- Add the seprater            local bottom = ImageView:create()            bottom:loadTexture(\"images/guang.png\")            bottom:setFlipY(true)            bottom:setLayoutParameter( layoutParameter )            bottom:setZOrder( zOrder )            contentContainer:addChild( bottom )            contentHeight = contentHeight + bottom:getSize().height            bottom:setOpacity( 0 )            mWidget:runAction( CCTargetedAction:create( bottom, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )            updateContentContainer( contentHeight, bottom )        end ) )        seqArray:addObject( CCDelayTime:create( CONTENT_DELAY_TIME ) )    end    seqArray:addObject( CCCallFuncN:create( function()        if contentContainer:getChildrenCount() == 0 then            local content = SceneManager.widgetFromJsonFile(\"scenes/MatchListEmptyIndi.json\")            content:setLayoutParameter( layoutParameter )            contentContainer:addChild( content )            contentHeight = contentHeight + content:getSize().height            updateContentContainer( contentHeight, content )        end    end ) )    mWidget:runAction( CCSequence:create( seqArray ) )endfunction updateContentContainer( contentHeight, addContent )    local contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )    local layout = tolua.cast( contentContainer, \"Layout\" )    layout:requestDoLayout()    if mTheFirstDate ~= nil then        if addContent:getZOrder() < mTheFirstDate:getZOrder() then            local y = contentContainer:getInnerContainer():getPositionY() + addContent:getSize().height            contentContainer:jumpToDestination( ccp( 0, y ) )        end    endendfunction enterMatch( match )    Logic:setSelectedMatch( match )    EventManager:postEvent( Event.Enter_Match )endfunction leagueSelectedCallback( leagueId )    hideOptionAnim( function()        EventManager:postEvent( Event.Enter_Match_List, { LeagueConfig.getConfigId( leagueId ) } )    end )endfunction helperInitMatchInfo( content, matchInfo )    local team1 = tolua.cast( content:getChildByName(\"team1\"), \"ImageView\" )    local team2 = tolua.cast( content:getChildByName(\"team2\"), \"ImageView\" )    local team1Name = tolua.cast( content:getChildByName(\"team1Name\"), \"Label\" )    local team2Name = tolua.cast( content:getChildByName(\"team2Name\"), \"Label\" )    local friendNum = tolua.cast( content:getChildByName(\"friendNum\"), \"Label\" )    local fhNum = tolua.cast( content:getChildByName(\"fhNum\"), \"Label\" )    local played = tolua.cast( content:getChildByName(\"played\"), \"Label\" )        -- Load the team logo    team1:loadTexture( TeamConfig.getLogo( TeamConfig.getConfigIdByKey( matchInfo[\"HomeTeamId\"] ) ) )    team2:loadTexture( TeamConfig.getLogo( TeamConfig.getConfigIdByKey( matchInfo[\"AwayTeamId\"] ) ) )    -- Load the team names    local teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( matchInfo[\"HomeTeamId\"] ) )    if string.len( teamName ) > 20 then        team1Name:setFontSize( 20 )    end    team1Name:setText( teamName )    teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( matchInfo[\"AwayTeamId\"] ) )    if string.len( teamName ) > 20 then        team2Name:setFontSize( 20 )    end    team2Name:setText( teamName )    local time = tolua.cast( content:getChildByName(\"time\"), \"Label\" )    local score = tolua.cast( content:getChildByName(\"score\"), \"Label\" )    time:setFontName(\"fonts/Newgtbxc.ttf\")    score:setFontName(\"fonts/Newgtbxc.ttf\")    if matchInfo[\"HomeGoals\"] >= 0 and matchInfo[\"AwayGoals\"] >= 0 then        score:setText( string.format( score:getStringValue(), matchInfo[\"HomeGoals\"], matchInfo[\"AwayGoals\"] ) )        time:setEnabled( false )    else        time:setText( os.date( \"%H:%M\", matchInfo[\"StartTime\"] ) )        score:setEnabled( false )    end    if matchInfo[\"FriendsPlayed\"] > 0 then        friendNum:setText( matchInfo[\"FriendsPlayed\"] )    else        friendNum:setText(\"0\")    end    fhNum:setText( matchInfo[\"TotalUsersPlayed\"] )    played:setText( string.format( played:getStringValue(), matchInfo[\"PredictionsPlayed\"], matchInfo[\"PredictionsAvailable\"] ) )    local isGameStart = matchInfo[\"StartTime\"] > os.time()    if isGameStart then        content:setTouchEnabled( true )    else        content:setTouchEnabled( false )    endendfunction optionEventHandler( sender, eventType )    if eventType == TOUCH_EVENT_ENDED then        local optionBt = mWidget:getChildByName(\"option\")        optionBt:setTouchEnabled( false )        local seqArray = CCArray:create()        seqArray:addObject( CCMoveBy:create( OPTION_MOVE_TIME, ccp( OPTION_VIEW_OFFSET_X, 0 ) ) )        seqArray:addObject( CCCallFuncN:create( function()            mTopLayer:setTouchEnabled( true )        end ) )        mWidget:runAction( CCSequence:create( seqArray ) )    endendfunction onTopLevelTouch( eventType, x, y )    print( \"onTopLevelTouch\" )    if eventType == TOUCH_EVENT_ENDED then        local touchBeginPoint = sender:getTouchStartPos()        local touchEndPoint = sender:getTouchEndPos()        print( touchBeginPoint.x - touchEndPoint.x )            endendlocal startPosX, startPosYfunction onTopLevelTouch( eventType, x, y )    if eventType == \"began\" then        startPosX, startPosY = x, y        return true    elseif eventType == \"ended\" then        if startPosX - x > MIN_MOVE_DISTANCE then            -- Swap to Left            hideOptionAnim( nil )        end    endendfunction hideOptionAnim( callbackFunc )    mTopLayer:setTouchEnabled( false )    local seqArray = CCArray:create()    seqArray:addObject( CCMoveBy:create( OPTION_MOVE_TIME, ccp( OPTION_VIEW_OFFSET_X * (-1), 0 ) ) )    seqArray:addObject( CCCallFuncN:create( function()        local optionBt = mWidget:getChildByName(\"option\")        optionBt:setTouchEnabled( true )        if callbackFunc ~= nil then            callbackFunc()        end    end ) )    mWidget:runAction( CCSequence:create( seqArray ) )end","scripts.actions.EnterHistoryAction":"module(..., package.seeall)local Json = require(\"json\")local ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local Logic = require(\"scripts.Logic\").getInstance()local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal RequestUtils = require(\"scripts.RequestUtils\")local mUserId = Logic:getUserId()local mUserName = \"\"function action( param )    local historyMainScene = require(\"scripts.views.HistoryMainScene\")    if historyMainScene.isFrameShown() then        return     end                                                             \tlocal step = 1        mUserId = Logic:getUserId()    if param ~= nil and param[1] ~= nil and param[2] ~= nil then        mUserId = param[1]        mUserName = param[2]    end\tlocal url = RequestUtils.GET_COUPON_HISTORY_REST_CALL..\"?userId=\"..mUserId..\"&step=\"..step    local requestInfo = {}    requestInfo.requestData = \"\"    requestInfo.url = url    local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )    httpRequest:addHeader( Logic:getAuthSessionString() )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( response )    local CouponHistoryData = require(\"scripts.data.CouponHistoryData\").CouponHistoryData    local couponHistory = CouponHistoryData:new( response )        local historyMainScene = require(\"scripts.views.HistoryMainScene\")    historyMainScene.loadFrame( mUserId, mUserName, couponHistory )end","scripts.SMIS":"module(..., package.seeall)local RequestUtils = require(\"scripts.RequestUtils\")local FileUtils = require(\"scripts.FileUtils\")local FOLDER = \"SMI/\"-- Return the local file path if the file exist.-- Otherwise download it, save it locally and return the file path.function getSMImagePath( fileUrl, handler )\tlocal list = RequestUtils.split( fileUrl, \"/\" )\tlocal fileName = list[table.getn( list )]\tlocal fileUtils = CCFileUtils:sharedFileUtils()\tlocal path = fileUtils:getWritablePath()..FOLDER..fileName\tif fileUtils:isFileExist( path ) then\t\thandler( path )\telse\t\tlocal successHandler = function( body )\t\t\tFileUtils.writeStringToFile( FOLDER..fileName, body )\t\t\thandler( path )\t\tend\t\tlocal failedHandler = function()\t\t\thandler( nil )\t\tend\t\tdownloadSMImage( fileUrl, successHandler, failedHandler )\tendendfunction downloadSMImage( fileUrl, onRequestSuccess, onRequestFailed )\tlocal handler = function( isSucceed, body, header, status, errorBuffer )        print( \"Http reponse: \"..status..\" and errorBuffer: \"..errorBuffer )        if status == RequestUtils.HTTP_200 then            onRequestSuccess( body )        else            onRequestFailed()        end    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )    httpRequest:sendHttpRequest( fileUrl, handler )end","scripts.views.FAQScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal mWidgetfunction loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/FAQ.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget( widget )    local backBt = widget:getChildByName(\"back\")    backBt:addTouchEventListener( backEventHandler )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then        WebviewDelegate:sharedDelegate():openWebpage( \"http://www.baidu.com\", 0, 40, 320, 528 )    elseif eventType == \"exit\" then        mWidget = nil    endendfunction isFrameShown()    return mWidget ~= nilendfunction backEventHandler( sender,eventType )    if eventType == TOUCH_EVENT_ENDED then        WebviewDelegate:sharedDelegate():closeWebpage()        EventManager:popHistory()    endend","scripts.SceneManager":"module(..., package.seeall)local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal CheckFilesVersionAction = require(\"scripts.actions.CheckFilesVersionAction\")local EnterMatchListAction = require(\"scripts.actions.EnterMatchListAction\")local EnterMatchAction = require(\"scripts.actions.EnterMatchAction\")local EnterPredictionConfirmAction = require(\"scripts.actions.EnterPredictionConfirmAction\")local EnterPredTotalConfirmAction = require(\"scripts.actions.EnterPredTotalConfirmAction\")local EnterLoginNRegAction = require(\"scripts.actions.EnterLoginNRegAction\")local EnterRegisterAction = require(\"scripts.actions.EnterRegisterAction\")local EnterRegisterNameAction = require(\"scripts.actions.EnterRegisterNameAction\")local EnterLoginAction = require(\"scripts.actions.EnterLoginAction\")local EnterForgotPasswordAction = require(\"scripts.actions.EnterForgotPasswordAction\")local EnterSelFavTeamAction = require(\"scripts.actions.EnterSelFavTeamAction\")local EnterNextPredictionAction = require(\"scripts.actions.EnterNextPredictionAction\")local EnterHistoryAction = require(\"scripts.actions.EnterHistoryAction\")local EnterHistoryDetailAction = require(\"scripts.actions.EnterHistoryDetailAction\")local EnterLeaderboardAction = require(\"scripts.actions.EnterLeaderboardAction\")local EnterLeaderboardListAction = require(\"scripts.actions.EnterLeaderboardListAction\")local EnterSettingsAction = require(\"scripts.actions.EnterSettingsAction\")local EnterFAQAction = require(\"scripts.actions.EnterFAQAction\")local DoRegisterAction = require(\"scripts.actions.DoRegisterAction\")local DoLoginAction = require(\"scripts.actions.DoLoginAction\")local DoRegisterNameAction = require(\"scripts.actions.DoRegisterNameAction\")local DoFBConnectAction = require(\"scripts.actions.DoFBConnectAction\")local DoFBConnectWithUserAction = require(\"scripts.actions.DoFBConnectWithUserAction\")local DoPostPredictionsAction = require(\"scripts.actions.DoPostPredictionsAction\")local DoPostFavTeamAction = require(\"scripts.actions.DoPostFavTeamAction\")local ShowErrorMessageAction = require(\"scripts.actions.ShowErrorMessageAction\")local LoadMoreInLeaderboardAction = require(\"scripts.actions.LoadMoreInLeaderboardAction\")local LoadMoreInHistoryAction = require(\"scripts.actions.LoadMoreInHistoryAction\")TOUCH_PRIORITY_ZERO = 0TOUCH_PRIORITY_MINUS_ONE = -1local mSceneGameLayerlocal mWidgets = {}\t\t-- Store widget show in the list to save time loading the same json file.function init()\tlocal eglView = CCEGLView:sharedOpenGLView()\tif CCApplication:sharedApplication():getTargetPlatform() == kTargetWindows then\t\teglView:setFrameSize( 541, 960 )\tend\teglView:setDesignResolutionSize( 640, 1136, kResolutionShowAll )\tlocal sceneGame = CCScene:create()    CCDirector:sharedDirector():runWithScene( sceneGame )    mSceneGameLayer = TouchGroup:create()    sceneGame:addChild( mSceneGameLayer )    initEvents()endfunction initEvents()\tEventManager:registerEventHandler( Event.Check_File_Version, CheckFilesVersionAction )\tEventManager:registerEventHandler( Event.Enter_Login_N_Reg, EnterLoginNRegAction )\tEventManager:registerEventHandler( Event.Enter_Register, EnterRegisterAction )\tEventManager:registerEventHandler( Event.Enter_Register_Name, EnterRegisterNameAction )\tEventManager:registerEventHandler( Event.Enter_Login, EnterLoginAction )\tEventManager:registerEventHandler( Event.Enter_Forgot_Password, EnterForgotPasswordAction )\tEventManager:registerEventHandler( Event.Enter_Match_List, EnterMatchListAction )\tEventManager:registerEventHandler( Event.Enter_Match, EnterMatchAction )\tEventManager:registerEventHandler( Event.Enter_Prediction_Confirm, EnterPredictionConfirmAction )\tEventManager:registerEventHandler( Event.Enter_Pred_Total_Confirm, EnterPredTotalConfirmAction )\tEventManager:registerEventHandler( Event.Enter_Sel_Fav_Team, EnterSelFavTeamAction )\tEventManager:registerEventHandler( Event.Enter_Next_Prediction, EnterNextPredictionAction )\tEventManager:registerEventHandler( Event.Enter_History, EnterHistoryAction )\tEventManager:registerEventHandler( Event.Enter_History_Detail, EnterHistoryDetailAction )\tEventManager:registerEventHandler( Event.Enter_Leaderboard, EnterLeaderboardAction )\tEventManager:registerEventHandler( Event.Enter_Leaderboard_List, EnterLeaderboardListAction )\tEventManager:registerEventHandler( Event.Enter_Settings, EnterSettingsAction )\tEventManager:registerEventHandler( Event.Enter_FAQ, EnterFAQAction )\tEventManager:registerEventHandler( Event.Do_Register, DoRegisterAction )\tEventManager:registerEventHandler( Event.Do_Register_Name, DoRegisterNameAction )\tEventManager:registerEventHandler( Event.Do_Login, DoLoginAction )\tEventManager:registerEventHandler( Event.Do_FB_Connect, DoFBConnectAction )\tEventManager:registerEventHandler( Event.Do_FB_Connect_With_User, DoFBConnectWithUserAction )\tEventManager:registerEventHandler( Event.Do_Post_Predictions, DoPostPredictionsAction )\tEventManager:registerEventHandler( Event.Do_Post_Fav_Team, DoPostFavTeamAction )\tEventManager:registerEventHandler( Event.Show_Error_Message, ShowErrorMessageAction )\tEventManager:registerEventHandler( Event.Load_More_In_Leaderboard, LoadMoreInLeaderboardAction )\tEventManager:registerEventHandler( Event.Load_More_In_History, LoadMoreInHistoryAction )endfunction clearNAddWidget( widget )\tmSceneGameLayer:clear()\taddWidget( widget )endfunction clear()\tmSceneGameLayer:clear()endfunction addWidget( widget )\tmSceneGameLayer:addWidget( widget )endfunction removeWidget( widget )\tmSceneGameLayer:removeWidget( widget )endfunction widgetFromJsonFile( fileName )\tif mWidgets[fileName] == nil then\t\tlocal content = GUIReader:shareReader():widgetFromJsonFile( fileName )\t\tcontent:retain()\t\tmWidgets[fileName] = content\tend\treturn mWidgets[fileName]:clone()end","scripts.actions.EnterHistoryDetailAction":"module(..., package.seeall)function action( param )\tlocal historyDetailScene = require(\"scripts.views.HistoryDetailScene\")    historyDetailScene.loadFrame( param[1], param[2] )end","scripts.actions.DoPostPredictionsAction":"module(..., package.seeall)local Json = require(\"json\")local Constants = require(\"scripts.Constants\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal Logic = require(\"scripts.Logic\").getInstance()local RequestUtils = require(\"scripts.RequestUtils\")local ConnectingMessage = require(\"scripts.views.ConnectingMessage\")function action( param )    if Logic:getPredictions():getSize() > 0 then        postPredictionData()    else        EventManager:postEvent( Event.Enter_Match_List )    endendfunction postPredictionData()\tlocal requestContentText = Logic:getPredictions():toString()    local url = RequestUtils.POST_COUPONS_REST_CALL    local requestInfo = {}    requestInfo.requestData = requestContentText    requestInfo.url = url    local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess, onRequestFailed )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )    httpRequest:addHeader( Logic:getAuthSessionString() )        httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( jsonResponse )    local balance = jsonResponse[\"Balance\"]    Logic:resetPredictions()    Logic:setBalance( balance )    EventManager:postEvent( Event.Enter_Match_List )endfunction onRequestFailed( jsonResponse )    local errorBuffer = jsonResponse[\"Message\"]    EventManager:postEvent( Event.Show_Error_Message, { errorBuffer, postPredictionData } )end","scripts.views.ScorePrediction":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local SceneManager = require(\"scripts.SceneManager\")local TeamConfig = require(\"scripts.config.Team\")local MarketConfig = require(\"scripts.config.Market\")local Logic = require(\"scripts.Logic\").getInstance()local MarketsForGameData = require(\"scripts.data.MarketsForGameData\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal mWidgetlocal mMatchlocal mMarketsDatalocal MIN_MOVE_DISTANCE = 100local SCALE_BASE = 0.6local SCALE_UP_OFFSET_MAX = 0.2local SCALE_DOWN_OFFSET_MAX = -0.2local OPACITY = 255function loadFrame()    mMatch = Logic:getSelectedMatch()    mMarketsData = Logic:getCurMarketInfo():getMarketAt( Logic:getCurDisplayMarketIndex() )    local widget = GUIReader:shareReader():widgetFromJsonFile( getWidgetConfigFile() )    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    mWidget:addTouchEventListener( onFrameTouch )    SceneManager.clearNAddWidget( widget )    local backBt = widget:getChildByName(\"Back\")    local skipBt = widget:getChildByName(\"skip\")    backBt:addTouchEventListener( backEventHandler )    skipBt:addTouchEventListener( skipEventHandler )    helperInitMarketInfo( widget )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction getWidgetConfigFile()    local marketType = MarketsForGameData.getMarketType( mMarketsData )    if marketType == MarketConfig.MARKET_TYPE_TOTAL_GOAL then        return \"scenes/WTGBMTPrediction.json\"    elseif marketType == MarketConfig.MARKET_TYPE_ASIAN_HANDICAP then        return \"scenes/WTWBEGPrediction.json\"    end    return \"scenes/WTCBMTPrediction.json\"endfunction selectYes()    local yes = tolua.cast( mWidget:getChildByName(\"yes\"), \"ImageView\" )    makePrediction(        MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION ),        MarketsForGameData.getOddIdForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION ),        helperGetTheAnswer( true ),        yes:getTextureFile() )endfunction selectNo()    local no = tolua.cast( mWidget:getChildByName(\"no\"), \"ImageView\" )    makePrediction(        MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION ),        MarketsForGameData.getOddIdForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION ),        helperGetTheAnswer( false ),        no:getTextureFile() )endfunction skipEventHandler( sender, eventType )    if eventType == TOUCH_EVENT_ENDED then        SceneManager.clear()        EventManager:postEvent( Event.Enter_Next_Prediction )    endendfunction backEventHandler( sender, eventType )    if eventType == TOUCH_EVENT_ENDED then        EventManager:postEvent( Event.Do_Post_Predictions )    endendfunction makePrediction( rewards, oddId, answer, answerIcon )    local seqArray = CCArray:create()    seqArray:addObject( CCDelayTime:create( 0.1 ) )    seqArray:addObject( CCCallFuncN:create( function()        --EventManager:postEvent( Event.Enter_Prediction_Confirm, { answer, rewards, oddId, answerIcon } )        Logic:addPrediction( oddId, answer, rewards, answerIcon )        EventManager:postEvent( Event.Enter_Next_Prediction )    end ) )    mWidget:runAction( CCSequence:create( seqArray ) )    endfunction helperInitMarketInfo( content )    local team1Name = tolua.cast( content:getChildByName(\"team1Name\"), \"Label\" )    local team2Name = tolua.cast( content:getChildByName(\"team2Name\"), \"Label\" )    local yes = tolua.cast( mWidget:getChildByName(\"yes\"), \"ImageView\" )    local no = tolua.cast( mWidget:getChildByName(\"no\"), \"ImageView\" )    local answer1Point = tolua.cast( yes:getChildByName(\"answer1Point\"), \"Label\" )    local answer2Point = tolua.cast( no:getChildByName(\"answer2Point\"), \"Label\" )    local stake = tolua.cast( content:getChildByName(\"stake\"), \"Label\" )    local balance = tolua.cast( content:getChildByName(\"balance\"), \"Label\" )        team1Name:setText( TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) ) )    team2Name:setText( TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) ) )    answer1Point:setText( MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_ONE_OPTION )..\" points\" )    answer2Point:setText( MarketsForGameData.getOddsForType( mMarketsData, MarketConfig.ODDS_TYPE_TWO_OPTION )..\" points\" )    stake:setText( string.format( stake:getStringValue(), Constants.STAKE ) )    balance:setText( string.format( balance:getStringValue(), Logic:getBalance() - Logic:getUncommitedBalance() ) )    helperInitQuestion( content )endfunction helperInitQuestion( content )    local marketType = MarketsForGameData.getMarketType( mMarketsData )    local question = tolua.cast( content:getChildByName(\"question\"), \"Label\" )    local line = MarketsForGameData.getMarketLine( mMarketsData )    if marketType == MarketConfig.MARKET_TYPE_TOTAL_GOAL then        question:setText( string.format( question:getStringValue(), math.ceil( line ) ) )    elseif marketType == MarketConfig.MARKET_TYPE_ASIAN_HANDICAP then        local teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) )        if line < 0 then            teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) )            line = line * ( -1 )        end         question:setText( string.format( question:getStringValue(), teamName, math.ceil( line ) ) )    endendfunction helperGetTheAnswer( answerId )    local marketType = MarketsForGameData.getMarketType( mMarketsData )    local line = MarketsForGameData.getMarketLine( mMarketsData )    if marketType == MarketConfig.MARKET_TYPE_TOTAL_GOAL then        if answerId then            return string.format( \"Total goals will be %d or more.\", math.ceil( line ) )        else            return string.format( \"Total goals will less than %d.\", math.ceil( line ) )        end    elseif marketType == MarketConfig.MARKET_TYPE_ASIAN_HANDICAP then        local teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"AwayTeamId\"] ) )        if line < 0 then            teamName = TeamConfig.getTeamName( TeamConfig.getConfigIdByKey( mMatch[\"HomeTeamId\"] ) )            line = line * ( -1 )        end                 if answerId then            return string.format( \"%s will win by %d goals or more.\", teamName, math.ceil( line ) )        else            return string.format( \"%s will not win by %d goals or more.\", teamName, math.ceil( line ) )        end    endendfunction onFrameTouch( sender, eventType )    local yes = tolua.cast( mWidget:getChildByName(\"yes\"), \"ImageView\" )    local no = tolua.cast( mWidget:getChildByName(\"no\"), \"ImageView\" )    if eventType == TOUCH_EVENT_ENDED then        local touchBeginPoint = sender:getTouchStartPos()        local touchEndPoint = sender:getTouchEndPos()        if touchBeginPoint.x - touchEndPoint.x > MIN_MOVE_DISTANCE then            -- Swap to Left            selectNo()        elseif touchBeginPoint.x - touchEndPoint.x < MIN_MOVE_DISTANCE * (-1) then            -- Swap to Right            selectYes()        else            yes:setScale( SCALE_BASE )            no:setScale( SCALE_BASE )            yes:setOpacity( OPACITY )            no:setOpacity( OPACITY )        end    elseif eventType == TOUCH_EVENT_MOVED then        local touchBeginPoint = sender:getTouchStartPos()        local touchMovPoint = sender:getTouchMovePos()        local scalePercentage = math.abs( touchBeginPoint.x - touchMovPoint.x ) / MIN_MOVE_DISTANCE        if scalePercentage > 1 then            scalePercentage = 1        end        if touchBeginPoint.x - touchMovPoint.x > 0 then            no:setScale( scalePercentage * SCALE_UP_OFFSET_MAX + SCALE_BASE )            yes:setScale( scalePercentage * SCALE_DOWN_OFFSET_MAX + SCALE_BASE )            no:setOpacity( OPACITY )            yes:setOpacity( OPACITY / 3 )        else            yes:setScale( scalePercentage * SCALE_UP_OFFSET_MAX + SCALE_BASE )            no:setScale( scalePercentage * SCALE_DOWN_OFFSET_MAX + SCALE_BASE )            yes:setOpacity( OPACITY )            no:setOpacity( OPACITY / 3 )        end    endend","scripts.views.Navigator":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local SceneManager = require(\"scripts.SceneManager\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal mWidgetlocal mLastSelectedId = 0local NAV_BT_NUM = 4local TAB_EVENT_LIST = {\tEvent.Enter_Match_List,\tEvent.Enter_Leaderboard,\tEvent.Enter_History,\tEvent.Enter_Settings,}function loadFrame( parent )\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/Navigator.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    parent:addChild( widget )    for i = 1, NAV_BT_NUM do    \tlocal navBt = widget:getChildByName(\"nav\"..i)    \tnavBt:addTouchEventListener( navEventHandler )    end    if mLastSelectedId == 0 then    \tmLastSelectedId = 1    end    chooseNav( mLastSelectedId )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction navEventHandler( sender, eventType )\tif eventType == TOUCH_EVENT_ENDED then\t\tlocal navIndex = 1\t\tfor i = 1, NAV_BT_NUM do\t\t\tif sender == mWidget:getChildByName(\"nav\"..i) then\t\t\t\tnavIndex = i\t\t\tend\t\tend\t\tchooseNav( navIndex, true )\tendendfunction chooseNav( index, postMessage )\tmLastSelectedId = index\tpostMessage = postMessage or false\tfor i = 1, NAV_BT_NUM do\t\tlocal navBt = mWidget:getChildByName(\"nav\"..i)\t\tif i == index then\t\t\tnavBt:setFocused( true )\t\telse\t\t\tnavBt:setFocused( false )\t\tend\tend\tif postMessage then\t\tEventManager:postEvent( TAB_EVENT_LIST[index] )\tendend","scripts.data.CouponHistoryData":"module(..., package.seeall)CouponHistoryData = {}--[[{   \"open\":[      {         \"GameId\":642,         \"HomeTeamId\":229,         \"AwayTeamId\":244,         \"Result\":null,         \"ROI\":-1.0,         \"Profit\":0.00,         \"WinPercentage\":0.0,         \"GameCouponsDTOs\":[            {               \"MarketTypeId\":1,               \"CouponId\":992,               \"Line\":null,               \"OutcomeSide\":1,               \"Odd\":2.12,               \"Stake\":1000.00,               \"Won\":false,               \"Profit\":0.00            },            {               \"MarketTypeId\":2,               \"CouponId\":993,               \"Line\":2.5,               \"OutcomeSide\":2,               \"Odd\":1.95,               \"Stake\":1000.00,               \"Won\":false,               \"Profit\":0.00            },            {               \"MarketTypeId\":3,               \"CouponId\":994,               \"Line\":-0.5,               \"OutcomeSide\":1,               \"Odd\":2.20,               \"Stake\":1000.00,               \"Won\":false,               \"Profit\":0.00            }         ]      }   ],   \"closed\":[   ]}--]]function CouponHistoryData:new( rawDataObj )\tlocal obj = {\t\tOpenCoupon = rawDataObj[\"open\"],    ClosedCoupon = rawDataObj[\"closed\"],\t}\tsetmetatable(obj, self)    self.__index = self        obj.__newindex = function(t, k, v) assert(false, \"CouponHistoryData--\"..k .. \"__newindex not exist\") end        return obj endfunction CouponHistoryData:getOpenData()  return self.OpenCouponendfunction CouponHistoryData:getClosedData()  return self.ClosedCouponend","scripts.Logic":"module(..., package.seeall)local Json = require(\"json\")local FileUtils = require(\"scripts.FileUtils\")local Coupons = require(\"scripts.data.Coupons\").Couponslocal Constants = require(\"scripts.Constants\")-- Singleton of logiclocal MATCH_PREDICTION = \"matchPrediction\"local SCORE_PREDICTION = \"scorePrediction\"local SUB_PREDICTION = \"sub\"local instancelocal ACCOUNT_INFO_FILE = \"ai.txt\"local ACCOUNT_INFO_EMAIL = \"email\"local ACCOUNT_INFO_PASSWORD = \"password\"function getInstance()\tif instance == nil then\t\tinstance = Logic:new()\t\tlocal savedAccountInfo = FileUtils.readStringFromFile( ACCOUNT_INFO_FILE )\t\tif savedAccountInfo ~= nil and string.len( savedAccountInfo ) > 0 then\t\t\tlocal accountInfo = Json.decode( savedAccountInfo )\t\t\tprint( savedAccountInfo )\t\t\tinstance:setUserInfo( accountInfo[ACCOUNT_INFO_EMAIL], accountInfo[ACCOUNT_INFO_PASSWORD], 0, \"\" )\t\tend\tend\treturn instanceendLogic = {}function Logic:new()\tif instance ~= nil then\t\tassert( false )\t\treturn instance\tend\t\tlocal obj = {\t\tmPoint = 5000,\t\tmSelectedMatch = nil,\t--DS: see MatchListData\t\tmCurDisplayMarketIndex = 0,\t\tmCurMarketInfo = nil,\t-- DS: see MarketsForGameData\t\tmCoupons = Coupons:new(),  -- DS: Coupons\t\tmPreviousLeagueSelected = 0,\t\tsessionToken = 0,\t\temail = \"\",\t\tpassword = \"\",\t\tuserId = \"\",\t\tdisplayName = \"\",\t\tpictureUrl = nil,\t\tstartLeagueId = 0,\t\tbalance = 0,\t\tFbId = nil,\t}        setmetatable(obj, self)    self.__index = self        obj.__newindex = function(t, k, v) assert(false, \"Logic--\"..k .. \"__newindex not exist\") end        instance = obj    return obj endfunction Logic:getSelectedMatch()\treturn self.mSelectedMatchendfunction Logic:setSelectedMatch( match )\tself.mSelectedMatch = matchendfunction Logic:getCurDisplayMarketIndex()\treturn self.mCurDisplayMarketIndexendfunction Logic:setCurDisplayMarketIndex( index )\tself.mCurDisplayMarketIndex = indexendfunction Logic:getCurMarketInfo()\treturn self.mCurMarketInfoendfunction Logic:setCurMarketInfo( info )\tself.mCurMarketInfo = info\tself.mCurDisplayMarketIndex = 0endfunction Logic:getPoint()\treturn self.mPointendfunction Logic:setPoint( p )\tself.mPoint = pendfunction Logic:consumePoint( v )\tif self.mPoint > v then\t\tself:setPoint( self.mPoint - v )\telse\t\tself:setPoint( 0 )\tendendfunction Logic:setUserInfo( email, password, sessionToken, userId )\tself.email = email\tself.password = password\tself.sessionToken = sessionToken\tself.userId = userId\tlocal accountInfo = {}\taccountInfo[ACCOUNT_INFO_EMAIL] = email\taccountInfo[ACCOUNT_INFO_PASSWORD] = password\tFileUtils.writeStringToFile( ACCOUNT_INFO_FILE, Json.encode( accountInfo ) )endfunction Logic:getEmail()\treturn self.emailendfunction Logic:getPassword()\treturn self.passwordendfunction Logic:getAuthSessionString()\treturn \"Authorization: FH-Token \"..self.sessionTokenendfunction Logic:getUserId()\treturn self.userIdendfunction Logic:addPrediction( prediciton, answer, reward, answerIcon )\tprint( string.format( \"Make Prediction: %d with answer[%s], reward[%d] and answerIcon[%s]\", prediciton, answer, reward, answerIcon ) )\tself.mCoupons:addCoupon( prediciton, answer, reward, answerIcon )endfunction Logic:setPredictionMetadata( message, shareOnFacebook )\tself.mCoupons:setMessage( message )\tself.mCoupons:setShareOnFacebook( shareOnFacebook )endfunction Logic:getPredictions()\treturn self.mCouponsendfunction Logic:resetPredictions()\tself.mCoupons = Coupons:new()endfunction Logic:getPreviousLeagueSelected()\treturn self.mPreviousLeagueSelectedendfunction Logic:setPreviousLeagueSelected( id )\tself.mPreviousLeagueSelected = idendfunction Logic:getDisplayName()\treturn self.displayNameendfunction Logic:setDisplayName( name )\tself.displayName = nameendfunction Logic:getPictureUrl()\treturn self.pictureUrlendfunction Logic:setPictureUrl( url )\tself.pictureUrl = urlendfunction Logic:getStartLeagueId()\treturn self.startLeagueIdendfunction Logic:setStartLeagueId( id )\tself.startLeagueId = idendfunction Logic:setBalance( balance )\tself.balance = balanceendfunction Logic:getBalance()\treturn self.balanceendfunction Logic:getUncommitedBalance()\treturn self.mCoupons:getSize() * Constants.STAKEendfunction Logic:setFbId( id )\tself.FbId = idendfunction  Logic:getFbId()\treturn self.FbIdend","scripts.actions.EnterPredTotalConfirmAction":"module(..., package.seeall)function action( param )\tlocal PredTotalConfirmScene = require(\"scripts.views.PredTotalConfirmScene\")    PredTotalConfirmScene.loadFrame()end","scripts.views.LeaderboardListScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local Navigator = require(\"scripts.views.Navigator\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal TeamConfig = require(\"scripts.config.Team\")local LeaderboardConfig = require(\"scripts.config.Leaderboard\")local SMIS = require(\"scripts.SMIS\")local mWidgetlocal mLeaderboardIdlocal mSubTypelocal mSteplocal mCurrentTotalNum-- DS for subType see LeaderboardConfigfunction loadFrame( leaderboardInfo, leaderboardId, subType )\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/LeaderboardList.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget( widget )    Navigator.loadFrame( widget )    local backBt = mWidget:getChildByName(\"back\")    backBt:addTouchEventListener( backEventHandler )    mLeaderboardId = leaderboardId    mSubType = subType    initTitles()    initContent( leaderboardInfo )    mStep = 1endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction backEventHandler( sender,eventType )    if eventType == TOUCH_EVENT_ENDED then        --EventManager:postEvent( Event.Enter_Leaderboard )        EventManager:popHistory()    endendfunction initTitles()    local title = tolua.cast( mWidget:getChildByName(\"title\"), \"Label\" )    local subTitle = tolua.cast( mWidget:getChildByName(\"subTitle\"), \"Label\" )    title:setText( LeaderboardConfig.LeaderboardType[mLeaderboardId][\"displayName\"] )    subTitle:setText( mSubType[\"title\"] )endfunction initContent( leaderboardInfo )\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )    contentContainer:removeAllChildrenWithCleanup( true )    local layoutParameter = LinearLayoutParameter:create()    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)    local contentHeight = 0    for i = 1, table.getn( leaderboardInfo ) do    \tlocal eventHandler = function( sender, eventType )            if eventType == TOUCH_EVENT_ENDED then                contentClick( leaderboardInfo[i] )            end        end        local content = SceneManager.widgetFromJsonFile(\"scenes/LeaderboardListContent.json\")        content:setLayoutParameter( layoutParameter )        contentContainer:addChild( content )        contentHeight = contentHeight + content:getSize().height        initLeaderboardContent( i, content, leaderboardInfo[i] )        content:addTouchEventListener( eventHandler )    end    mCurrentTotalNum = table.getn( leaderboardInfo )    -- Add the \"More\" button    contentHeight = contentHeight + addMoreButton( contentContainer, layoutParameter ):getSize().height    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )    local layout = tolua.cast( contentContainer, \"Layout\" )    layout:requestDoLayout()endfunction addMoreButton( contentContainer, layoutParameter )    local content = SceneManager.widgetFromJsonFile(\"scenes/MoreContent.json\")    content:setLayoutParameter( layoutParameter )    contentContainer:addChild( content )    content:addTouchEventListener( loadMore )    content:setName(\"More\")    return contentendfunction initLeaderboardContent( i, content, info )    local name = tolua.cast( content:getChildByName(\"name\"), \"Label\" )    local score = tolua.cast( content:getChildByName(\"score\"), \"Label\" )    local index = tolua.cast( content:getChildByName(\"index\"), \"Label\" )    local logo = tolua.cast( content:getChildByName(\"logo\"), \"ImageView\" )    if info[\"DisplayName\"] == nil then        name:setText( \"Unknow name\" )    else        name:setText( info[\"DisplayName\"] )    end    score:setText( string.format( mSubType[\"description\"], info[mSubType[\"dataColumnId\"]] ) )    index:setText( i )    local seqArray = CCArray:create()    seqArray:addObject( CCDelayTime:create( i * 0.2 ) )    seqArray:addObject( CCCallFuncN:create( function()        if info[\"PictureUrl\"] ~= nil then            local handler = function( filePath )                if filePath ~= nil and logo ~= nil then                    logo:loadTexture( filePath )                    logo:setScale( 1 )                end            end            SMIS.getSMImagePath( info[\"PictureUrl\"], handler )        end    end ) )    mWidget:runAction( CCSequence:create( seqArray ) )endfunction loadMore( sender, eventType )    if eventType == TOUCH_EVENT_ENDED then        mStep = mStep + 1        EventManager:postEvent( Event.Load_More_In_Leaderboard, { leaderboardId, mSubType, mStep } )    endendfunction loadMoreContent( leaderboardInfo )    local contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )    -- Remove the \"More\" button    local moreButton = contentContainer:getChildByName(\"More\")    moreButton:removeFromParent()    local layoutParameter = LinearLayoutParameter:create()    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)    local contentHeight = contentContainer:getInnerContainerSize().height    for i = 1, table.getn( leaderboardInfo ) do        local eventHandler = function( sender, eventType )            if eventType == TOUCH_EVENT_ENDED then                contentClick( leaderboardInfo[i] )            end        end        local content = SceneManager.widgetFromJsonFile(\"scenes/LeaderboardListContent.json\")        content:setLayoutParameter( layoutParameter )        contentContainer:addChild( content )        contentHeight = contentHeight + content:getSize().height        initLeaderboardContent( mCurrentTotalNum + i, content, leaderboardInfo[i] )        content:addTouchEventListener( eventHandler )    end    mCurrentTotalNum = mCurrentTotalNum + table.getn( leaderboardInfo )    if table.getn( leaderboardInfo ) > 0 then        -- Add back the \"More\" button        addMoreButton( contentContainer, layoutParameter )    end    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )    local layout = tolua.cast( contentContainer, \"Layout\" )    layout:requestDoLayout()endfunction contentClick( info )    local id = info[\"Id\"]    local name = \"Unknow name\"    if info[\"DisplayName\"] ~= nil then        name = info[\"DisplayName\"]    end    EventManager:postEvent( Event.Enter_History, { id, name } )end","scripts.actions.EnterRegisterNameAction":"module(..., package.seeall)function action( param )\tlocal registerNameScene = require(\"scripts.views.RegisterNameScene\")    registerNameScene.loadFrame()    if param ~= nil then    \tlocal userName = param[1]\t    if userName ~= nil then\t    \tprint(\"Add user name:\"..userName)\t    \tregisterNameScene.setUserName( userName )\t    end    endend","scripts.actions.CheckFilesVersionAction":"module(..., package.seeall)local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local RequestUtils = require(\"scripts.RequestUtils\")local FileUtils = require(\"scripts.FileUtils\")local MD5 = require(\"MD5\")local fileList = {\t\"config/countries.txt\",\t\"config/leagues.txt\",\t\"config/teams.txt\",\t\"config/leagueteams.txt\",}local MD5ConfigIDList = {\t\"CountryConfigMd5\",\t\"LeagueConfigMd5\",\t\"TeamConfigMd5\",\t\"LeagueTeamConfigMd5\",}local CDNFileNameList = {\t\"countries.txt\",\t\"leagues.txt\",\t\"teams.txt\",\t\"leagueteams.txt\",}local mConfigMd5Infolocal mFinishEventlocal mCurrentFileIndexfunction action( param )\tmConfigMd5Info = param[1]\tmFinishEvent = param[2]\tmCurrentFileIndex = 0\tcheckNext()endfunction checkNext()\tmCurrentFileIndex = mCurrentFileIndex + 1\tif mCurrentFileIndex <= table.getn( fileList ) then\t\tcheckFile( mCurrentFileIndex )\t\telse\t\t-- Init the configure files.\t\tConnectingMessage.loadFrame( \"Login success.\\nLoading data, please wait...\" )\t\tlocal loadDataTaskSeqArray = CCArray:create()\t\tloadDataTaskSeqArray:addObject( CCDelayTime:create( 1 ) )\t\tloadDataTaskSeqArray:addObject( CCCallFuncN:create( function()\t\t\tlocal LeagueTeamConfig = require(\"scripts.config.LeagueTeams\")\t        local CountryConfig = require(\"scripts.config.Country\")\t        local LeagueConfig = require(\"scripts.config.League\")\t        local TeamConfig = require(\"scripts.config.Team\")\t        EventManager:postEvent( mFinishEvent )\t\tend ) )\t\tCCDirector:sharedDirector():getRunningScene():runAction( CCSequence:create( loadDataTaskSeqArray ) )\tendendfunction checkFile( fileIndex )\tlocal file = fileList[fileIndex]\tlocal MD5ConfigId = MD5ConfigIDList[fileIndex]\tlocal serverMD5 = mConfigMd5Info[MD5ConfigId]\tif serverMD5 == nil then\t\tprint( \"Checking \"..file..\", but server MD5 is nil.\" )\t\tcheckNext()\t\treturn\tend\t-- Compare the md5 value\t-- Re-download the file if not match\tlocal fileContent = FileUtils.readStringFromFile( file )\tlocal localMD5 = MD5.sumhexa( fileContent )\tprint( \"Checking \"..file..\": \"..serverMD5..\" | \"..localMD5 )\tif serverMD5 ~= localMD5 then\t\tlocal handler = function( isSucceed, body, header, status, errorBuffer )\t        print( \"Http reponse: \"..status..\" and errorBuffer: \"..errorBuffer )\t        ConnectingMessage.selfRemove()\t        if status == RequestUtils.HTTP_200 then\t            onRequestSuccess( file, body )\t        else\t            onRequestFailed( errorBuffer )\t        end\t    end\t    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )\t    print(\"Downloading from: \"..RequestUtils.CDN_SERVER_IP..CDNFileNameList[fileIndex])\t    httpRequest:sendHttpRequest( RequestUtils.CDN_SERVER_IP..CDNFileNameList[fileIndex], handler )\t    ConnectingMessage.loadFrame( \"Updating \"..file..\"...\" )\telse\t\tcheckNext()\tendendfunction onRequestSuccess( fileName, fileContent )\tprint(\"Update complete for file: \"..fileName)    FileUtils.writeStringToFile( fileName, fileContent )    checkNext()endfunction onRequestFailed( errorBuffer )\tif errorBuffer == \"\" then\t\terrorBuffer = \"Update file failed.\"\tend    EventManager:postEvent( Event.Show_Error_Message, { errorBuffer, checkNext } )end","scripts.actions.DoLoginAction":"module(..., package.seeall)local Json = require(\"json\")local Constants = require(\"scripts.Constants\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local RequestUtils = require(\"scripts.RequestUtils\")local mEmail = \"test126@abc.com\"local mPassword = \"test126\"function action( param )    mEmail, mPassword = param[1], param[2]    if string.len( mEmail ) == 0 then        RequestUtils.onRequestFailed( \"Email is blank.\" )        return    end    if string.len( mPassword ) == 0 then        RequestUtils.onRequestFailed( \"Password is blank.\" )        return    end    local requestContent = { Email = mEmail, Password = mPassword, useDev = RequestUtils.USE_DEV }    local requestContentText = Json.encode( requestContent )        local url = RequestUtils.EMAIL_LOGIN_REST_CALL    local requestInfo = {}    requestInfo.requestData = requestContentText    requestInfo.url = url     local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( jsonResponse )    local sessionToken = jsonResponse[\"ProfileDto\"][\"SessionToken\"]    local userId = jsonResponse[\"ProfileDto\"][\"Id\"]    local configMd5Info = jsonResponse[\"ProfileDto\"][\"ConfigMd5Info\"]    local displayName = jsonResponse[\"ProfileDto\"][\"DisplayName\"]    local pictureUrl = jsonResponse[\"ProfileDto\"][\"PictureUrl\"]    local startLeagueId = jsonResponse[\"ProfileDto\"][\"StartLeagueId\"]    local balance = jsonResponse[\"ProfileDto\"][\"Balance\"]    local FbId = jsonResponse[\"ProfileDto\"][\"FbId\"]    local Logic = require(\"scripts.Logic\").getInstance()    Logic:setUserInfo( mEmail, mPassword, sessionToken, userId )    Logic:setDisplayName( displayName )    Logic:setPictureUrl( pictureUrl )    Logic:setStartLeagueId( startLeagueId )    Logic:setBalance( balance )    Logic:setFbId( FbId )    local finishEvent = Event.Enter_Sel_Fav_Team    if displayName == nil then        finishEvent = Event.Enter_Register_Name    end    EventManager:postEvent( Event.Check_File_Version, { configMd5Info, finishEvent } )end","scripts.actions.ShowErrorMessageAction":"module(..., package.seeall)function action( param )\tlocal errorMessage = require(\"scripts.views.ErrorMessage\")    errorMessage.loadFrame()    errorMessage.setErrorMessage( param[1], param[2] )end","scripts.config.Leaderboard":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local RequestUtils = require(\"scripts.RequestUtils\")LeaderboardType = {\t{ [\"displayName\"] = \"Top Performers\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"top-performers.png\", [\"request\"] = RequestUtils.GET_MAIN_LEADERBOARD_REST_CALL },\t\t{ [\"displayName\"] = \"Friends\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"friends.png\", [\"request\"] = RequestUtils.GET_FRIENDS_LEADERBOARD_REST_CALL },\t--[[\t{ [\"displayName\"] = \"Followers\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"followers.png\" },\t{ [\"displayName\"] = \"Monthly\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"monthly.png\" },\t\t{ [\"displayName\"] = \"Competitions\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"competition.png\" },\t\t{ [\"displayName\"] = \"Prediction Types\", [\"logo\"] = Constants.LEADERBOARD_IMAGE_PATH..\"prediction-types.png\" },--]]}LeaderboardSubType = {\t{ [\"sortType\"] = 1, [\"dataColumnId\"] = \"Roi\", [\"title\"] = \"Roi\", [\"description\"] = \"%d%% won\", },\t{ [\"sortType\"] = 2, [\"dataColumnId\"] = \"WinPercentage\", [\"title\"] = \"Win %\", [\"description\"] = \"%d%% won\", },\t{ [\"sortType\"] = 3, [\"dataColumnId\"] = \"Profit\", [\"title\"] = \"Profit\", [\"description\"] = \"%d won\", },}","scripts.data.MatchListData":"module(..., package.seeall)MatchListData = {}--[[[    {        \"date\": \"2014/4/25\",        \"dateDisplay\": \"April 25, Thursday\",        \"matches\": [            {                \"Id\": 4077,                \"HomeTeamId\": 2744,                \"AwayTeamId\": 2942,                \"StartTime\": 1398311338                \"HomeGoals\": 2,                \"AwayGoals\": 3,                \"PredictionsPlayed\": 0,                \"PredictionsAvailable\": 0            },            {                \"Id\": 4555,                \"HomeTeamId\": 1573,                \"AwayTeamId\": 6914,                \"StartTime\": 1398311338                \"HomeGoals\": 2,                \"AwayGoals\": 3,                \"PredictionsPlayed\": 0,                \"PredictionsAvailable\": 0            },            {                \"Id\": 4083,                \"HomeTeamId\": 10310,                \"AwayTeamId\": 58760,                \"StartTime\": 1398311338                \"HomeGoals\": 2,                \"AwayGoals\": 3,                \"PredictionsPlayed\": 0,                \"PredictionsAvailable\": 0            }        ]    },    {        \"date\": \"2014/4/27\",        \"dateDisplay\": \"April 27, Saturday\",        \"matches\": [            {                \"Id\": 4077,                \"HomeTeamId\": 2744,                \"AwayTeamId\": 2942,                \"StartTime\": 1398311338                \"HomeGoals\": 2,                \"AwayGoals\": 3,                \"PredictionsPlayed\": 0,                \"PredictionsAvailable\": 0            },            {                \"Id\": 4555,                \"HomeTeamId\": 1573,                \"AwayTeamId\": 6914,                \"StartTime\": 1398311338                \"HomeGoals\": 2,                \"AwayGoals\": 3,                \"PredictionsPlayed\": 0,                \"PredictionsAvailable\": 0            },            {                \"Id\": 4083,                \"HomeTeamId\": 10310,                \"AwayTeamId\": 58760,                \"StartTime\": 1398311338                \"HomeGoals\": 2,                \"AwayGoals\": 3,                \"PredictionsPlayed\": 0,                \"PredictionsAvailable\": 0            }        ]    }]--]]function MatchListData:new()\tlocal obj = {\t\tmatchDateList = {}\t}\tsetmetatable(obj, self)    self.__index = self        obj.__newindex = function(t, k, v) assert(false, \"MatchListData--\"..k .. \"__newindex not exist\") end        return obj endfunction MatchListData:getOrCreateMatchListOnDate( date, dateDisplay )\tfor k,v in pairs( self.matchDateList ) do\t\tif v[\"date\"] == date then\t\t\treturn v\t\tend\tend\tlocal matchDate = {}\tmatchDate[\"date\"] = date\tmatchDate[\"dateDisplay\"] = dateDisplay\tmatchDate[\"matches\"] = {}\ttable.insert( self.matchDateList, matchDate )\treturn matchDateendfunction MatchListData:addMatch( match )\tlocal startTimeNum = match[\"StartTime\"]    local startTimeDate = os.date(\"%y\", startTimeNum) * 10000 + os.date(\"%m\", startTimeNum) * 100 + os.date(\"%d\", startTimeNum)    local startTimeDisplay = os.date( \"%B %d, %A\", startTimeNum )    local matchDate = self:getOrCreateMatchListOnDate( startTimeDate, startTimeDisplay )    table.insert( matchDate[\"matches\"], match )endfunction MatchListData:getMatchDateList()\treturn self.matchDateListend","scripts.actions.EnterLoginAction":"module(..., package.seeall)function action( param )\tlocal loginScene = require(\"scripts.views.LoginScene\")    loginScene.loadFrame()end","scripts.actions.EnterLeaderboardListAction":"module(..., package.seeall)local Json = require(\"json\")local ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal RequestUtils = require(\"scripts.RequestUtils\")local LeaderboardConfig = require(\"scripts.config.Leaderboard\")local Logic = require(\"scripts.Logic\").getInstance()local mLeaderboardIdlocal mSubType = LeaderboardConfig.LeaderboardSubType[1]function action( param )\tmLeaderboardId = param[1]\tlocal leaderboardType = param[2]\tlocal step = 1\tlocal url = LeaderboardConfig.LeaderboardType[mLeaderboardId][\"request\"]\t-- Todo change the url for friends leaderboard when that is done.\tif leaderboardType == 1 then\t\tmSubType = LeaderboardConfig.LeaderboardSubType[1]\telseif leaderboardType == 2 then\t\t-- Todo change to played type\telseif leaderboardType == 3 then\t\tmSubType = LeaderboardConfig.LeaderboardSubType[3]\telseif leaderboardType == 4 then\t\tmSubType = LeaderboardConfig.LeaderboardSubType[2]\tend\turl = url..\"?sortType=\"..mSubType[\"sortType\"]..\"&step=\"..step    local requestInfo = {}    requestInfo.requestData = \"\"    requestInfo.url = url\tlocal handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )    httpRequest:addHeader( Logic:getAuthSessionString() )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( response )    local leaderboardListScene = require(\"scripts.views.LeaderboardListScene\")    leaderboardListScene.loadFrame( response, mLeaderboardId, mSubType )end","scripts.views.SettingsScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local Navigator = require(\"scripts.views.Navigator\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal SettingsConfig = require(\"scripts.config.Settings\")local mWidgetfunction loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/SettingsHome.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget( widget )    Navigator.loadFrame( widget )    initContent()endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction isFrameShown()    return mWidget ~= nilendfunction initContent()\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )    contentContainer:removeAllChildrenWithCleanup( true )    local layoutParameter = LinearLayoutParameter:create()    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)    local contentHeight = 0    for i = 1, table.getn( SettingsConfig.SettingsItem ) do    \tlocal eventHandler = function( sender, eventType )            if eventType == TOUCH_EVENT_ENDED then                EventManager:postEvent( SettingsConfig.SettingsItem[i][\"event\"] )            end        end        local content = SceneManager.widgetFromJsonFile(\"scenes/SettingsHomeContent.json\")        content:setLayoutParameter( layoutParameter )        contentContainer:addChild( content )        contentHeight = contentHeight + content:getSize().height        content:addTouchEventListener( eventHandler )        initSettingsItemContent( content, SettingsConfig.SettingsItem[i] )    end    contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )    local layout = tolua.cast( contentContainer, \"Layout\" )    layout:requestDoLayout()endfunction initSettingsItemContent( content, info )    local name = tolua.cast( content:getChildByName(\"name\"), \"Label\" )    name:setText( info[\"itemName\"] )end","scripts.actions.EnterRegisterAction":"module(..., package.seeall)function action( param )\tlocal registerScene = require(\"scripts.views.RegisterScene\")    registerScene.loadFrame()end","scripts.views.RegisterScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ViewUtils = require(\"scripts.views.ViewUtils\")local EMAIL_CONTAINER_NAME = \"emailContainer\"local PASSWORD_CONTAINER_NAME = \"passwordContainer1\"local PASSWORD_CONF_CONTAINER_NAME = \"passwordContainer2\"local mWidgetlocal inputWidth = 400local inputHeight = 50function loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/Register.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget(widget)    local backBt = widget:getChildByName(\"back\")    local registerBt = widget:getChildByName(\"register\")    backBt:addTouchEventListener( backEventHandler )    registerBt:addTouchEventListener( registerEventHandler )    local emailInput = ViewUtils.createTextInput( mWidget:getChildByName( EMAIL_CONTAINER_NAME ), \"E-mail address\" )    local passwordInput = ViewUtils.createTextInput( mWidget:getChildByName( PASSWORD_CONTAINER_NAME ), \"Password\" )    local passwordConfInput = ViewUtils.createTextInput( mWidget:getChildByName( PASSWORD_CONF_CONTAINER_NAME ), \"Confirm Password\" )    passwordInput:setInputFlag( kEditBoxInputFlagPassword )    passwordConfInput:setInputFlag( kEditBoxInputFlagPassword )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction backEventHandler( sender,eventType )\tif eventType == TOUCH_EVENT_ENDED then        --EventManager:postEvent( Event.Enter_Login_N_Reg )        EventManager:popHistory()    endendfunction registerEventHandler( sender,eventType )\tif eventType == TOUCH_EVENT_ENDED then        local email = mWidget:getChildByName( EMAIL_CONTAINER_NAME ):getNodeByTag( 1 ):getText()        local pass = mWidget:getChildByName( PASSWORD_CONTAINER_NAME ):getNodeByTag( 1 ):getText()        local passConf = mWidget:getChildByName( PASSWORD_CONF_CONTAINER_NAME ):getNodeByTag( 1 ):getText()        EventManager:postEvent( Event.Do_Register, { email, pass, passConf } )    endend","scripts.actions.EnterMatchListAction":"module(..., package.seeall)local Json = require(\"json\")local RequestUtils = require(\"scripts.RequestUtils\")local ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal Logic = require(\"scripts.Logic\").getInstance()function action( param )    local leagueId = Logic:getStartLeagueId()    if Logic:getPreviousLeagueSelected() > 0 then        leagueId = Logic:getPreviousLeagueSelected()    end    if param ~= nil and param[1] ~= nil then        leagueId = param[1]    end    Logic:setPreviousLeagueSelected( leagueId )    local url = RequestUtils.GET_UPCOMING_GAMES_BY_LEAGUE_REST_CALL..\"?leagueId=\"..leagueId    local requestInfo = {}    requestInfo.requestData = \"\"    requestInfo.url = url    local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess, onRequestFailed )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpGet )    httpRequest:addHeader( Logic:getAuthSessionString() )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()--[[    local JsonConfigReader = require(\"scripts.config.JsonConfigReader\")    local config = JsonConfigReader.read( \"config/matchList.json\" )    onRequestSuccess( config )--]]endfunction onRequestSuccess( matchList )    local MatchListData = require(\"scripts.data.MatchListData\").MatchListData    -- Sort the match according to its start time.    local currentTime = os.time()    local currentDate = os.time{year=os.date(\"%Y\", currentTime), month=os.date(\"%m\", currentTime), day=os.date(\"%d\", currentTime), hour=0}    table.sort( matchList, function ( n1, n2 )        if n1[\"StartTime\"] < n2[\"StartTime\"] then            if n2[\"StartTime\"] < currentDate then                return false            elseif n1[\"StartTime\"] < currentDate then                return false            else                return true            end        elseif  n1[\"StartTime\"] > n2[\"StartTime\"] then            if n1[\"StartTime\"] < currentDate then                return true            elseif n2[\"StartTime\"] < currentDate then                return true            else                return false            end        else            return false        end    end )    -- Group and sort.    local sortedMatchList = MatchListData:new()    for k,v in pairs( matchList ) do        sortedMatchList:addMatch( v )    end\tlocal matchListScene = require(\"scripts.views.MatchListScene\")    if matchListScene.isShown() then        matchListScene.initMatchList( sortedMatchList )    else        matchListScene.loadFrame( sortedMatchList )    end    endfunction onRequestFailed( jsonResponse )    local errorBuffer = jsonResponse[\"Message\"]    local MatchListData = require(\"scripts.data.MatchListData\").MatchListData    local matchList = MatchListData:new()    local matchListScene = require(\"scripts.views.MatchListScene\")    if matchListScene.isShown() then        matchListScene.initMatchList( matchList )    else        matchListScene.loadFrame( matchList )    end        EventManager:postEvent( Event.Show_Error_Message, { errorBuffer } )end","scripts.actions.EnterFAQAction":"module(..., package.seeall)function action( param )\tlocal FAQScene = require(\"scripts.views.FAQScene\")\tif FAQScene.isFrameShown() then\t\treturn\tend    FAQScene.loadFrame()end","scripts.views.HistoryDetailScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local Navigator = require(\"scripts.views.Navigator\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal MarketConfig = require(\"scripts.config.Market\")local TeamConfig = require(\"scripts.config.Team\")local Constants = require(\"scripts.Constants\")local CONTENT_FADEIN_TIME = 1local mWidgetlocal mIsOpenlocal mGameCouponsDTOslocal mHomeTeamIdlocal mAwayTeamId-- DS for matchInof, see CouponHistoryDatafunction loadFrame( isOpen, matchInfo )\tmIsOpen = isOpen    mGameCouponsDTOs = matchInfo[\"GameCouponsDTOs\"]    local widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/HistoryDetail.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget( widget )    Navigator.loadFrame( widget )    local backBt = mWidget:getChildByName(\"back\")    backBt:addTouchEventListener( backEventHandler )    helperInitMatchInfo( mWidget, matchInfo )    initContent()endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction backEventHandler( sender,eventType )    if eventType == TOUCH_EVENT_ENDED then        --EventManager:postEvent( Event.Enter_History )        EventManager:popHistory()    endendfunction initContent()    local contentWidgetFile = \"scenes/HistoryDetailClosedContent.json\"    if mIsOpen then        contentWidgetFile = \"scenes/HistoryDetailOpenContent.json\"    end\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )    contentContainer:removeAllChildrenWithCleanup( true )    local layoutParameter = LinearLayoutParameter:create()    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)    local contentHeight = 0    local seqArray = CCArray:create()    for i = 1, table.getn( mGameCouponsDTOs ) do        seqArray:addObject( CCCallFuncN:create( function()            local content = GUIReader:shareReader():widgetFromJsonFile( contentWidgetFile )            content:setLayoutParameter( layoutParameter )            contentContainer:addChild( content )            contentHeight = contentHeight + content:getSize().height            --content:addTouchEventListener( eventHandler )            initCouponInfo( content, mGameCouponsDTOs[i] )            content:setOpacity( 0 )            content:setCascadeOpacityEnabled( true )            mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )        end ) )        seqArray:addObject( CCDelayTime:create( 0.2 ) )    end    seqArray:addObject( CCCallFuncN:create( function()        contentContainer:setInnerContainerSize( CCSize:new( 0, contentHeight ) )        local layout = tolua.cast( contentContainer, \"Layout\" )        layout:requestDoLayout()    end ) )    mWidget:runAction( CCSequence:create( seqArray ) )endfunction helperInitMatchInfo( content, matchInfo )    mHomeTeamId = TeamConfig.getConfigIdByKey( matchInfo[\"HomeTeamId\"] )    mAwayTeamId = TeamConfig.getConfigIdByKey( matchInfo[\"AwayTeamId\"] )    local team1Name = tolua.cast( content:getChildByName(\"team1Name\"), \"Label\" )    local team2Name = tolua.cast( content:getChildByName(\"team2Name\"), \"Label\" )    team1Name:setText( TeamConfig.getTeamName( mHomeTeamId ) )    team2Name:setText( TeamConfig.getTeamName( mAwayTeamId ) )    team1Name:setFontName(\"fonts/Newgtbxc.ttf\")    team2Name:setFontName(\"fonts/Newgtbxc.ttf\")endfunction initCouponInfo( content, info )    local answer = tolua.cast( content:getChildByName(\"answer\"), \"Label\" )    local winLoseLabel = tolua.cast( content:getChildByName(\"winLoseLabel\"), \"Label\" )    local points = tolua.cast( content:getChildByName(\"points\"), \"Label\" )    local stake = tolua.cast( content:getChildByName(\"stake\"), \"Label\" )    local choice = tolua.cast( content:getChildByName(\"choice\"), \"ImageView\" )    local statusBar = tolua.cast( content:getChildByName(\"statusBar\"), \"Button\" )    -- Init the answer string.    local marketType = info[\"MarketTypeId\"]    local line = info[\"Line\"]    local answerId = ( info[\"OutcomeSide\"] == 1 )    local answerString    local choiceImage    if marketType == MarketConfig.MARKET_TYPE_MATCH then        if answerId then            answerString = TeamConfig.getTeamName( mHomeTeamId )..\" to win.\"            choiceImage = TeamConfig.getLogo( mHomeTeamId )        else            answerString = TeamConfig.getTeamName( mAwayTeamId )..\" to win.\"            choiceImage = TeamConfig.getLogo( mAwayTeamId )        end    elseif marketType == MarketConfig.MARKET_TYPE_TOTAL_GOAL then        if answerId then            answerString = string.format( \"Total goals will be %d or more.\", math.ceil( line ) )            choiceImage = Constants.PREDICTION_CHOICE_IMAGE_PATH..\"Will-total-goals-be-more-than-xx-yes.png\"        else            answerString = string.format( \"Total goals will less than %d.\", math.ceil( line ) )            choiceImage = Constants.PREDICTION_CHOICE_IMAGE_PATH..\"Will-total-goals-be-more-than-xx-no.png\"        end    elseif marketType == MarketConfig.MARKET_TYPE_ASIAN_HANDICAP then        local teamName = TeamConfig.getTeamName( mAwayTeamId )        if line < 0 then            teamName = TeamConfig.getTeamName( mHomeTeamId )            line = line * ( -1 )        end                 if answerId then            answerString = string.format( \"%s will win by %d goals or more.\", teamName, math.ceil( line ) )            choiceImage = Constants.PREDICTION_CHOICE_IMAGE_PATH..\"Will-xx_team-score-a-goal-yes.png\"        else            answerString = string.format( \"%s will not win by %d goals or more.\", teamName, math.ceil( line ) )            choiceImage = Constants.PREDICTION_CHOICE_IMAGE_PATH..\"Will-xx_team-score-a-goal-no.png\"        end    end    answer:setText( answerString )    choice:loadTexture( choiceImage )    stake:setText( string.format( stake:getStringValue(), info[\"Stake\"] ) )    if mIsOpen == false then        if info[\"Won\"] then            statusBar:setFocused( true )            winLoseLabel:setText(\"Won:\")            points:setText( string.format( points:getStringValue(), info[\"Stake\"] * ( info[\"Odd\"] - 1 ) ) )        else            statusBar:setBright( false )            winLoseLabel:setText(\"Lost:\")            points:setText( string.format( points:getStringValue(), info[\"Stake\"] ) )        end    else        points:setText( string.format( points:getStringValue(), info[\"Stake\"] * ( info[\"Odd\"] - 1 ) ) )    endend","scripts.actions.EnterLeaderboardAction":"module(..., package.seeall)function action( param )\tlocal leaderboardMainScene = require(\"scripts.views.LeaderboardMainScene\")\tif leaderboardMainScene.isFrameShown() then\t\treturn\tend    leaderboardMainScene.loadFrame()end","scripts.views.RegisterNameScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ViewUtils = require(\"scripts.views.ViewUtils\")local USERNAME_CONTAINER_NAME = \"usernameContainer\"local FIRSTNAME_CONTAINER_NAME = \"firstnameContainer\"local LASTNAME_CONTAINER_NAME = \"lastnameContainer\"local mWidgetlocal inputWidth = 400local inputHeight = 50function loadFrame()\tlocal widget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/RegisterName.json\")    mWidget = widget    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget(widget)    local confirmBt = widget:getChildByName(\"confirm\")    confirmBt:addTouchEventListener( confirmEventHandler )    ViewUtils.createTextInput( mWidget:getChildByName( USERNAME_CONTAINER_NAME ), \"Username\" )    ViewUtils.createTextInput( mWidget:getChildByName( FIRSTNAME_CONTAINER_NAME ), \"First name (Optional)\" )    ViewUtils.createTextInput( mWidget:getChildByName( LASTNAME_CONTAINER_NAME ), \"Last name (Optional)\" )endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction setUserName( name )    mWidget:getChildByName( USERNAME_CONTAINER_NAME ):getNodeByTag( 1 ):setText( name )endfunction confirmEventHandler( sender,eventType )\tif eventType == TOUCH_EVENT_ENDED then        local userName = mWidget:getChildByName( USERNAME_CONTAINER_NAME ):getNodeByTag( 1 ):getText()        local firstName = mWidget:getChildByName( FIRSTNAME_CONTAINER_NAME ):getNodeByTag( 1 ):getText()        local lastName = mWidget:getChildByName( LASTNAME_CONTAINER_NAME ):getNodeByTag( 1 ):getText()        EventManager:postEvent( Event.Do_Register_Name, { userName, firstName, lastName } )    endend","scripts.actions.DoFBConnectAction":"module(..., package.seeall)local Constants = require(\"scripts.Constants\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal ConnectingMessage = require(\"scripts.views.ConnectingMessage\")local Json = require(\"json\")local RequestUtils = require(\"scripts.RequestUtils\")function action( param )\tlocal Json = require(\"json\")\tlocal RequestUtils = require(\"scripts.RequestUtils\")    local successHandler = function( accessToken )        if accessToken == nil then            -- To handle user reject to the oAuth.            onFBConnectFailed()        else            print(\"Get login result \"..accessToken)            onFBConnectSuccess( accessToken )        end    end    FacebookDelegate:sharedDelegate():login( successHandler, successHandler )endfunction onFBConnectFailed()endfunction onFBConnectSuccess( accessToken )    local requestContent = { SocialNetworkType = 0, AuthToken = accessToken, useDev = RequestUtils.USE_DEV }    local requestContentText = Json.encode( requestContent )        local url = RequestUtils.FB_LOGIN_REST_CALL        local requestInfo = {}    requestInfo.requestData = requestContentText    requestInfo.url = url    local handler = function( isSucceed, body, header, status, errorBuffer )        RequestUtils.messageHandler( requestInfo, isSucceed, body, header, status, errorBuffer, RequestUtils.HTTP_200, onRequestSuccess )    end    local httpRequest = HttpRequestForLua:create( CCHttpRequest.kHttpPost )    httpRequest:addHeader( Constants.CONTENT_TYPE_JSON )    httpRequest:getRequest():setRequestData( requestContentText, string.len( requestContentText ) )    httpRequest:sendHttpRequest( url, handler )    ConnectingMessage.loadFrame()endfunction onRequestSuccess( jsonResponse )    local sessionToken = jsonResponse[\"SessionToken\"]    local userId = jsonResponse[\"Id\"]    local configMd5Info = jsonResponse[\"ConfigMd5Info\"]    local displayName = jsonResponse[\"DisplayName\"]    local pictureUrl = jsonResponse[\"PictureUrl\"]    local startLeagueId = jsonResponse[\"StartLeagueId\"]    local balance = jsonResponse[\"Balance\"]    local FbId = jsonResponse[\"FbId\"]    local Logic = require(\"scripts.Logic\").getInstance()    Logic:setUserInfo( \"\", \"\", sessionToken, userId )    Logic:setDisplayName( displayName )    Logic:setPictureUrl( pictureUrl )    Logic:setStartLeagueId( startLeagueId )    Logic:setBalance( balance )    Logic:setFbId( FbId )        local finishEvent = Event.Enter_Sel_Fav_Team    if displayName == nil then        finishEvent = Event.Enter_Register_Name    end    EventManager:postEvent( Event.Check_File_Version, { configMd5Info, finishEvent } )end","scripts.events.EventManager":"module(..., package.seeall)local Event = require(\"scripts.events.Event\")local instancefunction getInstance()\tif instance == nil then\t\tinstance = EventManager:new()\tend\treturn instanceendEventManager = {}function EventManager:new()\tif instance ~= nil then\t\tassert( false )\t\treturn instance\tend\t\tlocal obj = {\t\tmEventHandler = {},\t\tmEventHistory = {}\t}        setmetatable(obj, self)    self.__index = self        obj.__newindex = function(t, k, v) assert(false, \"EventManager--\"..k .. \"__newindex not exist\") end        instance = obj    return obj endfunction EventManager:registerEventHandler( eventId, action )\tself.mEventHandler[eventId] = actionendfunction EventManager:postEvent( eventId, param )\tif self.mEventHandler[eventId] == nil then\t\tprint( \"Event id = \"..Event.GetEventNameById( eventId )..\" has no action.\" )\telse\t\tprint( \"Event id = \"..Event.GetEventNameById( eventId )..\" handled.\" )\t\tself:addHistory( eventId, param )\t\tself.mEventHandler[eventId].action( param )\tendendfunction EventManager:addHistory( eventId, param )\tlocal eventName = Event.GetEventNameById( eventId )\tif Event.EventDosenotTrackList[eventName] == nil then\t\tprint(\"Track: \"..eventName)\t\tlocal history = {\t\t\t[\"eventId\"] = eventId,\t\t\t[\"param\"] = param\t\t}\t\ttable.insert( self.mEventHistory, history )\telse\t\tprint(\"Does not track: \"..eventName)\tendendfunction EventManager:popHistory()\ttable.remove( self.mEventHistory ) -- Throw away the current one.\tlocal lastHistory = table.remove( self.mEventHistory ) \tif lastHistory ~= nil then\t\tself:postEvent( lastHistory[\"eventId\"], lastHistory[\"param\"] )\telse\t\tprint( \"Dose not have history event.\" )\tendend","scripts.FileUtils":"module(..., package.seeall)local Json = require(\"json\")function writeStringToFile( fileName, str )\tlocal fileUtils = CCFileUtils:sharedFileUtils()\tlocal writePath = fileUtils:getWritablePath()..fileName\tcreateFolderRecur( fileUtils:getWritablePath(), fileName )\tlocal fileHandle, errorCode = io.open( writePath, \"w+\" )\t--print( \"Write to: \"..writePath )\tif fileHandle == nil then\t\tassert( false, \"Write failed to file\"..fileName..\" with error: \"..errorCode )\t\treturn\tend\tfileHandle:write( str )\tfileHandle:close()endfunction createFolderRecur( existFolder, toCreateFolder )\tprint(\"createFolderRecur: \"..existFolder..\"|\"..toCreateFolder)\tlocal pos = string.find( toCreateFolder, \"/\" )\tif pos ~= nil then\t\tlocal folderToCreate = existFolder..string.sub( toCreateFolder, 1, pos )\t\tif lfs.mkdir( folderToCreate ) then\t\t\tcreateFolderRecur( folderToCreate, string.sub( toCreateFolder, pos + 1 ) )\t\tend\tendend-- 1. check the writable path-- 2. check the file in the packagefunction readStringFromFile( fileName )\tlocal text = \"\"\tlocal fileUtils = CCFileUtils:sharedFileUtils()\tlocal path = fileUtils:getWritablePath()..fileName\tif fileUtils:isFileExist( path ) then\t\tprint(\"Read local file from: \"..path)\t\tlocal fileHandler, errorCode = io.open( path, \"r\" )\t\t--print( \"Read from: \"..path )\t\tif fileHandler == nil then\t\t\tassert( false, \"Read failed from file\"..fileName..\" with error: \"..errorCode )\t\t\treturn \"\"\t\tend\t\t\t\ttext = fileHandler:read(\"*all\")\t\tfileHandler:close()\telse\t\tlocal fileName = fileUtils:fullPathForFilename( fileName )\t\tprint(\"Read file from package: \"..fileName)\t\ttext = fileUtils:getFileData( fileName, \"r\", 0 )\tend\treturn textend","scripts.views.HistoryMainScene":"module(..., package.seeall)local SceneManager = require(\"scripts.SceneManager\")local Navigator = require(\"scripts.views.Navigator\")local EventManager = require(\"scripts.events.EventManager\").getInstance()local Event = require(\"scripts.events.Event\").EventListlocal TeamConfig = require(\"scripts.config.Team\")local Logic = require(\"scripts.Logic\").getInstance()local CONTENT_FADEIN_TIME = 1local mWidgetlocal mStep-- DS for couponHistory see CouponHistoryDatafunction loadFrame( userId, userName, couponHistory )    if userId == Logic:getUserId() then        mWidget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/HistoryHome.json\")        local totalPoints = tolua.cast( mWidget:getChildByName(\"totalPoints\"), \"Label\" )        totalPoints:setText( string.format( totalPoints:getStringValue(), Logic:getBalance() ) )    else        mWidget = GUIReader:shareReader():widgetFromJsonFile(\"scenes/HistoryHomeForOthers.json\")        local name = tolua.cast( mWidget:getChildByName(\"name\"), \"Label\" )        name:setText( userName )        local backEventHandler = function( sender, eventType )            if eventType == TOUCH_EVENT_ENDED then                EventManager:popHistory()            end        end        local backBt = mWidget:getChildByName(\"Back\")        backBt:addTouchEventListener( backEventHandler )    end\t    mWidget:registerScriptHandler( EnterOrExit )    SceneManager.clearNAddWidget( mWidget )    Navigator.loadFrame( mWidget )    initContent( couponHistory )    mStep = 1endfunction EnterOrExit( eventType )    if eventType == \"enter\" then    elseif eventType == \"exit\" then        mWidget = nil    endendfunction isFrameShown()    return mWidget ~= nilendfunction initContent( couponHistory )\tlocal contentContainer = tolua.cast( mWidget:getChildByName(\"ScrollView\"), \"ScrollView\" )    contentContainer:removeAllChildrenWithCleanup( true )    local layoutParameter = LinearLayoutParameter:create()    layoutParameter:setGravity(LINEAR_GRAVITY_CENTER_VERTICAL)    local contentHeight = 0    local seqArray = CCArray:create()    -- Add the open predictions     seqArray:addObject( CCCallFuncN:create( function()        local content = GUIReader:shareReader():widgetFromJsonFile(\"scenes/HistoryMainTitle.json\")        local titleText = tolua.cast( content:getChildByName(\"titleText\"), \"Label\" )        titleText:setText( \"Open Predictions\" )        content:setLayoutParameter( layoutParameter )        contentContainer:addChild( content )        contentHeight = contentHeight + content:getSize().height        content:setOpacity( 0 )        content:setCascadeOpacityEnabled( true )        mWidget:runAction( CCTargetedAction:create( content, CCFadeIn:create( CONTENT_FADEIN_TIME ) ) )    end ) )    seqArray:addObject( CCDelayTime:create( 0.2 ) )    for i = 1, table.getn( couponHistory:getOpenData() ) do    \tlocal eventHandler = function( sender, eventType )            if eventType == TOUCH_EVENT_ENDED then                predictionClicked( true, couponHistory:getOpenData()[i] )            end        end        seqArray:addObject( CCCallFuncN:create( function()            -- Add the open matches            local content = SceneManager.widgetFromJsonFile(\"scenes/HistoryMainMatchContent.json\")            content:setLayoutParameter( layoutParameter )            contentContainer:addChild( content )            contentHeight = contentHeight + content:getSize().height            local bt = content:getChildByName(\"match\")            bt:addTouchEventListener( eventHandler )            helperInitPredictionCommon( content, couponHistory:getOpenData()[i] )            helperInitOpenPrediction( content, couponHistory:getOpenData()[i] )            content:setOpacity( 0 )      