diff --git a/scripting/lua/cjson/fpconv.c b/scripting/lua/cjson/fpconv.c
new file mode 100755
index 0000000..e28d430
--- /dev/null
+++ b/scripting/lua/cjson/fpconv.c
@@ -0,0 +1,206 @@
+/* fpconv - Floating point conversion routines
+ *
+ * Copyright (c) 2011-2012  Mark Pulford <mark@kyne.com.au>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* JSON uses a '.' decimal separator. strtod() / sprintf() under C libraries
+ * with locale support will break when the decimal separator is a comma.
+ *
+ * fpconv_* will around these issues with a translation buffer if required.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+
+#include "fpconv.h"
+#include "CCStdC.h"
+
+/* Lua CJSON assumes the locale is the same for all threads within a
+ * process and doesn't change after initialisation.
+ *
+ * This avoids the need for per thread storage or expensive checks
+ * for call. */
+static char locale_decimal_point = '.';
+
+/* In theory multibyte decimal_points are possible, but
+ * Lua CJSON only supports UTF-8 and known locales only have
+ * single byte decimal points ([.,]).
+ *
+ * localconv() may not be thread safe (=>crash), and nl_langinfo() is
+ * not supported on some platforms. Use sprintf() instead - if the
+ * locale does change, at least Lua CJSON won't crash. */
+static void fpconv_update_locale()
+{
+    char buf[8];
+
+    snprintf(buf, sizeof(buf), "%g", 0.5);
+
+    /* Failing this test might imply the platform has a buggy dtoa
+     * implementation or wide characters */
+    if (buf[0] != '0' || buf[2] != '5' || buf[3] != 0) {
+        fprintf(stderr, "Error: wide characters found or printf() bug.");
+        abort();
+    }
+
+    locale_decimal_point = buf[1];
+}
+
+/* Check for a valid number character: [-+0-9a-yA-Y.]
+ * Eg: -0.6e+5, infinity, 0xF0.F0pF0
+ *
+ * Used to find the probable end of a number. It doesn't matter if
+ * invalid characters are counted - strtod() will find the valid
+ * number if it exists.  The risk is that slightly more memory might
+ * be allocated before a parse error occurs. */
+static int valid_number_character(char ch)
+{
+    char lower_ch;
+
+    if ('0' <= ch && ch <= '9')
+        return 1;
+    if (ch == '-' || ch == '+' || ch == '.')
+        return 1;
+
+    /* Hex digits, exponent (e), base (p), "infinity",.. */
+    lower_ch = ch | 0x20;
+    if ('a' <= lower_ch && lower_ch <= 'y')
+        return 1;
+
+    return 0;
+}
+
+/* Calculate the size of the buffer required for a strtod locale
+ * conversion. */
+static int strtod_buffer_size(const char *s)
+{
+    const char *p = s;
+
+    while (valid_number_character(*p))
+        p++;
+
+    return p - s;
+}
+
+/* Similar to strtod(), but must be passed the current locale's decimal point
+ * character. Guaranteed to be called at the start of any valid number in a string */
+double fpconv_strtod(const char *nptr, char **endptr)
+{
+    char localbuf[FPCONV_G_FMT_BUFSIZE];
+    char *buf, *endbuf, *dp;
+    int buflen;
+    double value;
+
+    /* System strtod() is fine when decimal point is '.' */
+    if (locale_decimal_point == '.')
+        return strtod(nptr, endptr);
+
+    buflen = strtod_buffer_size(nptr);
+    if (!buflen) {
+        /* No valid characters found, standard strtod() return */
+        *endptr = (char *)nptr;
+        return 0;
+    }
+
+    /* Duplicate number into buffer */
+    if (buflen >= FPCONV_G_FMT_BUFSIZE) {
+        /* Handle unusually large numbers */
+        buf = malloc(buflen + 1);
+        if (!buf) {
+            fprintf(stderr, "Out of memory");
+            abort();
+        }
+    } else {
+        /* This is the common case.. */
+        buf = localbuf;
+    }
+    memcpy(buf, nptr, buflen);
+    buf[buflen] = 0;
+
+    /* Update decimal point character if found */
+    dp = strchr(buf, '.');
+    if (dp)
+        *dp = locale_decimal_point;
+
+    value = strtod(buf, &endbuf);
+    *endptr = (char *)&nptr[endbuf - buf];
+    if (buflen >= FPCONV_G_FMT_BUFSIZE)
+        free(buf);
+
+    return value;
+}
+
+/* "fmt" must point to a buffer of at least 6 characters */
+static void set_number_format(char *fmt, int precision)
+{
+    int d1, d2, i;
+
+    assert(1 <= precision && precision <= 14);
+
+    /* Create printf format (%.14g) from precision */
+    d1 = precision / 10;
+    d2 = precision % 10;
+    fmt[0] = '%';
+    fmt[1] = '.';
+    i = 2;
+    if (d1) {
+        fmt[i++] = '0' + d1;
+    }
+    fmt[i++] = '0' + d2;
+    fmt[i++] = 'g';
+    fmt[i] = 0;
+}
+
+/* Assumes there is always at least 32 characters available in the target buffer */
+int fpconv_g_fmt(char *str, double num, int precision)
+{
+    char buf[FPCONV_G_FMT_BUFSIZE];
+    char fmt[6];
+    int len;
+    char *b;
+
+    set_number_format(fmt, precision);
+
+    /* Pass through when decimal point character is dot. */
+    if (locale_decimal_point == '.')
+        return snprintf(str, FPCONV_G_FMT_BUFSIZE, fmt, num);
+
+    /* snprintf() to a buffer then translate for other decimal point characters */
+    len = snprintf(buf, FPCONV_G_FMT_BUFSIZE, fmt, num);
+
+    /* Copy into target location. Translate decimal point if required */
+    b = buf;
+    do {
+        *str++ = (*b == locale_decimal_point ? '.' : *b);
+    } while(*b++);
+
+    return len;
+}
+
+void fpconv_init()
+{
+    fpconv_update_locale();
+}
+
+/* vi:ai et sw=4 ts=4:
+ */
diff --git a/scripting/lua/cjson/fpconv.h b/scripting/lua/cjson/fpconv.h
new file mode 100755
index 0000000..90ef5b3
--- /dev/null
+++ b/scripting/lua/cjson/fpconv.h
@@ -0,0 +1,22 @@
+/* Lua CJSON floating point conversion routines */
+
+/* Buffer required to store the largest string representation of a double.
+ *
+ * Longest double printed with %.14g is 21 characters long:
+ * -1.7976931348623e+308 */
+# define FPCONV_G_FMT_BUFSIZE   32
+
+#ifdef USE_INTERNAL_FPCONV
+static void fpconv_init()
+{
+    /* Do nothing - not required */
+}
+#else
+extern void fpconv_init();
+#endif
+
+extern int fpconv_g_fmt(char*, double, int);
+extern double fpconv_strtod(const char*, char**);
+
+/* vi:ai et sw=4 ts=4:
+ */
diff --git a/scripting/lua/cjson/lua_cjson.c b/scripting/lua/cjson/lua_cjson.c
new file mode 100755
index 0000000..a17a086
--- /dev/null
+++ b/scripting/lua/cjson/lua_cjson.c
@@ -0,0 +1,1428 @@
+/* Lua CJSON - JSON support for Lua
+ *
+ * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/* Caveats:
+ * - JSON "null" values are represented as lightuserdata since Lua
+ *   tables cannot contain "nil". Compare with cjson.null.
+ * - Invalid UTF-8 characters are not detected and will be passed
+ *   untouched. If required, UTF-8 error checking should be done
+ *   outside this library.
+ * - Javascript comments are not part of the JSON spec, and are not
+ *   currently supported.
+ *
+ * Note: Decoding is slower than encoding. Lua spends significant
+ *       time (30%) managing tables when parsing JSON since it is
+ *       difficult to know object/array sizes ahead of time.
+ */
+
+#include <assert.h>
+#include <string.h>
+#include <math.h>
+#include <limits.h>
+#include "lua.h"
+#include "lauxlib.h"
+#include "lua_cjson.h"
+
+#include "strbuf.h"
+#include "fpconv.h"
+
+#ifndef CJSON_MODNAME
+#define CJSON_MODNAME   "cjson"
+#endif
+
+#ifndef CJSON_VERSION
+#define CJSON_VERSION   "2.1.0"
+#endif
+
+/* Workaround for Solaris platforms missing isinf() */
+#if !defined(isinf) && (defined(USE_INTERNAL_ISINF) || defined(MISSING_ISINF))
+#define isinf(x) (!isnan(x) && isnan((x) - (x)))
+#endif
+
+#define DEFAULT_SPARSE_CONVERT 0
+#define DEFAULT_SPARSE_RATIO 2
+#define DEFAULT_SPARSE_SAFE 10
+#define DEFAULT_ENCODE_MAX_DEPTH 1000
+#define DEFAULT_DECODE_MAX_DEPTH 1000
+#define DEFAULT_ENCODE_INVALID_NUMBERS 0
+#define DEFAULT_DECODE_INVALID_NUMBERS 1
+#define DEFAULT_ENCODE_KEEP_BUFFER 1
+#define DEFAULT_ENCODE_NUMBER_PRECISION 14
+
+#ifdef DISABLE_INVALID_NUMBERS
+#undef DEFAULT_DECODE_INVALID_NUMBERS
+#define DEFAULT_DECODE_INVALID_NUMBERS 0
+#endif
+
+typedef enum {
+    T_OBJ_BEGIN,
+    T_OBJ_END,
+    T_ARR_BEGIN,
+    T_ARR_END,
+    T_STRING,
+    T_NUMBER,
+    T_BOOLEAN,
+    T_NULL,
+    T_COLON,
+    T_COMMA,
+    T_END,
+    T_WHITESPACE,
+    T_ERROR,
+    T_UNKNOWN
+} json_token_type_t;
+
+static const char *json_token_type_name[] = {
+    "T_OBJ_BEGIN",
+    "T_OBJ_END",
+    "T_ARR_BEGIN",
+    "T_ARR_END",
+    "T_STRING",
+    "T_NUMBER",
+    "T_BOOLEAN",
+    "T_NULL",
+    "T_COLON",
+    "T_COMMA",
+    "T_END",
+    "T_WHITESPACE",
+    "T_ERROR",
+    "T_UNKNOWN",
+    NULL
+};
+
+typedef struct {
+    json_token_type_t ch2token[256];
+    char escape2char[256];  /* Decoding */
+
+    /* encode_buf is only allocated and used when
+     * encode_keep_buffer is set */
+    strbuf_t encode_buf;
+
+    int encode_sparse_convert;
+    int encode_sparse_ratio;
+    int encode_sparse_safe;
+    int encode_max_depth;
+    int encode_invalid_numbers;     /* 2 => Encode as "null" */
+    int encode_number_precision;
+    int encode_keep_buffer;
+
+    int decode_invalid_numbers;
+    int decode_max_depth;
+} json_config_t;
+
+typedef struct {
+    const char *data;
+    const char *ptr;
+    strbuf_t *tmp;    /* Temporary storage for strings */
+    json_config_t *cfg;
+    int current_depth;
+} json_parse_t;
+
+typedef struct {
+    json_token_type_t type;
+    int index;
+    union {
+        const char *string;
+        double number;
+        int boolean;
+    } value;
+    int string_len;
+} json_token_t;
+
+static const char *char2escape[256] = {
+    "\\u0000", "\\u0001", "\\u0002", "\\u0003",
+    "\\u0004", "\\u0005", "\\u0006", "\\u0007",
+    "\\b", "\\t", "\\n", "\\u000b",
+    "\\f", "\\r", "\\u000e", "\\u000f",
+    "\\u0010", "\\u0011", "\\u0012", "\\u0013",
+    "\\u0014", "\\u0015", "\\u0016", "\\u0017",
+    "\\u0018", "\\u0019", "\\u001a", "\\u001b",
+    "\\u001c", "\\u001d", "\\u001e", "\\u001f",
+    NULL, NULL, "\\\"", NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, "\\/",
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, "\\\\", NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, "\\u007f",
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+};
+
+/* ===== CONFIGURATION ===== */
+
+static json_config_t *json_fetch_config(lua_State *l)
+{
+    json_config_t *cfg;
+
+    cfg = lua_touserdata(l, lua_upvalueindex(1));
+    if (!cfg)
+        luaL_error(l, "BUG: Unable to fetch CJSON configuration");
+
+    return cfg;
+}
+
+/* Ensure the correct number of arguments have been provided.
+ * Pad with nil to allow other functions to simply check arg[i]
+ * to find whether an argument was provided */
+static json_config_t *json_arg_init(lua_State *l, int args)
+{
+    luaL_argcheck(l, lua_gettop(l) <= args, args + 1,
+                  "found too many arguments");
+
+    while (lua_gettop(l) < args)
+        lua_pushnil(l);
+
+    return json_fetch_config(l);
+}
+
+/* Process integer options for configuration functions */
+static int json_integer_option(lua_State *l, int optindex, int *setting,
+                               int min, int max)
+{
+    char errmsg[64];
+    int value;
+
+    if (!lua_isnil(l, optindex)) {
+        value = luaL_checkinteger(l, optindex);
+#ifndef WIN32
+		snprintf(errmsg, sizeof(errmsg), "expected integer between %d and %d", min, max);
+#endif // !WIN32
+        luaL_argcheck(l, min <= value && value <= max, 1, errmsg);
+        *setting = value;
+    }
+
+    lua_pushinteger(l, *setting);
+
+    return 1;
+}
+
+/* Process enumerated arguments for a configuration function */
+static int json_enum_option(lua_State *l, int optindex, int *setting,
+                            const char **options, int bool_true)
+{
+    static const char *bool_options[] = { "off", "on", NULL };
+
+    if (!options) {
+        options = bool_options;
+        bool_true = 1;
+    }
+
+    if (!lua_isnil(l, optindex)) {
+        if (bool_true && lua_isboolean(l, optindex))
+            *setting = lua_toboolean(l, optindex) * bool_true;
+        else
+            *setting = luaL_checkoption(l, optindex, NULL, options);
+    }
+
+    if (bool_true && (*setting == 0 || *setting == bool_true))
+        lua_pushboolean(l, *setting);
+    else
+        lua_pushstring(l, options[*setting]);
+
+    return 1;
+}
+
+/* Configures handling of extremely sparse arrays:
+ * convert: Convert extremely sparse arrays into objects? Otherwise error.
+ * ratio: 0: always allow sparse; 1: never allow sparse; >1: use ratio
+ * safe: Always use an array when the max index <= safe */
+static int json_cfg_encode_sparse_array(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 3);
+
+    json_enum_option(l, 1, &cfg->encode_sparse_convert, NULL, 1);
+    json_integer_option(l, 2, &cfg->encode_sparse_ratio, 0, INT_MAX);
+    json_integer_option(l, 3, &cfg->encode_sparse_safe, 0, INT_MAX);
+
+    return 3;
+}
+
+/* Configures the maximum number of nested arrays/objects allowed when
+ * encoding */
+static int json_cfg_encode_max_depth(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 1);
+
+    return json_integer_option(l, 1, &cfg->encode_max_depth, 1, INT_MAX);
+}
+
+/* Configures the maximum number of nested arrays/objects allowed when
+ * encoding */
+static int json_cfg_decode_max_depth(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 1);
+
+    return json_integer_option(l, 1, &cfg->decode_max_depth, 1, INT_MAX);
+}
+
+/* Configures number precision when converting doubles to text */
+static int json_cfg_encode_number_precision(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 1);
+
+    return json_integer_option(l, 1, &cfg->encode_number_precision, 1, 14);
+}
+
+/* Configures JSON encoding buffer persistence */
+static int json_cfg_encode_keep_buffer(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 1);
+    int old_value;
+
+    old_value = cfg->encode_keep_buffer;
+
+    json_enum_option(l, 1, &cfg->encode_keep_buffer, NULL, 1);
+
+    /* Init / free the buffer if the setting has changed */
+    if (old_value ^ cfg->encode_keep_buffer) {
+        if (cfg->encode_keep_buffer)
+            strbuf_init(&cfg->encode_buf, 0);
+        else
+            strbuf_free(&cfg->encode_buf);
+    }
+
+    return 1;
+}
+
+#if defined(DISABLE_INVALID_NUMBERS) && !defined(USE_INTERNAL_FPCONV)
+void json_verify_invalid_number_setting(lua_State *l, int *setting)
+{
+    if (*setting == 1) {
+        *setting = 0;
+        luaL_error(l, "Infinity, NaN, and/or hexadecimal numbers are not supported.");
+    }
+}
+#else
+#define json_verify_invalid_number_setting(l, s)    do { } while(0)
+#endif
+
+static int json_cfg_encode_invalid_numbers(lua_State *l)
+{
+    static const char *options[] = { "off", "on", "null", NULL };
+    json_config_t *cfg = json_arg_init(l, 1);
+
+    json_enum_option(l, 1, &cfg->encode_invalid_numbers, options, 1);
+
+    json_verify_invalid_number_setting(l, &cfg->encode_invalid_numbers);
+
+    return 1;
+}
+
+static int json_cfg_decode_invalid_numbers(lua_State *l)
+{
+    json_config_t *cfg = json_arg_init(l, 1);
+
+    json_enum_option(l, 1, &cfg->decode_invalid_numbers, NULL, 1);
+
+    json_verify_invalid_number_setting(l, &cfg->encode_invalid_numbers);
+
+    return 1;
+}
+
+static int json_destroy_config(lua_State *l)
+{
+    json_config_t *cfg;
+
+    cfg = lua_touserdata(l, 1);
+    if (cfg)
+        strbuf_free(&cfg->encode_buf);
+    cfg = NULL;
+
+    return 0;
+}
+
+static void json_create_config(lua_State *l)
+{
+    json_config_t *cfg;
+    int i;
+
+    cfg = lua_newuserdata(l, sizeof(*cfg));
+
+    /* Create GC method to clean up strbuf */
+    lua_newtable(l);
+    lua_pushcfunction(l, json_destroy_config);
+    lua_setfield(l, -2, "__gc");
+    lua_setmetatable(l, -2);
+
+    cfg->encode_sparse_convert = DEFAULT_SPARSE_CONVERT;
+    cfg->encode_sparse_ratio = DEFAULT_SPARSE_RATIO;
+    cfg->encode_sparse_safe = DEFAULT_SPARSE_SAFE;
+    cfg->encode_max_depth = DEFAULT_ENCODE_MAX_DEPTH;
+    cfg->decode_max_depth = DEFAULT_DECODE_MAX_DEPTH;
+    cfg->encode_invalid_numbers = DEFAULT_ENCODE_INVALID_NUMBERS;
+    cfg->decode_invalid_numbers = DEFAULT_DECODE_INVALID_NUMBERS;
+    cfg->encode_keep_buffer = DEFAULT_ENCODE_KEEP_BUFFER;
+    cfg->encode_number_precision = DEFAULT_ENCODE_NUMBER_PRECISION;
+
+#if DEFAULT_ENCODE_KEEP_BUFFER > 0
+    strbuf_init(&cfg->encode_buf, 0);
+#endif
+
+    /* Decoding init */
+
+    /* Tag all characters as an error */
+    for (i = 0; i < 256; i++)
+        cfg->ch2token[i] = T_ERROR;
+
+    /* Set tokens that require no further processing */
+    cfg->ch2token['{'] = T_OBJ_BEGIN;
+    cfg->ch2token['}'] = T_OBJ_END;
+    cfg->ch2token['['] = T_ARR_BEGIN;
+    cfg->ch2token[']'] = T_ARR_END;
+    cfg->ch2token[','] = T_COMMA;
+    cfg->ch2token[':'] = T_COLON;
+    cfg->ch2token['\0'] = T_END;
+    cfg->ch2token[' '] = T_WHITESPACE;
+    cfg->ch2token['\t'] = T_WHITESPACE;
+    cfg->ch2token['\n'] = T_WHITESPACE;
+    cfg->ch2token['\r'] = T_WHITESPACE;
+
+    /* Update characters that require further processing */
+    cfg->ch2token['f'] = T_UNKNOWN;     /* false? */
+    cfg->ch2token['i'] = T_UNKNOWN;     /* inf, ininity? */
+    cfg->ch2token['I'] = T_UNKNOWN;
+    cfg->ch2token['n'] = T_UNKNOWN;     /* null, nan? */
+    cfg->ch2token['N'] = T_UNKNOWN;
+    cfg->ch2token['t'] = T_UNKNOWN;     /* true? */
+    cfg->ch2token['"'] = T_UNKNOWN;     /* string? */
+    cfg->ch2token['+'] = T_UNKNOWN;     /* number? */
+    cfg->ch2token['-'] = T_UNKNOWN;
+    for (i = 0; i < 10; i++)
+        cfg->ch2token['0' + i] = T_UNKNOWN;
+
+    /* Lookup table for parsing escape characters */
+    for (i = 0; i < 256; i++)
+        cfg->escape2char[i] = 0;          /* String error */
+    cfg->escape2char['"'] = '"';
+    cfg->escape2char['\\'] = '\\';
+    cfg->escape2char['/'] = '/';
+    cfg->escape2char['b'] = '\b';
+    cfg->escape2char['t'] = '\t';
+    cfg->escape2char['n'] = '\n';
+    cfg->escape2char['f'] = '\f';
+    cfg->escape2char['r'] = '\r';
+    cfg->escape2char['u'] = 'u';          /* Unicode parsing required */
+}
+
+/* ===== ENCODING ===== */
+
+static void json_encode_exception(lua_State *l, json_config_t *cfg, strbuf_t *json, int lindex,
+                                  const char *reason)
+{
+    if (!cfg->encode_keep_buffer)
+        strbuf_free(json);
+    luaL_error(l, "Cannot serialise %s: %s",
+                  lua_typename(l, lua_type(l, lindex)), reason);
+}
+
+/* json_append_string args:
+ * - lua_State
+ * - JSON strbuf
+ * - String (Lua stack index)
+ *
+ * Returns nothing. Doesn't remove string from Lua stack */
+static void json_append_string(lua_State *l, strbuf_t *json, int lindex)
+{
+    const char *escstr;
+    int i;
+    const char *str;
+    size_t len;
+
+    str = lua_tolstring(l, lindex, &len);
+
+    /* Worst case is len * 6 (all unicode escapes).
+     * This buffer is reused constantly for small strings
+     * If there are any excess pages, they won't be hit anyway.
+     * This gains ~5% speedup. */
+    strbuf_ensure_empty_length(json, len * 6 + 2);
+
+    strbuf_append_char_unsafe(json, '\"');
+    for (i = 0; i < len; i++) {
+        escstr = char2escape[(unsigned char)str[i]];
+        if (escstr)
+            strbuf_append_string(json, escstr);
+        else
+            strbuf_append_char_unsafe(json, str[i]);
+    }
+    strbuf_append_char_unsafe(json, '\"');
+}
+
+/* Find the size of the array on the top of the Lua stack
+ * -1   object (not a pure array)
+ * >=0  elements in array
+ */
+static int lua_array_length(lua_State *l, json_config_t *cfg, strbuf_t *json)
+{
+    double k;
+    int max;
+    int items;
+
+    max = 0;
+    items = 0;
+
+    lua_pushnil(l);
+    /* table, startkey */
+    while (lua_next(l, -2) != 0) {
+        /* table, key, value */
+        if (lua_type(l, -2) == LUA_TNUMBER &&
+            (k = lua_tonumber(l, -2))) {
+            /* Integer >= 1 ? */
+            if (floor(k) == k && k >= 1) {
+                if (k > max)
+                    max = k;
+                items++;
+                lua_pop(l, 1);
+                continue;
+            }
+        }
+
+        /* Must not be an array (non integer key) */
+        lua_pop(l, 2);
+        return -1;
+    }
+
+    /* Encode excessively sparse arrays as objects (if enabled) */
+    if (cfg->encode_sparse_ratio > 0 &&
+        max > items * cfg->encode_sparse_ratio &&
+        max > cfg->encode_sparse_safe) {
+        if (!cfg->encode_sparse_convert)
+            json_encode_exception(l, cfg, json, -1, "excessively sparse array");
+
+        return -1;
+    }
+
+    return max;
+}
+
+static void json_check_encode_depth(lua_State *l, json_config_t *cfg,
+                                    int current_depth, strbuf_t *json)
+{
+    /* Ensure there are enough slots free to traverse a table (key,
+     * value) and push a string for a potential error message.
+     *
+     * Unlike "decode", the key and value are still on the stack when
+     * lua_checkstack() is called.  Hence an extra slot for luaL_error()
+     * below is required just in case the next check to lua_checkstack()
+     * fails.
+     *
+     * While this won't cause a crash due to the EXTRA_STACK reserve
+     * slots, it would still be an improper use of the API. */
+    if (current_depth <= cfg->encode_max_depth && lua_checkstack(l, 3))
+        return;
+
+    if (!cfg->encode_keep_buffer)
+        strbuf_free(json);
+
+    luaL_error(l, "Cannot serialise, excessive nesting (%d)",
+               current_depth);
+}
+
+static void json_append_data(lua_State *l, json_config_t *cfg,
+                             int current_depth, strbuf_t *json);
+
+/* json_append_array args:
+ * - lua_State
+ * - JSON strbuf
+ * - Size of passwd Lua array (top of stack) */
+static void json_append_array(lua_State *l, json_config_t *cfg, int current_depth,
+                              strbuf_t *json, int array_length)
+{
+    int comma, i;
+
+    strbuf_append_char(json, '[');
+
+    comma = 0;
+    for (i = 1; i <= array_length; i++) {
+        if (comma)
+            strbuf_append_char(json, ',');
+        else
+            comma = 1;
+
+        lua_rawgeti(l, -1, i);
+        json_append_data(l, cfg, current_depth, json);
+        lua_pop(l, 1);
+    }
+
+    strbuf_append_char(json, ']');
+}
+
+static void json_append_number(lua_State *l, json_config_t *cfg,
+                               strbuf_t *json, int lindex)
+{
+    double num = lua_tonumber(l, lindex);
+    int len;
+
+    if (cfg->encode_invalid_numbers == 0) {
+        /* Prevent encoding invalid numbers */
+        if (isinf(num) || isnan(num))
+            json_encode_exception(l, cfg, json, lindex, "must not be NaN or Inf");
+    } else if (cfg->encode_invalid_numbers == 1) {
+        /* Encode invalid numbers, but handle "nan" separately
+         * since some platforms may encode as "-nan". */
+        if (isnan(num)) {
+            strbuf_append_mem(json, "nan", 3);
+            return;
+        }
+    } else {
+        /* Encode invalid numbers as "null" */
+        if (isinf(num) || isnan(num)) {
+            strbuf_append_mem(json, "null", 4);
+            return;
+        }
+    }
+
+    strbuf_ensure_empty_length(json, FPCONV_G_FMT_BUFSIZE);
+    len = fpconv_g_fmt(strbuf_empty_ptr(json), num, cfg->encode_number_precision);
+    strbuf_extend_length(json, len);
+}
+
+static void json_append_object(lua_State *l, json_config_t *cfg,
+                               int current_depth, strbuf_t *json)
+{
+    int comma, keytype;
+
+    /* Object */
+    strbuf_append_char(json, '{');
+
+    lua_pushnil(l);
+    /* table, startkey */
+    comma = 0;
+    while (lua_next(l, -2) != 0) {
+        if (comma)
+            strbuf_append_char(json, ',');
+        else
+            comma = 1;
+
+        /* table, key, value */
+        keytype = lua_type(l, -2);
+        if (keytype == LUA_TNUMBER) {
+            strbuf_append_char(json, '"');
+            json_append_number(l, cfg, json, -2);
+            strbuf_append_mem(json, "\":", 2);
+        } else if (keytype == LUA_TSTRING) {
+            json_append_string(l, json, -2);
+            strbuf_append_char(json, ':');
+        } else {
+            json_encode_exception(l, cfg, json, -2,
+                                  "table key must be a number or string");
+            /* never returns */
+        }
+
+        /* table, key, value */
+        json_append_data(l, cfg, current_depth, json);
+        lua_pop(l, 1);
+        /* table, key */
+    }
+
+    strbuf_append_char(json, '}');
+}
+
+/* Serialise Lua data into JSON string. */
+static void json_append_data(lua_State *l, json_config_t *cfg,
+                             int current_depth, strbuf_t *json)
+{
+    int len;
+
+    switch (lua_type(l, -1)) {
+    case LUA_TSTRING:
+        json_append_string(l, json, -1);
+        break;
+    case LUA_TNUMBER:
+        json_append_number(l, cfg, json, -1);
+        break;
+    case LUA_TBOOLEAN:
+        if (lua_toboolean(l, -1))
+            strbuf_append_mem(json, "true", 4);
+        else
+            strbuf_append_mem(json, "false", 5);
+        break;
+    case LUA_TTABLE:
+        current_depth++;
+        json_check_encode_depth(l, cfg, current_depth, json);
+        len = lua_array_length(l, cfg, json);
+        if (len > 0)
+            json_append_array(l, cfg, current_depth, json, len);
+        else
+            json_append_object(l, cfg, current_depth, json);
+        break;
+    case LUA_TNIL:
+        strbuf_append_mem(json, "null", 4);
+        break;
+    case LUA_TLIGHTUSERDATA:
+        if (lua_touserdata(l, -1) == NULL) {
+            strbuf_append_mem(json, "null", 4);
+            break;
+        }
+    default:
+        /* Remaining types (LUA_TFUNCTION, LUA_TUSERDATA, LUA_TTHREAD,
+         * and LUA_TLIGHTUSERDATA) cannot be serialised */
+        json_encode_exception(l, cfg, json, -1, "type not supported");
+        /* never returns */
+    }
+}
+
+static int json_encode(lua_State *l)
+{
+    json_config_t *cfg = json_fetch_config(l);
+    strbuf_t local_encode_buf;
+    strbuf_t *encode_buf;
+    char *json;
+    int len;
+
+    luaL_argcheck(l, lua_gettop(l) == 1, 1, "expected 1 argument");
+
+    if (!cfg->encode_keep_buffer) {
+        /* Use private buffer */
+        encode_buf = &local_encode_buf;
+        strbuf_init(encode_buf, 0);
+    } else {
+        /* Reuse existing buffer */
+        encode_buf = &cfg->encode_buf;
+        strbuf_reset(encode_buf);
+    }
+
+    json_append_data(l, cfg, 0, encode_buf);
+    json = strbuf_string(encode_buf, &len);
+
+    lua_pushlstring(l, json, len);
+
+    if (!cfg->encode_keep_buffer)
+        strbuf_free(encode_buf);
+
+    return 1;
+}
+
+/* ===== DECODING ===== */
+
+static void json_process_value(lua_State *l, json_parse_t *json,
+                               json_token_t *token);
+
+static int hexdigit2int(char hex)
+{
+    if ('0' <= hex  && hex <= '9')
+        return hex - '0';
+
+    /* Force lowercase */
+    hex |= 0x20;
+    if ('a' <= hex && hex <= 'f')
+        return 10 + hex - 'a';
+
+    return -1;
+}
+
+static int decode_hex4(const char *hex)
+{
+    int digit[4];
+    int i;
+
+    /* Convert ASCII hex digit to numeric digit
+     * Note: this returns an error for invalid hex digits, including
+     *       NULL */
+    for (i = 0; i < 4; i++) {
+        digit[i] = hexdigit2int(hex[i]);
+        if (digit[i] < 0) {
+            return -1;
+        }
+    }
+
+    return (digit[0] << 12) +
+           (digit[1] << 8) +
+           (digit[2] << 4) +
+            digit[3];
+}
+
+/* Converts a Unicode codepoint to UTF-8.
+ * Returns UTF-8 string length, and up to 4 bytes in *utf8 */
+static int codepoint_to_utf8(char *utf8, int codepoint)
+{
+    /* 0xxxxxxx */
+    if (codepoint <= 0x7F) {
+        utf8[0] = codepoint;
+        return 1;
+    }
+
+    /* 110xxxxx 10xxxxxx */
+    if (codepoint <= 0x7FF) {
+        utf8[0] = (codepoint >> 6) | 0xC0;
+        utf8[1] = (codepoint & 0x3F) | 0x80;
+        return 2;
+    }
+
+    /* 1110xxxx 10xxxxxx 10xxxxxx */
+    if (codepoint <= 0xFFFF) {
+        utf8[0] = (codepoint >> 12) | 0xE0;
+        utf8[1] = ((codepoint >> 6) & 0x3F) | 0x80;
+        utf8[2] = (codepoint & 0x3F) | 0x80;
+        return 3;
+    }
+
+    /* 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
+    if (codepoint <= 0x1FFFFF) {
+        utf8[0] = (codepoint >> 18) | 0xF0;
+        utf8[1] = ((codepoint >> 12) & 0x3F) | 0x80;
+        utf8[2] = ((codepoint >> 6) & 0x3F) | 0x80;
+        utf8[3] = (codepoint & 0x3F) | 0x80;
+        return 4;
+    }
+
+    return 0;
+}
+
+
+/* Called when index pointing to beginning of UTF-16 code escape: \uXXXX
+ * \u is guaranteed to exist, but the remaining hex characters may be
+ * missing.
+ * Translate to UTF-8 and append to temporary token string.
+ * Must advance index to the next character to be processed.
+ * Returns: 0   success
+ *          -1  error
+ */
+static int json_append_unicode_escape(json_parse_t *json)
+{
+    char utf8[4];       /* Surrogate pairs require 4 UTF-8 bytes */
+    int codepoint;
+    int surrogate_low;
+    int len;
+    int escape_len = 6;
+
+    /* Fetch UTF-16 code unit */
+    codepoint = decode_hex4(json->ptr + 2);
+    if (codepoint < 0)
+        return -1;
+
+    /* UTF-16 surrogate pairs take the following 2 byte form:
+     *      11011 x yyyyyyyyyy
+     * When x = 0: y is the high 10 bits of the codepoint
+     *      x = 1: y is the low 10 bits of the codepoint
+     *
+     * Check for a surrogate pair (high or low) */
+    if ((codepoint & 0xF800) == 0xD800) {
+        /* Error if the 1st surrogate is not high */
+        if (codepoint & 0x400)
+            return -1;
+
+        /* Ensure the next code is a unicode escape */
+        if (*(json->ptr + escape_len) != '\\' ||
+            *(json->ptr + escape_len + 1) != 'u') {
+            return -1;
+        }
+
+        /* Fetch the next codepoint */
+        surrogate_low = decode_hex4(json->ptr + 2 + escape_len);
+        if (surrogate_low < 0)
+            return -1;
+
+        /* Error if the 2nd code is not a low surrogate */
+        if ((surrogate_low & 0xFC00) != 0xDC00)
+            return -1;
+
+        /* Calculate Unicode codepoint */
+        codepoint = (codepoint & 0x3FF) << 10;
+        surrogate_low &= 0x3FF;
+        codepoint = (codepoint | surrogate_low) + 0x10000;
+        escape_len = 12;
+    }
+
+    /* Convert codepoint to UTF-8 */
+    len = codepoint_to_utf8(utf8, codepoint);
+    if (!len)
+        return -1;
+
+    /* Append bytes and advance parse index */
+    strbuf_append_mem_unsafe(json->tmp, utf8, len);
+    json->ptr += escape_len;
+
+    return 0;
+}
+
+static void json_set_token_error(json_token_t *token, json_parse_t *json,
+                                 const char *errtype)
+{
+    token->type = T_ERROR;
+    token->index = json->ptr - json->data;
+    token->value.string = errtype;
+}
+
+static void json_next_string_token(json_parse_t *json, json_token_t *token)
+{
+    char *escape2char = json->cfg->escape2char;
+    char ch;
+
+    /* Caller must ensure a string is next */
+    assert(*json->ptr == '"');
+
+    /* Skip " */
+    json->ptr++;
+
+    /* json->tmp is the temporary strbuf used to accumulate the
+     * decoded string value.
+     * json->tmp is sized to handle JSON containing only a string value.
+     */
+    strbuf_reset(json->tmp);
+
+    while ((ch = *json->ptr) != '"') {
+        if (!ch) {
+            /* Premature end of the string */
+            json_set_token_error(token, json, "unexpected end of string");
+            return;
+        }
+
+        /* Handle escapes */
+        if (ch == '\\') {
+            /* Fetch escape character */
+            ch = *(json->ptr + 1);
+
+            /* Translate escape code and append to tmp string */
+            ch = escape2char[(unsigned char)ch];
+            if (ch == 'u') {
+                if (json_append_unicode_escape(json) == 0)
+                    continue;
+
+                json_set_token_error(token, json,
+                                     "invalid unicode escape code");
+                return;
+            }
+            if (!ch) {
+                json_set_token_error(token, json, "invalid escape code");
+                return;
+            }
+
+            /* Skip '\' */
+            json->ptr++;
+        }
+        /* Append normal character or translated single character
+         * Unicode escapes are handled above */
+        strbuf_append_char_unsafe(json->tmp, ch);
+        json->ptr++;
+    }
+    json->ptr++;    /* Eat final quote (") */
+
+    strbuf_ensure_null(json->tmp);
+
+    token->type = T_STRING;
+    token->value.string = strbuf_string(json->tmp, &token->string_len);
+}
+
+/* JSON numbers should take the following form:
+ *      -?(0|[1-9]|[1-9][0-9]+)(.[0-9]+)?([eE][-+]?[0-9]+)?
+ *
+ * json_next_number_token() uses strtod() which allows other forms:
+ * - numbers starting with '+'
+ * - NaN, -NaN, infinity, -infinity
+ * - hexadecimal numbers
+ * - numbers with leading zeros
+ *
+ * json_is_invalid_number() detects "numbers" which may pass strtod()'s
+ * error checking, but should not be allowed with strict JSON.
+ *
+ * json_is_invalid_number() may pass numbers which cause strtod()
+ * to generate an error.
+ */
+static int json_is_invalid_number(json_parse_t *json)
+{
+    const char *p = json->ptr;
+
+    /* Reject numbers starting with + */
+    if (*p == '+')
+        return 1;
+
+    /* Skip minus sign if it exists */
+    if (*p == '-')
+        p++;
+
+    /* Reject numbers starting with 0x, or leading zeros */
+    if (*p == '0') {
+        int ch2 = *(p + 1);
+
+        if ((ch2 | 0x20) == 'x' ||          /* Hex */
+            ('0' <= ch2 && ch2 <= '9'))     /* Leading zero */
+            return 1;
+
+        return 0;
+    } else if (*p <= '9') {
+        return 0;                           /* Ordinary number */
+    }
+
+#ifndef WIN32
+    /* Reject inf/nan */
+    if (!strncasecmp(p, "inf", 3))
+        return 1;
+    if (!strncasecmp(p, "nan", 3))
+        return 1;
+#endif
+
+    /* Pass all other numbers which may still be invalid, but
+     * strtod() will catch them. */
+    return 0;
+}
+
+static void json_next_number_token(json_parse_t *json, json_token_t *token)
+{
+    char *endptr;
+
+    token->type = T_NUMBER;
+    token->value.number = fpconv_strtod(json->ptr, &endptr);
+    if (json->ptr == endptr)
+        json_set_token_error(token, json, "invalid number");
+    else
+        json->ptr = endptr;     /* Skip the processed number */
+
+    return;
+}
+
+/* Fills in the token struct.
+ * T_STRING will return a pointer to the json_parse_t temporary string
+ * T_ERROR will leave the json->ptr pointer at the error.
+ */
+static void json_next_token(json_parse_t *json, json_token_t *token)
+{
+    const json_token_type_t *ch2token = json->cfg->ch2token;
+    int ch;
+
+    /* Eat whitespace. */
+    while (1) {
+        ch = (unsigned char)*(json->ptr);
+        token->type = ch2token[ch];
+        if (token->type != T_WHITESPACE)
+            break;
+        json->ptr++;
+    }
+
+    /* Store location of new token. Required when throwing errors
+     * for unexpected tokens (syntax errors). */
+    token->index = json->ptr - json->data;
+
+    /* Don't advance the pointer for an error or the end */
+    if (token->type == T_ERROR) {
+        json_set_token_error(token, json, "invalid token");
+        return;
+    }
+
+    if (token->type == T_END) {
+        return;
+    }
+
+    /* Found a known single character token, advance index and return */
+    if (token->type != T_UNKNOWN) {
+        json->ptr++;
+        return;
+    }
+
+    /* Process characters which triggered T_UNKNOWN
+     *
+     * Must use strncmp() to match the front of the JSON string.
+     * JSON identifier must be lowercase.
+     * When strict_numbers if disabled, either case is allowed for
+     * Infinity/NaN (since we are no longer following the spec..) */
+    if (ch == '"') {
+        json_next_string_token(json, token);
+        return;
+    } else if (ch == '-' || ('0' <= ch && ch <= '9')) {
+        if (!json->cfg->decode_invalid_numbers && json_is_invalid_number(json)) {
+            json_set_token_error(token, json, "invalid number");
+            return;
+        }
+        json_next_number_token(json, token);
+        return;
+    } else if (!strncmp(json->ptr, "true", 4)) {
+        token->type = T_BOOLEAN;
+        token->value.boolean = 1;
+        json->ptr += 4;
+        return;
+    } else if (!strncmp(json->ptr, "false", 5)) {
+        token->type = T_BOOLEAN;
+        token->value.boolean = 0;
+        json->ptr += 5;
+        return;
+    } else if (!strncmp(json->ptr, "null", 4)) {
+        token->type = T_NULL;
+        json->ptr += 4;
+        return;
+    } else if (json->cfg->decode_invalid_numbers &&
+               json_is_invalid_number(json)) {
+        /* When decode_invalid_numbers is enabled, only attempt to process
+         * numbers we know are invalid JSON (Inf, NaN, hex)
+         * This is required to generate an appropriate token error,
+         * otherwise all bad tokens will register as "invalid number"
+         */
+        json_next_number_token(json, token);
+        return;
+    }
+
+    /* Token starts with t/f/n but isn't recognised above. */
+    json_set_token_error(token, json, "invalid token");
+}
+
+/* This function does not return.
+ * DO NOT CALL WITH DYNAMIC MEMORY ALLOCATED.
+ * The only supported exception is the temporary parser string
+ * json->tmp struct.
+ * json and token should exist on the stack somewhere.
+ * luaL_error() will long_jmp and release the stack */
+static void json_throw_parse_error(lua_State *l, json_parse_t *json,
+                                   const char *exp, json_token_t *token)
+{
+    const char *found;
+
+    strbuf_free(json->tmp);
+
+    if (token->type == T_ERROR)
+        found = token->value.string;
+    else
+        found = json_token_type_name[token->type];
+
+    /* Note: token->index is 0 based, display starting from 1 */
+    luaL_error(l, "Expected %s but found %s at character %d",
+               exp, found, token->index + 1);
+}
+
+static void json_decode_ascend(json_parse_t *json)
+{
+    json->current_depth--;
+}
+
+static void json_decode_descend(lua_State *l, json_parse_t *json, int slots)
+{
+    json->current_depth++;
+
+    if (json->current_depth <= json->cfg->decode_max_depth &&
+        lua_checkstack(l, slots)) {
+        return;
+    }
+
+    strbuf_free(json->tmp);
+    luaL_error(l, "Found too many nested data structures (%d) at character %d",
+        json->current_depth, json->ptr - json->data);
+}
+
+static void json_parse_object_context(lua_State *l, json_parse_t *json)
+{
+    json_token_t token;
+
+    /* 3 slots required:
+     * .., table, key, value */
+    json_decode_descend(l, json, 3);
+
+    lua_newtable(l);
+
+    json_next_token(json, &token);
+
+    /* Handle empty objects */
+    if (token.type == T_OBJ_END) {
+        json_decode_ascend(json);
+        return;
+    }
+
+    while (1) {
+        if (token.type != T_STRING)
+            json_throw_parse_error(l, json, "object key string", &token);
+
+        /* Push key */
+        lua_pushlstring(l, token.value.string, token.string_len);
+
+        json_next_token(json, &token);
+        if (token.type != T_COLON)
+            json_throw_parse_error(l, json, "colon", &token);
+
+        /* Fetch value */
+        json_next_token(json, &token);
+        json_process_value(l, json, &token);
+
+        /* Set key = value */
+        lua_rawset(l, -3);
+
+        json_next_token(json, &token);
+
+        if (token.type == T_OBJ_END) {
+            json_decode_ascend(json);
+            return;
+        }
+
+        if (token.type != T_COMMA)
+            json_throw_parse_error(l, json, "comma or object end", &token);
+
+        json_next_token(json, &token);
+    }
+}
+
+/* Handle the array context */
+static void json_parse_array_context(lua_State *l, json_parse_t *json)
+{
+    json_token_t token;
+    int i;
+
+    /* 2 slots required:
+     * .., table, value */
+    json_decode_descend(l, json, 2);
+
+    lua_newtable(l);
+
+    json_next_token(json, &token);
+
+    /* Handle empty arrays */
+    if (token.type == T_ARR_END) {
+        json_decode_ascend(json);
+        return;
+    }
+
+    for (i = 1; ; i++) {
+        json_process_value(l, json, &token);
+        lua_rawseti(l, -2, i);            /* arr[i] = value */
+
+        json_next_token(json, &token);
+
+        if (token.type == T_ARR_END) {
+            json_decode_ascend(json);
+            return;
+        }
+
+        if (token.type != T_COMMA)
+            json_throw_parse_error(l, json, "comma or array end", &token);
+
+        json_next_token(json, &token);
+    }
+}
+
+/* Handle the "value" context */
+static void json_process_value(lua_State *l, json_parse_t *json,
+                               json_token_t *token)
+{
+    switch (token->type) {
+    case T_STRING:
+        lua_pushlstring(l, token->value.string, token->string_len);
+        break;;
+    case T_NUMBER:
+        lua_pushnumber(l, token->value.number);
+        break;;
+    case T_BOOLEAN:
+        lua_pushboolean(l, token->value.boolean);
+        break;;
+    case T_OBJ_BEGIN:
+        json_parse_object_context(l, json);
+        break;;
+    case T_ARR_BEGIN:
+        json_parse_array_context(l, json);
+        break;;
+    case T_NULL:
+        /* In Lua, setting "t[k] = nil" will delete k from the table.
+         * Hence a NULL pointer lightuserdata object is used instead */
+        lua_pushlightuserdata(l, NULL);
+        break;;
+    default:
+        json_throw_parse_error(l, json, "value", token);
+    }
+}
+
+static int json_decode(lua_State *l)
+{
+    json_parse_t json;
+    json_token_t token;
+    size_t json_len;
+
+    luaL_argcheck(l, lua_gettop(l) == 1, 1, "expected 1 argument");
+
+    json.cfg = json_fetch_config(l);
+    json.data = luaL_checklstring(l, 1, &json_len);
+    json.current_depth = 0;
+    json.ptr = json.data;
+
+    /* Detect Unicode other than UTF-8 (see RFC 4627, Sec 3)
+     *
+     * CJSON can support any simple data type, hence only the first
+     * character is guaranteed to be ASCII (at worst: '"'). This is
+     * still enough to detect whether the wrong encoding is in use. */
+    if (json_len >= 2 && (!json.data[0] || !json.data[1]))
+        luaL_error(l, "JSON parser does not support UTF-16 or UTF-32");
+
+    /* Ensure the temporary buffer can hold the entire string.
+     * This means we no longer need to do length checks since the decoded
+     * string must be smaller than the entire json string */
+    json.tmp = strbuf_new(json_len);
+
+    json_next_token(&json, &token);
+    json_process_value(l, &json, &token);
+
+    /* Ensure there is no more input left */
+    json_next_token(&json, &token);
+
+    if (token.type != T_END)
+        json_throw_parse_error(l, &json, "the end", &token);
+
+    strbuf_free(json.tmp);
+
+    return 1;
+}
+
+/* ===== INITIALISATION ===== */
+
+#if !defined(LUA_VERSION_NUM) || LUA_VERSION_NUM < 502
+/* Compatibility for Lua 5.1.
+ *
+ * luaL_setfuncs() is used to create a module table where the functions have
+ * json_config_t as their first upvalue. Code borrowed from Lua 5.2 source. */
+static void luaL_setfuncs (lua_State *l, const luaL_Reg *reg, int nup)
+{
+    int i;
+
+    luaL_checkstack(l, nup, "too many upvalues");
+    for (; reg->name != NULL; reg++) {  /* fill the table with given functions */
+        for (i = 0; i < nup; i++)  /* copy upvalues to the top */
+            lua_pushvalue(l, -nup);
+        lua_pushcclosure(l, reg->func, nup);  /* closure with those upvalues */
+        lua_setfield(l, -(nup + 2), reg->name);
+    }
+    lua_pop(l, nup);  /* remove upvalues */
+}
+#endif
+
+/* Call target function in protected mode with all supplied args.
+ * Assumes target function only returns a single non-nil value.
+ * Convert and return thrown errors as: nil, "error message" */
+static int json_protect_conversion(lua_State *l)
+{
+    int err;
+
+    /* Deliberately throw an error for invalid arguments */
+    luaL_argcheck(l, lua_gettop(l) == 1, 1, "expected 1 argument");
+
+    /* pcall() the function stored as upvalue(1) */
+    lua_pushvalue(l, lua_upvalueindex(1));
+    lua_insert(l, 1);
+    err = lua_pcall(l, 1, 1, 0);
+    if (!err)
+        return 1;
+
+    if (err == LUA_ERRRUN) {
+        lua_pushnil(l);
+        lua_insert(l, -2);
+        return 2;
+    }
+
+    /* Since we are not using a custom error handler, the only remaining
+     * errors are memory related */
+    return luaL_error(l, "Memory allocation error in CJSON protected call");
+}
+
+/* Return cjson module table */
+static int lua_cjson_new(lua_State *l)
+{
+    luaL_Reg reg[] = {
+        { "encode", json_encode },
+        { "decode", json_decode },
+        { "encode_sparse_array", json_cfg_encode_sparse_array },
+        { "encode_max_depth", json_cfg_encode_max_depth },
+        { "decode_max_depth", json_cfg_decode_max_depth },
+        { "encode_number_precision", json_cfg_encode_number_precision },
+        { "encode_keep_buffer", json_cfg_encode_keep_buffer },
+        { "encode_invalid_numbers", json_cfg_encode_invalid_numbers },
+        { "decode_invalid_numbers", json_cfg_decode_invalid_numbers },
+        { "new", lua_cjson_new },
+        { NULL, NULL }
+    };
+
+    /* Initialise number conversions */
+    fpconv_init();
+
+    /* cjson module table */
+    lua_newtable(l);
+
+    /* Register functions with config data as upvalue */
+    json_create_config(l);
+    luaL_setfuncs(l, reg, 1);
+
+    /* Set cjson.null */
+    lua_pushlightuserdata(l, NULL);
+    lua_setfield(l, -2, "null");
+
+    /* Set module name / version fields */
+    lua_pushliteral(l, CJSON_MODNAME);
+    lua_setfield(l, -2, "_NAME");
+    lua_pushliteral(l, CJSON_VERSION);
+    lua_setfield(l, -2, "_VERSION");
+
+    return 1;
+}
+
+/* Return cjson.safe module table */
+static int lua_cjson_safe_new(lua_State *l)
+{
+    const char *func[] = { "decode", "encode", NULL };
+    int i;
+
+    lua_cjson_new(l);
+
+    /* Fix new() method */
+    lua_pushcfunction(l, lua_cjson_safe_new);
+    lua_setfield(l, -2, "new");
+
+    for (i = 0; func[i]; i++) {
+        lua_getfield(l, -1, func[i]);
+        lua_pushcclosure(l, json_protect_conversion, 1);
+        lua_setfield(l, -2, func[i]);
+    }
+
+    return 1;
+}
+
+int luaopen_cjson(lua_State *l)
+{
+    lua_cjson_new(l);
+
+    /* Register a global "cjson" table. */
+    lua_pushvalue(l, -1);
+    lua_setglobal(l, CJSON_MODNAME);
+
+    /* Return cjson table */
+    return 1;
+}
+
+int luaopen_cjson_safe(lua_State *l)
+{
+    lua_cjson_safe_new(l);
+
+    /* Return cjson.safe table */
+    return 1;
+}
+
+/* vi:ai et sw=4 ts=4:
+ */
diff --git a/scripting/lua/cjson/lua_cjson.h b/scripting/lua/cjson/lua_cjson.h
new file mode 100755
index 0000000..69f31f2
--- /dev/null
+++ b/scripting/lua/cjson/lua_cjson.h
@@ -0,0 +1,6 @@
+#ifndef cjson_h
+#define cjson_h
+
+int luaopen_cjson(lua_State *L);
+
+#endif
diff --git a/scripting/lua/cjson/strbuf.c b/scripting/lua/cjson/strbuf.c
new file mode 100755
index 0000000..b437cdc
--- /dev/null
+++ b/scripting/lua/cjson/strbuf.c
@@ -0,0 +1,251 @@
+/* strbuf - String buffer routines
+ *
+ * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+
+#include "strbuf.h"
+
+static void die(const char *fmt, ...)
+{
+    va_list arg;
+
+    va_start(arg, fmt);
+    vfprintf(stderr, fmt, arg);
+    va_end(arg);
+    fprintf(stderr, "\n");
+
+    exit(-1);
+}
+
+void strbuf_init(strbuf_t *s, int len)
+{
+    int size;
+
+    if (len <= 0)
+        size = STRBUF_DEFAULT_SIZE;
+    else
+        size = len + 1;         /* \0 terminator */
+
+    s->buf = NULL;
+    s->size = size;
+    s->length = 0;
+    s->increment = STRBUF_DEFAULT_INCREMENT;
+    s->dynamic = 0;
+    s->reallocs = 0;
+    s->debug = 0;
+
+    s->buf = malloc(size);
+    if (!s->buf)
+        die("Out of memory");
+
+    strbuf_ensure_null(s);
+}
+
+strbuf_t *strbuf_new(int len)
+{
+    strbuf_t *s;
+
+    s = malloc(sizeof(strbuf_t));
+    if (!s)
+        die("Out of memory");
+
+    strbuf_init(s, len);
+
+    /* Dynamic strbuf allocation / deallocation */
+    s->dynamic = 1;
+
+    return s;
+}
+
+void strbuf_set_increment(strbuf_t *s, int increment)
+{
+    /* Increment > 0:  Linear buffer growth rate
+     * Increment < -1: Exponential buffer growth rate */
+    if (increment == 0 || increment == -1)
+        die("BUG: Invalid string increment");
+
+    s->increment = increment;
+}
+
+static void debug_stats(strbuf_t *s)
+{
+    if (s->debug) {
+        fprintf(stderr, "strbuf(%lx) reallocs: %d, length: %d, size: %d\n",
+                (long)s, s->reallocs, s->length, s->size);
+    }
+}
+
+/* If strbuf_t has not been dynamically allocated, strbuf_free() can
+ * be called any number of times strbuf_init() */
+void strbuf_free(strbuf_t *s)
+{
+    debug_stats(s);
+
+    if (s->buf) {
+        free(s->buf);
+        s->buf = NULL;
+    }
+    if (s->dynamic)
+        free(s);
+}
+
+char *strbuf_free_to_string(strbuf_t *s, int *len)
+{
+    char *buf;
+
+    debug_stats(s);
+
+    strbuf_ensure_null(s);
+
+    buf = s->buf;
+    if (len)
+        *len = s->length;
+
+    if (s->dynamic)
+        free(s);
+
+    return buf;
+}
+
+static int calculate_new_size(strbuf_t *s, int len)
+{
+    int reqsize, newsize;
+
+    if (len <= 0)
+        die("BUG: Invalid strbuf length requested");
+
+    /* Ensure there is room for optional NULL termination */
+    reqsize = len + 1;
+
+    /* If the user has requested to shrink the buffer, do it exactly */
+    if (s->size > reqsize)
+        return reqsize;
+
+    newsize = s->size;
+    if (s->increment < 0) {
+        /* Exponential sizing */
+        while (newsize < reqsize)
+            newsize *= -s->increment;
+    } else {
+        /* Linear sizing */
+        newsize = ((newsize + s->increment - 1) / s->increment) * s->increment;
+    }
+
+    return newsize;
+}
+
+
+/* Ensure strbuf can handle a string length bytes long (ignoring NULL
+ * optional termination). */
+void strbuf_resize(strbuf_t *s, int len)
+{
+    int newsize;
+
+    newsize = calculate_new_size(s, len);
+
+    if (s->debug > 1) {
+        fprintf(stderr, "strbuf(%lx) resize: %d => %d\n",
+                (long)s, s->size, newsize);
+    }
+
+    s->size = newsize;
+    s->buf = realloc(s->buf, s->size);
+    if (!s->buf)
+        die("Out of memory");
+    s->reallocs++;
+}
+
+void strbuf_append_string(strbuf_t *s, const char *str)
+{
+    int space, i;
+
+    space = strbuf_empty_length(s);
+
+    for (i = 0; str[i]; i++) {
+        if (space < 1) {
+            strbuf_resize(s, s->length + 1);
+            space = strbuf_empty_length(s);
+        }
+
+        s->buf[s->length] = str[i];
+        s->length++;
+        space--;
+    }
+}
+
+/* strbuf_append_fmt() should only be used when an upper bound
+ * is known for the output string. */
+void strbuf_append_fmt(strbuf_t *s, int len, const char *fmt, ...)
+{
+    va_list arg;
+    int fmt_len;
+
+    strbuf_ensure_empty_length(s, len);
+
+    va_start(arg, fmt);
+    fmt_len = vsnprintf(s->buf + s->length, len, fmt, arg);
+    va_end(arg);
+
+    if (fmt_len < 0)
+        die("BUG: Unable to convert number");  /* This should never happen.. */
+
+    s->length += fmt_len;
+}
+
+/* strbuf_append_fmt_retry() can be used when the there is no known
+ * upper bound for the output string. */
+void strbuf_append_fmt_retry(strbuf_t *s, const char *fmt, ...)
+{
+    va_list arg;
+    int fmt_len, try;
+    int empty_len;
+
+    /* If the first attempt to append fails, resize the buffer appropriately
+     * and try again */
+    for (try = 0; ; try++) {
+        va_start(arg, fmt);
+        /* Append the new formatted string */
+        /* fmt_len is the length of the string required, excluding the
+         * trailing NULL */
+        empty_len = strbuf_empty_length(s);
+        /* Add 1 since there is also space to store the terminating NULL. */
+        fmt_len = vsnprintf(s->buf + s->length, empty_len + 1, fmt, arg);
+        va_end(arg);
+
+        if (fmt_len <= empty_len)
+            break;  /* SUCCESS */
+        if (try > 0)
+            die("BUG: length of formatted string changed");
+
+        strbuf_resize(s, s->length + fmt_len);
+    }
+
+    s->length += fmt_len;
+}
+
+/* vi:ai et sw=4 ts=4:
+ */
diff --git a/scripting/lua/cjson/strbuf.h b/scripting/lua/cjson/strbuf.h
new file mode 100755
index 0000000..134b8e6
--- /dev/null
+++ b/scripting/lua/cjson/strbuf.h
@@ -0,0 +1,154 @@
+/* strbuf - String buffer routines
+ *
+ * Copyright (c) 2010-2012  Mark Pulford <mark@kyne.com.au>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include <stdlib.h>
+#include <stdarg.h>
+
+/* Size: Total bytes allocated to *buf
+ * Length: String length, excluding optional NULL terminator.
+ * Increment: Allocation increments when resizing the string buffer.
+ * Dynamic: True if created via strbuf_new()
+ */
+
+typedef struct {
+    char *buf;
+    int size;
+    int length;
+    int increment;
+    int dynamic;
+    int reallocs;
+    int debug;
+} strbuf_t;
+
+#ifndef STRBUF_DEFAULT_SIZE
+#define STRBUF_DEFAULT_SIZE 1023
+#endif
+#ifndef STRBUF_DEFAULT_INCREMENT
+#define STRBUF_DEFAULT_INCREMENT -2
+#endif
+
+/* Initialise */
+extern strbuf_t *strbuf_new(int len);
+extern void strbuf_init(strbuf_t *s, int len);
+extern void strbuf_set_increment(strbuf_t *s, int increment);
+
+/* Release */
+extern void strbuf_free(strbuf_t *s);
+extern char *strbuf_free_to_string(strbuf_t *s, int *len);
+
+/* Management */
+extern void strbuf_resize(strbuf_t *s, int len);
+static int strbuf_empty_length(strbuf_t *s);
+static int strbuf_length(strbuf_t *s);
+static char *strbuf_string(strbuf_t *s, int *len);
+static void strbuf_ensure_empty_length(strbuf_t *s, int len);
+static char *strbuf_empty_ptr(strbuf_t *s);
+static void strbuf_extend_length(strbuf_t *s, int len);
+
+/* Update */
+extern void strbuf_append_fmt(strbuf_t *s, int len, const char *fmt, ...);
+extern void strbuf_append_fmt_retry(strbuf_t *s, const char *format, ...);
+static void strbuf_append_mem(strbuf_t *s, const char *c, int len);
+extern void strbuf_append_string(strbuf_t *s, const char *str);
+static void strbuf_append_char(strbuf_t *s, const char c);
+static void strbuf_ensure_null(strbuf_t *s);
+
+/* Reset string for before use */
+static  void strbuf_reset(strbuf_t *s)
+{
+    s->length = 0;
+}
+
+static  int strbuf_allocated(strbuf_t *s)
+{
+    return s->buf != NULL;
+}
+
+/* Return bytes remaining in the string buffer
+ * Ensure there is space for a NULL terminator. */
+static  int strbuf_empty_length(strbuf_t *s)
+{
+    return s->size - s->length - 1;
+}
+
+static  void strbuf_ensure_empty_length(strbuf_t *s, int len)
+{
+    if (len > strbuf_empty_length(s))
+        strbuf_resize(s, s->length + len);
+}
+
+static  char *strbuf_empty_ptr(strbuf_t *s)
+{
+    return s->buf + s->length;
+}
+
+static  void strbuf_extend_length(strbuf_t *s, int len)
+{
+    s->length += len;
+}
+
+static  int strbuf_length(strbuf_t *s)
+{
+    return s->length;
+}
+
+static  void strbuf_append_char(strbuf_t *s, const char c)
+{
+    strbuf_ensure_empty_length(s, 1);
+    s->buf[s->length++] = c;
+}
+
+static  void strbuf_append_char_unsafe(strbuf_t *s, const char c)
+{
+    s->buf[s->length++] = c;
+}
+
+static  void strbuf_append_mem(strbuf_t *s, const char *c, int len)
+{
+    strbuf_ensure_empty_length(s, len);
+    memcpy(s->buf + s->length, c, len);
+    s->length += len;
+}
+
+static  void strbuf_append_mem_unsafe(strbuf_t *s, const char *c, int len)
+{
+    memcpy(s->buf + s->length, c, len);
+    s->length += len;
+}
+
+static  void strbuf_ensure_null(strbuf_t *s)
+{
+    s->buf[s->length] = 0;
+}
+
+static  char *strbuf_string(strbuf_t *s, int *len)
+{
+    if (len)
+        *len = s->length;
+
+    return s->buf;
+}
+
+/* vi:ai et sw=4 ts=4:
+ */
diff --git a/scripting/lua/cocos2dx_support/CCLuaStack.cpp b/scripting/lua/cocos2dx_support/CCLuaStack.cpp
index e6abff2..a016896 100755
--- a/scripting/lua/cocos2dx_support/CCLuaStack.cpp
+++ b/scripting/lua/cocos2dx_support/CCLuaStack.cpp
@@ -30,6 +30,11 @@ extern "C" {
 #include "lualib.h"
 #include "lauxlib.h"
 #include "tolua_fix.h"
+#include "md5.h"
+#include "ldes56.h"
+#include "lfs.h"
+#include "lua_zlib.h"
+#include "lua_cjson.h"
 }
 
 #include "LuaCocos2d.h"
@@ -121,6 +126,11 @@ bool CCLuaStack::init(void)
     luaL_register(m_state, "_G", global_functions);
     tolua_CocoStudio_open(m_state);
 	tolua_Extension_open(m_state);
+	luaopen_md5_core(m_state);
+	luaopen_des56(m_state);
+	luaopen_lfs(m_state);
+	luaopen_zlib(m_state);
+	luaopen_cjson(m_state);
 #if (CC_TARGET_PLATFORM == CC_PLATFORM_IOS || CC_TARGET_PLATFORM == CC_PLATFORM_MAC)
     CCLuaObjcBridge::luaopen_luaoc(m_state);
 #endif
diff --git a/scripting/lua/cocos2dx_support/LuaCocoStudio.cpp b/scripting/lua/cocos2dx_support/LuaCocoStudio.cpp
index 1044ba4..c2a9814 100644
--- a/scripting/lua/cocos2dx_support/LuaCocoStudio.cpp
+++ b/scripting/lua/cocos2dx_support/LuaCocoStudio.cpp
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: CocoStudio
-** Generated automatically by tolua++-1.0.92 on 04/02/14 12:02:55.
+** Generated automatically by tolua++-1.0.92 on 08/12/14 17:48:59.
 */
 
 /****************************************************************************
@@ -10861,6 +10861,39 @@ static int tolua_CocoStudio_Button_getTitleFontName00(lua_State* tolua_S)
 }
 #endif //#ifndef TOLUA_DISABLE
 
+/* method: setBrightStyle of class  Button */
+#ifndef TOLUA_DISABLE_tolua_CocoStudio_Button_setBrightStyle00
+static int tolua_CocoStudio_Button_setBrightStyle00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Button",0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Button* self = (Button*)  tolua_tousertype(tolua_S,1,0);
+  BrightStyle style = ((BrightStyle) (int)  tolua_tonumber(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setBrightStyle'", NULL);
+#endif
+  {
+   self->setBrightStyle(style);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setBrightStyle'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
 /* method: new of class  CheckBox */
 #ifndef TOLUA_DISABLE_tolua_CocoStudio_CheckBox_new00
 static int tolua_CocoStudio_CheckBox_new00(lua_State* tolua_S)
@@ -12104,6 +12137,38 @@ static int tolua_CocoStudio_ImageView_getVirtualRenderer00(lua_State* tolua_S)
 }
 #endif //#ifndef TOLUA_DISABLE
 
+/* method: getTextureFile of class  ImageView */
+#ifndef TOLUA_DISABLE_tolua_CocoStudio_ImageView_getTextureFile00
+static int tolua_CocoStudio_ImageView_getTextureFile00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"ImageView",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  ImageView* self = (ImageView*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'getTextureFile'", NULL);
+#endif
+  {
+   const char* tolua_ret = (const char*)  self->getTextureFile();
+   tolua_pushstring(tolua_S,(const char*)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'getTextureFile'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
 /* method: new of class  Label */
 #ifndef TOLUA_DISABLE_tolua_CocoStudio_Label_new00
 static int tolua_CocoStudio_Label_new00(lua_State* tolua_S)
@@ -16917,6 +16982,39 @@ static int tolua_CocoStudio_ScrollView_jumpToPercentBothDirection00(lua_State* t
 }
 #endif //#ifndef TOLUA_DISABLE
 
+/* method: jumpToDestination of class  ScrollView */
+#ifndef TOLUA_DISABLE_tolua_CocoStudio_ScrollView_jumpToDestination00
+static int tolua_CocoStudio_ScrollView_jumpToDestination00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"ScrollView",0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !tolua_isusertype(tolua_S,2,"const CCPoint",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  ScrollView* self = (ScrollView*)  tolua_tousertype(tolua_S,1,0);
+  const CCPoint* des = ((const CCPoint*)  tolua_tousertype(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'jumpToDestination'", NULL);
+#endif
+  {
+   self->jumpToDestination(*des);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'jumpToDestination'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
 /* method: setInnerContainerSize of class  ScrollView */
 #ifndef TOLUA_DISABLE_tolua_CocoStudio_ScrollView_setInnerContainerSize00
 static int tolua_CocoStudio_ScrollView_setInnerContainerSize00(lua_State* tolua_S)
@@ -23761,6 +23859,9 @@ TOLUA_API int tolua_CocoStudio_open (lua_State* tolua_S)
    tolua_function(tolua_S,"sortAllChildren",tolua_CocoStudio_Layout_sortAllChildren00);
    tolua_function(tolua_S,"requestDoLayout",tolua_CocoStudio_Layout_requestDoLayout00);
   tolua_endmodule(tolua_S);
+  tolua_constant(tolua_S,"BRIGHT_NONE",BRIGHT_NONE);
+  tolua_constant(tolua_S,"BRIGHT_NORMAL",BRIGHT_NORMAL);
+  tolua_constant(tolua_S,"BRIGHT_HIGHLIGHT",BRIGHT_HIGHLIGHT);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"Button","Button","Widget",tolua_collect_Button);
   #else
@@ -23800,6 +23901,7 @@ TOLUA_API int tolua_CocoStudio_open (lua_State* tolua_S)
    tolua_function(tolua_S,"getTitleFontSize",tolua_CocoStudio_Button_getTitleFontSize00);
    tolua_function(tolua_S,"setTitleFontName",tolua_CocoStudio_Button_setTitleFontName00);
    tolua_function(tolua_S,"getTitleFontName",tolua_CocoStudio_Button_getTitleFontName00);
+   tolua_function(tolua_S,"setBrightStyle",tolua_CocoStudio_Button_setBrightStyle00);
   tolua_endmodule(tolua_S);
   tolua_constant(tolua_S,"CHECKBOX_STATE_EVENT_SELECTED",CHECKBOX_STATE_EVENT_SELECTED);
   tolua_constant(tolua_S,"CHECKBOX_STATE_EVENT_UNSELECTED",CHECKBOX_STATE_EVENT_UNSELECTED);
@@ -23856,6 +23958,7 @@ TOLUA_API int tolua_CocoStudio_open (lua_State* tolua_S)
    tolua_function(tolua_S,"getDescription",tolua_CocoStudio_ImageView_getDescription00);
    tolua_function(tolua_S,"getContentSize",tolua_CocoStudio_ImageView_getContentSize00);
    tolua_function(tolua_S,"getVirtualRenderer",tolua_CocoStudio_ImageView_getVirtualRenderer00);
+   tolua_function(tolua_S,"getTextureFile",tolua_CocoStudio_ImageView_getTextureFile00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"Label","Label","Widget",tolua_collect_Label);
@@ -24080,6 +24183,7 @@ TOLUA_API int tolua_CocoStudio_open (lua_State* tolua_S)
    tolua_function(tolua_S,"jumpToPercentVertical",tolua_CocoStudio_ScrollView_jumpToPercentVertical00);
    tolua_function(tolua_S,"jumpToPercentHorizontal",tolua_CocoStudio_ScrollView_jumpToPercentHorizontal00);
    tolua_function(tolua_S,"jumpToPercentBothDirection",tolua_CocoStudio_ScrollView_jumpToPercentBothDirection00);
+   tolua_function(tolua_S,"jumpToDestination",tolua_CocoStudio_ScrollView_jumpToDestination00);
    tolua_function(tolua_S,"setInnerContainerSize",tolua_CocoStudio_ScrollView_setInnerContainerSize00);
    tolua_function(tolua_S,"getInnerContainerSize",tolua_CocoStudio_ScrollView_getInnerContainerSize00);
    tolua_function(tolua_S,"addChild",tolua_CocoStudio_ScrollView_addChild00);
diff --git a/scripting/lua/cocos2dx_support/LuaCocos2d.cpp b/scripting/lua/cocos2dx_support/LuaCocos2d.cpp
index 8771c4d..d507f38 100755
--- a/scripting/lua/cocos2dx_support/LuaCocos2d.cpp
+++ b/scripting/lua/cocos2dx_support/LuaCocos2d.cpp
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: Cocos2d
-** Generated automatically by tolua++-1.0.92 on 04/02/14 12:13:56.
+** Generated automatically by tolua++-1.0.92 on 08/12/14 17:52:00.
 */
 
 /****************************************************************************
@@ -457,6 +457,7 @@ static void tolua_reg_types (lua_State* tolua_S)
  tolua_usertype(tolua_S,"CCWaves");
  tolua_usertype(tolua_S,"CCParticleFireworks");
  tolua_usertype(tolua_S,"CCEvent");
+ tolua_usertype(tolua_S,"CCShaderCache");
  tolua_usertype(tolua_S,"CCActionInterval");
  tolua_usertype(tolua_S,"CCRenderTexture");
  tolua_usertype(tolua_S,"CCObject");
@@ -536,6 +537,7 @@ static void tolua_reg_types (lua_State* tolua_S)
  tolua_usertype(tolua_S,"CCDeccelAmplitude");
  tolua_usertype(tolua_S,"CCTableView");
  tolua_usertype(tolua_S,"CCTimer");
+ tolua_usertype(tolua_S,"CCEditBoxDelegate");
  tolua_usertype(tolua_S,"CCControlStepper");
  tolua_usertype(tolua_S,"CCFiniteTimeAction");
  tolua_usertype(tolua_S,"CCTransitionProgressRadialCW");
@@ -9807,6 +9809,41 @@ static int tolua_Cocos2d_CCFileUtils_getFileData00(lua_State* tolua_S)
 }
 #endif //#ifndef TOLUA_DISABLE
 
+/* method: isFileExist of class  CCFileUtils */
+#ifndef TOLUA_DISABLE_tolua_Cocos2d_CCFileUtils_isFileExist00
+static int tolua_Cocos2d_CCFileUtils_isFileExist00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCFileUtils",0,&tolua_err) ||
+     !tolua_iscppstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCFileUtils* self = (CCFileUtils*)  tolua_tousertype(tolua_S,1,0);
+  const std::string strFilePath = ((const std::string)  tolua_tocppstring(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'isFileExist'", NULL);
+#endif
+  {
+   bool tolua_ret = (bool)  self->isFileExist(strFilePath);
+   tolua_pushboolean(tolua_S,(bool)tolua_ret);
+   tolua_pushcppstring(tolua_S,(const char*)strFilePath);
+  }
+ }
+ return 2;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'isFileExist'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
 /* function: ccDrawPoint */
 #ifndef TOLUA_DISABLE_tolua_Cocos2d_ccDrawPoint00
 static int tolua_Cocos2d_ccDrawPoint00(lua_State* tolua_S)
@@ -64032,6 +64069,37 @@ static int tolua_Cocos2d_CCEditBox_onExit00(lua_State* tolua_S)
 }
 #endif //#ifndef TOLUA_DISABLE
 
+/* method: closeKeyboard of class  CCEditBox */
+#ifndef TOLUA_DISABLE_tolua_Cocos2d_CCEditBox_closeKeyboard00
+static int tolua_Cocos2d_CCEditBox_closeKeyboard00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCEditBox",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCEditBox* self = (CCEditBox*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'closeKeyboard'", NULL);
+#endif
+  {
+   self->closeKeyboard();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'closeKeyboard'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
 /* method: touchDownAction of class  CCEditBox */
 #ifndef TOLUA_DISABLE_tolua_Cocos2d_CCEditBox_touchDownAction00
 static int tolua_Cocos2d_CCEditBox_touchDownAction00(lua_State* tolua_S)
@@ -64067,6 +64135,39 @@ static int tolua_Cocos2d_CCEditBox_touchDownAction00(lua_State* tolua_S)
 }
 #endif //#ifndef TOLUA_DISABLE
 
+/* method: setDelegate of class  CCEditBox */
+#ifndef TOLUA_DISABLE_tolua_Cocos2d_CCEditBox_setDelegate00
+static int tolua_Cocos2d_CCEditBox_setDelegate00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCEditBox",0,&tolua_err) ||
+     !tolua_isusertype(tolua_S,2,"CCEditBoxDelegate",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCEditBox* self = (CCEditBox*)  tolua_tousertype(tolua_S,1,0);
+  CCEditBoxDelegate* pDelegate = ((CCEditBoxDelegate*)  tolua_tousertype(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setDelegate'", NULL);
+#endif
+  {
+   self->setDelegate(pDelegate);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setDelegate'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
 /* method: new of class  CCInteger */
 #ifndef TOLUA_DISABLE_tolua_Cocos2d_CCInteger_new00
 static int tolua_Cocos2d_CCInteger_new00(lua_State* tolua_S)
@@ -66491,6 +66592,192 @@ static int tolua_Cocos2d_CCTableView_unregisterAllScriptHandler00(lua_State* tol
 }
 #endif //#ifndef TOLUA_DISABLE
 
+/* method: sharedShaderCache of class  CCShaderCache */
+#ifndef TOLUA_DISABLE_tolua_Cocos2d_CCShaderCache_sharedShaderCache00
+static int tolua_Cocos2d_CCShaderCache_sharedShaderCache00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,"CCShaderCache",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   CCShaderCache* tolua_ret = (CCShaderCache*)  CCShaderCache::sharedShaderCache();
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,"CCShaderCache");
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'sharedShaderCache'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: purgeSharedShaderCache of class  CCShaderCache */
+#ifndef TOLUA_DISABLE_tolua_Cocos2d_CCShaderCache_purgeSharedShaderCache00
+static int tolua_Cocos2d_CCShaderCache_purgeSharedShaderCache00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,"CCShaderCache",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   CCShaderCache::purgeSharedShaderCache();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'purgeSharedShaderCache'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: loadDefaultShaders of class  CCShaderCache */
+#ifndef TOLUA_DISABLE_tolua_Cocos2d_CCShaderCache_loadDefaultShaders00
+static int tolua_Cocos2d_CCShaderCache_loadDefaultShaders00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCShaderCache",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCShaderCache* self = (CCShaderCache*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'loadDefaultShaders'", NULL);
+#endif
+  {
+   self->loadDefaultShaders();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'loadDefaultShaders'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: reloadDefaultShaders of class  CCShaderCache */
+#ifndef TOLUA_DISABLE_tolua_Cocos2d_CCShaderCache_reloadDefaultShaders00
+static int tolua_Cocos2d_CCShaderCache_reloadDefaultShaders00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCShaderCache",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCShaderCache* self = (CCShaderCache*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'reloadDefaultShaders'", NULL);
+#endif
+  {
+   self->reloadDefaultShaders();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'reloadDefaultShaders'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: programForKey of class  CCShaderCache */
+#ifndef TOLUA_DISABLE_tolua_Cocos2d_CCShaderCache_programForKey00
+static int tolua_Cocos2d_CCShaderCache_programForKey00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCShaderCache",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCShaderCache* self = (CCShaderCache*)  tolua_tousertype(tolua_S,1,0);
+  const char* key = ((const char*)  tolua_tostring(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'programForKey'", NULL);
+#endif
+  {
+   CCGLProgram* tolua_ret = (CCGLProgram*)  self->programForKey(key);
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,"CCGLProgram");
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'programForKey'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: addProgram of class  CCShaderCache */
+#ifndef TOLUA_DISABLE_tolua_Cocos2d_CCShaderCache_addProgram00
+static int tolua_Cocos2d_CCShaderCache_addProgram00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCShaderCache",0,&tolua_err) ||
+     !tolua_isusertype(tolua_S,2,"CCGLProgram",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,3,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,4,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCShaderCache* self = (CCShaderCache*)  tolua_tousertype(tolua_S,1,0);
+  CCGLProgram* program = ((CCGLProgram*)  tolua_tousertype(tolua_S,2,0));
+  const char* key = ((const char*)  tolua_tostring(tolua_S,3,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'addProgram'", NULL);
+#endif
+  {
+   self->addProgram(program,key);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'addProgram'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
 /* Open function */
 TOLUA_API int tolua_Cocos2d_open (lua_State* tolua_S)
 {
@@ -66999,6 +67286,7 @@ TOLUA_API int tolua_Cocos2d_open (lua_State* tolua_S)
    tolua_function(tolua_S,"setPopupNotify",tolua_Cocos2d_CCFileUtils_setPopupNotify00);
    tolua_function(tolua_S,"isPopupNotify",tolua_Cocos2d_CCFileUtils_isPopupNotify00);
    tolua_function(tolua_S,"getFileData",tolua_Cocos2d_CCFileUtils_getFileData00);
+   tolua_function(tolua_S,"isFileExist",tolua_Cocos2d_CCFileUtils_isFileExist00);
   tolua_endmodule(tolua_S);
   tolua_function(tolua_S,"ccDrawPoint",tolua_Cocos2d_ccDrawPoint00);
   tolua_function(tolua_S,"ccDrawPoints",tolua_Cocos2d_ccDrawPoints00);
@@ -69831,7 +70119,9 @@ TOLUA_API int tolua_Cocos2d_open (lua_State* tolua_S)
    tolua_function(tolua_S,"visit",tolua_Cocos2d_CCEditBox_visit00);
    tolua_function(tolua_S,"onEnter",tolua_Cocos2d_CCEditBox_onEnter00);
    tolua_function(tolua_S,"onExit",tolua_Cocos2d_CCEditBox_onExit00);
+   tolua_function(tolua_S,"closeKeyboard",tolua_Cocos2d_CCEditBox_closeKeyboard00);
    tolua_function(tolua_S,"touchDownAction",tolua_Cocos2d_CCEditBox_touchDownAction00);
+   tolua_function(tolua_S,"setDelegate",tolua_Cocos2d_CCEditBox_setDelegate00);
   tolua_endmodule(tolua_S);
   #ifdef __cplusplus
   tolua_cclass(tolua_S,"CCInteger","CCInteger","CCObject",tolua_collect_CCInteger);
@@ -69950,6 +70240,15 @@ TOLUA_API int tolua_Cocos2d_open (lua_State* tolua_S)
    tolua_constant(tolua_S,"kNumberOfCellsInTableView",CCTableView::kNumberOfCellsInTableView);
    tolua_function(tolua_S,"unregisterAllScriptHandler",tolua_Cocos2d_CCTableView_unregisterAllScriptHandler00);
   tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,"CCShaderCache","CCShaderCache","CCObject",NULL);
+  tolua_beginmodule(tolua_S,"CCShaderCache");
+   tolua_function(tolua_S,"sharedShaderCache",tolua_Cocos2d_CCShaderCache_sharedShaderCache00);
+   tolua_function(tolua_S,"purgeSharedShaderCache",tolua_Cocos2d_CCShaderCache_purgeSharedShaderCache00);
+   tolua_function(tolua_S,"loadDefaultShaders",tolua_Cocos2d_CCShaderCache_loadDefaultShaders00);
+   tolua_function(tolua_S,"reloadDefaultShaders",tolua_Cocos2d_CCShaderCache_reloadDefaultShaders00);
+   tolua_function(tolua_S,"programForKey",tolua_Cocos2d_CCShaderCache_programForKey00);
+   tolua_function(tolua_S,"addProgram",tolua_Cocos2d_CCShaderCache_addProgram00);
+  tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  return 1;
 }
diff --git a/scripting/lua/cocos2dx_support/LuaCocos2dExtension.cpp b/scripting/lua/cocos2dx_support/LuaCocos2dExtension.cpp
index aa33089..a7329d6 100755
--- a/scripting/lua/cocos2dx_support/LuaCocos2dExtension.cpp
+++ b/scripting/lua/cocos2dx_support/LuaCocos2dExtension.cpp
@@ -1,6 +1,6 @@
 /*
 ** Lua binding: Extension
-** Generated automatically by tolua++-1.0.92 on 04/02/14 16:09:22.
+** Generated automatically by tolua++-1.0.92 on 12/25/14 11:54:33.
 */
 
 /****************************************************************************
@@ -33,9 +33,19 @@ extern "C" {
 
 #include <map>
 #include <string>
+#include "cocos2d.h"
+#include "CCLuaEngine.h"
 #include "FacebookDelegate.h"
+#include "HttpRequestForLua.h"
+#include "EditBoxDelegateForLua.h"
+#include "Analytics.h"
+#include "WebviewDelegate.h"
+#include "Misc.h"
 
+using namespace cocos2d;
+using namespace cocos2d::extension;
 using namespace Social;
+using namespace Utils;
 
 
 
@@ -44,7 +54,18 @@ using namespace Social;
 /* function to register type */
 static void tolua_reg_types (lua_State* tolua_S)
 {
+ tolua_usertype(tolua_S,"Misc");
+ tolua_usertype(tolua_S,"CCLayer");
+ tolua_usertype(tolua_S,"cocos2d::CCNode");
+ tolua_usertype(tolua_S,"HttpRequestForLua");
+ tolua_usertype(tolua_S,"WebviewDelegate");
+ tolua_usertype(tolua_S,"Analytics");
  tolua_usertype(tolua_S,"FacebookDelegate");
+ tolua_usertype(tolua_S,"CCHttpRequest");
+ 
+ tolua_usertype(tolua_S,"CCObject");
+ tolua_usertype(tolua_S,"CCEditBoxDelegate");
+ tolua_usertype(tolua_S,"EditBoxDelegateForLua");
 }
 
 /* method: sharedDelegate of class  FacebookDelegate */
@@ -83,18 +104,20 @@ static int tolua_Extension_FacebookDelegate_login00(lua_State* tolua_S)
  tolua_Error tolua_err;
  if (
      !tolua_isusertype(tolua_S,1,"FacebookDelegate",0,&tolua_err) ||
-     !tolua_isnoobj(tolua_S,2,&tolua_err)
+     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !toluafix_isfunction(tolua_S,2,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
  )
   goto tolua_lerror;
  else
 #endif
  {
   FacebookDelegate* self = (FacebookDelegate*)  tolua_tousertype(tolua_S,1,0);
+  LUA_FUNCTION handler = (  toluafix_ref_function(tolua_S,2,0));
 #ifndef TOLUA_RELEASE
   if (!self) tolua_error(tolua_S,"invalid 'self' in function 'login'", NULL);
 #endif
   {
-   self->login();
+   self->login(handler);
   }
  }
  return 0;
@@ -106,17 +129,1436 @@ static int tolua_Extension_FacebookDelegate_login00(lua_State* tolua_S)
 }
 #endif //#ifndef TOLUA_DISABLE
 
-/* Open function */
-TOLUA_API int tolua_Extension_open (lua_State* tolua_S)
+/* method: grantPublishPermission of class  FacebookDelegate */
+#ifndef TOLUA_DISABLE_tolua_Extension_FacebookDelegate_grantPublishPermission00
+static int tolua_Extension_FacebookDelegate_grantPublishPermission00(lua_State* tolua_S)
 {
- tolua_open(tolua_S);
- tolua_reg_types(tolua_S);
- tolua_module(tolua_S,NULL,0);
- tolua_beginmodule(tolua_S,NULL);
-  tolua_cclass(tolua_S,"FacebookDelegate","FacebookDelegate","",NULL);
-  tolua_beginmodule(tolua_S,"FacebookDelegate");
-   tolua_function(tolua_S,"sharedDelegate",tolua_Extension_FacebookDelegate_sharedDelegate00);
-   tolua_function(tolua_S,"login",tolua_Extension_FacebookDelegate_login00);
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"FacebookDelegate",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !toluafix_isfunction(tolua_S,3,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,4,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  FacebookDelegate* self = (FacebookDelegate*)  tolua_tousertype(tolua_S,1,0);
+  const char* permission = ((const char*)  tolua_tostring(tolua_S,2,0));
+  LUA_FUNCTION handler = (  toluafix_ref_function(tolua_S,3,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'grantPublishPermission'", NULL);
+#endif
+  {
+   self->grantPublishPermission(permission,handler);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'grantPublishPermission'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setRequestType of class  CCHttpRequest */
+#ifndef TOLUA_DISABLE_tolua_Extension_CCHttpRequest_setRequestType00
+static int tolua_Extension_CCHttpRequest_setRequestType00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCHttpRequest",0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCHttpRequest* self = (CCHttpRequest*)  tolua_tousertype(tolua_S,1,0);
+  CCHttpRequest::HttpRequestType type = ((CCHttpRequest::HttpRequestType) (int)  tolua_tonumber(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setRequestType'", NULL);
+#endif
+  {
+   self->setRequestType(type);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setRequestType'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getRequestType of class  CCHttpRequest */
+#ifndef TOLUA_DISABLE_tolua_Extension_CCHttpRequest_getRequestType00
+static int tolua_Extension_CCHttpRequest_getRequestType00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCHttpRequest",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCHttpRequest* self = (CCHttpRequest*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'getRequestType'", NULL);
+#endif
+  {
+   CCHttpRequest::HttpRequestType tolua_ret = (CCHttpRequest::HttpRequestType)  self->getRequestType();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'getRequestType'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setUrl of class  CCHttpRequest */
+#ifndef TOLUA_DISABLE_tolua_Extension_CCHttpRequest_setUrl00
+static int tolua_Extension_CCHttpRequest_setUrl00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCHttpRequest",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCHttpRequest* self = (CCHttpRequest*)  tolua_tousertype(tolua_S,1,0);
+  const char* url = ((const char*)  tolua_tostring(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setUrl'", NULL);
+#endif
+  {
+   self->setUrl(url);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setUrl'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getUrl of class  CCHttpRequest */
+#ifndef TOLUA_DISABLE_tolua_Extension_CCHttpRequest_getUrl00
+static int tolua_Extension_CCHttpRequest_getUrl00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCHttpRequest",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCHttpRequest* self = (CCHttpRequest*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'getUrl'", NULL);
+#endif
+  {
+   const char* tolua_ret = (const char*)  self->getUrl();
+   tolua_pushstring(tolua_S,(const char*)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'getUrl'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setRequestData of class  CCHttpRequest */
+#ifndef TOLUA_DISABLE_tolua_Extension_CCHttpRequest_setRequestData00
+static int tolua_Extension_CCHttpRequest_setRequestData00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCHttpRequest",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,4,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCHttpRequest* self = (CCHttpRequest*)  tolua_tousertype(tolua_S,1,0);
+  const char* buffer = ((const char*)  tolua_tostring(tolua_S,2,0));
+  unsigned int len = ((unsigned int)  tolua_tonumber(tolua_S,3,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setRequestData'", NULL);
+#endif
+  {
+   self->setRequestData(buffer,len);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setRequestData'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getRequestData of class  CCHttpRequest */
+#ifndef TOLUA_DISABLE_tolua_Extension_CCHttpRequest_getRequestData00
+static int tolua_Extension_CCHttpRequest_getRequestData00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCHttpRequest",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCHttpRequest* self = (CCHttpRequest*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'getRequestData'", NULL);
+#endif
+  {
+   char* tolua_ret = (char*)  self->getRequestData();
+   tolua_pushstring(tolua_S,(const char*)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'getRequestData'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getRequestDataSize of class  CCHttpRequest */
+#ifndef TOLUA_DISABLE_tolua_Extension_CCHttpRequest_getRequestDataSize00
+static int tolua_Extension_CCHttpRequest_getRequestDataSize00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCHttpRequest",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCHttpRequest* self = (CCHttpRequest*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'getRequestDataSize'", NULL);
+#endif
+  {
+   int tolua_ret = (int)  self->getRequestDataSize();
+   tolua_pushnumber(tolua_S,(lua_Number)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'getRequestDataSize'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setTag of class  CCHttpRequest */
+#ifndef TOLUA_DISABLE_tolua_Extension_CCHttpRequest_setTag00
+static int tolua_Extension_CCHttpRequest_setTag00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCHttpRequest",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCHttpRequest* self = (CCHttpRequest*)  tolua_tousertype(tolua_S,1,0);
+  const char* tag = ((const char*)  tolua_tostring(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setTag'", NULL);
+#endif
+  {
+   self->setTag(tag);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setTag'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getTag of class  CCHttpRequest */
+#ifndef TOLUA_DISABLE_tolua_Extension_CCHttpRequest_getTag00
+static int tolua_Extension_CCHttpRequest_getTag00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"CCHttpRequest",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCHttpRequest* self = (CCHttpRequest*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'getTag'", NULL);
+#endif
+  {
+   const char* tolua_ret = (const char*)  self->getTag();
+   tolua_pushstring(tolua_S,(const char*)tolua_ret);
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'getTag'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: create of class  HttpRequestForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_HttpRequestForLua_create00
+static int tolua_Extension_HttpRequestForLua_create00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,"HttpRequestForLua",0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  CCHttpRequest::HttpRequestType type = ((CCHttpRequest::HttpRequestType) (int)  tolua_tonumber(tolua_S,2,0));
+  {
+   HttpRequestForLua* tolua_ret = (HttpRequestForLua*)  HttpRequestForLua::create(type);
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,"HttpRequestForLua");
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'create'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: addHeader of class  HttpRequestForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_HttpRequestForLua_addHeader00
+static int tolua_Extension_HttpRequestForLua_addHeader00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"HttpRequestForLua",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  HttpRequestForLua* self = (HttpRequestForLua*)  tolua_tousertype(tolua_S,1,0);
+  const char* header = ((const char*)  tolua_tostring(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'addHeader'", NULL);
+#endif
+  {
+   self->addHeader(header);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'addHeader'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setUserpwd of class  HttpRequestForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_HttpRequestForLua_setUserpwd00
+static int tolua_Extension_HttpRequestForLua_setUserpwd00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"HttpRequestForLua",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  HttpRequestForLua* self = (HttpRequestForLua*)  tolua_tousertype(tolua_S,1,0);
+  const char* userpwd = ((const char*)  tolua_tostring(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setUserpwd'", NULL);
+#endif
+  {
+   self->setUserpwd(userpwd);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setUserpwd'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setPriority of class  HttpRequestForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_HttpRequestForLua_setPriority00
+static int tolua_Extension_HttpRequestForLua_setPriority00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"HttpRequestForLua",0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  HttpRequestForLua* self = (HttpRequestForLua*)  tolua_tousertype(tolua_S,1,0);
+  int p = ((int)  tolua_tonumber(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setPriority'", NULL);
+#endif
+  {
+   self->setPriority(p);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setPriority'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: sendHttpRequest of class  HttpRequestForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_HttpRequestForLua_sendHttpRequest00
+static int tolua_Extension_HttpRequestForLua_sendHttpRequest00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"HttpRequestForLua",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !toluafix_isfunction(tolua_S,3,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,4,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  HttpRequestForLua* self = (HttpRequestForLua*)  tolua_tousertype(tolua_S,1,0);
+  const char* url = ((const char*)  tolua_tostring(tolua_S,2,0));
+  LUA_FUNCTION callbackFunc = (  toluafix_ref_function(tolua_S,3,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'sendHttpRequest'", NULL);
+#endif
+  {
+   self->sendHttpRequest(url,callbackFunc);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'sendHttpRequest'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: onHttpRequestCompleted of class  HttpRequestForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_HttpRequestForLua_onHttpRequestCompleted00
+static int tolua_Extension_HttpRequestForLua_onHttpRequestCompleted00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"HttpRequestForLua",0,&tolua_err) ||
+     !tolua_isusertype(tolua_S,2,"cocos2d::CCNode",0,&tolua_err) ||
+     !tolua_isuserdata(tolua_S,3,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,4,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  HttpRequestForLua* self = (HttpRequestForLua*)  tolua_tousertype(tolua_S,1,0);
+  cocos2d::CCNode* sender = ((cocos2d::CCNode*)  tolua_tousertype(tolua_S,2,0));
+  void* data = ((void*)  tolua_touserdata(tolua_S,3,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'onHttpRequestCompleted'", NULL);
+#endif
+  {
+   self->onHttpRequestCompleted(sender,data);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'onHttpRequestCompleted'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setRequest of class  HttpRequestForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_HttpRequestForLua_setRequest00
+static int tolua_Extension_HttpRequestForLua_setRequest00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"HttpRequestForLua",0,&tolua_err) ||
+     !tolua_isusertype(tolua_S,2,"CCHttpRequest",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  HttpRequestForLua* self = (HttpRequestForLua*)  tolua_tousertype(tolua_S,1,0);
+  CCHttpRequest* request = ((CCHttpRequest*)  tolua_tousertype(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setRequest'", NULL);
+#endif
+  {
+   self->setRequest(request);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setRequest'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getRequest of class  HttpRequestForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_HttpRequestForLua_getRequest00
+static int tolua_Extension_HttpRequestForLua_getRequest00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"HttpRequestForLua",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  HttpRequestForLua* self = (HttpRequestForLua*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'getRequest'", NULL);
+#endif
+  {
+   CCHttpRequest* tolua_ret = (CCHttpRequest*)  self->getRequest();
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,"CCHttpRequest");
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'getRequest'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: create of class  EditBoxDelegateForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_EditBoxDelegateForLua_create00
+static int tolua_Extension_EditBoxDelegateForLua_create00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,"EditBoxDelegateForLua",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   EditBoxDelegateForLua* tolua_ret = (EditBoxDelegateForLua*)  EditBoxDelegateForLua::create();
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,"EditBoxDelegateForLua");
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'create'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: registerEventScriptHandler of class  EditBoxDelegateForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_EditBoxDelegateForLua_registerEventScriptHandler00
+static int tolua_Extension_EditBoxDelegateForLua_registerEventScriptHandler00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"EditBoxDelegateForLua",0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !toluafix_isfunction(tolua_S,3,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,4,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  EditBoxDelegateForLua* self = (EditBoxDelegateForLua*)  tolua_tousertype(tolua_S,1,0);
+  EditBoxEvent eventType = ((EditBoxEvent) (int)  tolua_tonumber(tolua_S,2,0));
+  LUA_FUNCTION nHandler = (  toluafix_ref_function(tolua_S,3,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'registerEventScriptHandler'", NULL);
+#endif
+  {
+   self->registerEventScriptHandler(eventType,nHandler);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'registerEventScriptHandler'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: unregisterEventScriptHandler of class  EditBoxDelegateForLua */
+#ifndef TOLUA_DISABLE_tolua_Extension_EditBoxDelegateForLua_unregisterEventScriptHandler00
+static int tolua_Extension_EditBoxDelegateForLua_unregisterEventScriptHandler00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"EditBoxDelegateForLua",0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  EditBoxDelegateForLua* self = (EditBoxDelegateForLua*)  tolua_tousertype(tolua_S,1,0);
+  EditBoxEvent eventType = ((EditBoxEvent) (int)  tolua_tonumber(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'unregisterEventScriptHandler'", NULL);
+#endif
+  {
+   self->unregisterEventScriptHandler(eventType);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'unregisterEventScriptHandler'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* get function: __CCEditBoxDelegate__ of class  EditBoxDelegateForLua */
+#ifndef TOLUA_DISABLE_tolua_get_EditBoxDelegateForLua___CCEditBoxDelegate__
+static int tolua_get_EditBoxDelegateForLua___CCEditBoxDelegate__(lua_State* tolua_S)
+{
+  EditBoxDelegateForLua* self = (EditBoxDelegateForLua*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in accessing variable '__CCEditBoxDelegate__'",NULL);
+#endif
+#ifdef __cplusplus
+   tolua_pushusertype(tolua_S,(void*)static_cast<CCEditBoxDelegate*>(self), "CCEditBoxDelegate");
+#else
+   tolua_pushusertype(tolua_S,(void*)((CCEditBoxDelegate*)self), "CCEditBoxDelegate");
+#endif
+ return 1;
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: sharedDelegate of class  Analytics */
+#ifndef TOLUA_DISABLE_tolua_Extension_Analytics_sharedDelegate00
+static int tolua_Extension_Analytics_sharedDelegate00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,"Analytics",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   Analytics* tolua_ret = (Analytics*)  Analytics::sharedDelegate();
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Analytics");
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'sharedDelegate'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: postEvent of class  Analytics */
+#ifndef TOLUA_DISABLE_tolua_Extension_Analytics_postEvent00
+static int tolua_Extension_Analytics_postEvent00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Analytics",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isstring(tolua_S,3,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,4,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Analytics* self = (Analytics*)  tolua_tousertype(tolua_S,1,0);
+  const char* eventName = ((const char*)  tolua_tostring(tolua_S,2,0));
+  const char* paramString = ((const char*)  tolua_tostring(tolua_S,3,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'postEvent'", NULL);
+#endif
+  {
+   self->postEvent(eventName,paramString);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'postEvent'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: sharedDelegate of class  WebviewDelegate */
+#ifndef TOLUA_DISABLE_tolua_Extension_WebviewDelegate_sharedDelegate00
+static int tolua_Extension_WebviewDelegate_sharedDelegate00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,"WebviewDelegate",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   WebviewDelegate* tolua_ret = (WebviewDelegate*)  WebviewDelegate::sharedDelegate();
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,"WebviewDelegate");
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'sharedDelegate'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: openWebpage of class  WebviewDelegate */
+#ifndef TOLUA_DISABLE_tolua_Extension_WebviewDelegate_openWebpage00
+static int tolua_Extension_WebviewDelegate_openWebpage00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"WebviewDelegate",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,5,0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,6,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,7,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  WebviewDelegate* self = (WebviewDelegate*)  tolua_tousertype(tolua_S,1,0);
+  const char* url = ((const char*)  tolua_tostring(tolua_S,2,0));
+  int x = ((int)  tolua_tonumber(tolua_S,3,0));
+  int y = ((int)  tolua_tonumber(tolua_S,4,0));
+  int w = ((int)  tolua_tonumber(tolua_S,5,0));
+  int h = ((int)  tolua_tonumber(tolua_S,6,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'openWebpage'", NULL);
+#endif
+  {
+   self->openWebpage(url,x,y,w,h);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'openWebpage'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: closeWebpage of class  WebviewDelegate */
+#ifndef TOLUA_DISABLE_tolua_Extension_WebviewDelegate_closeWebpage00
+static int tolua_Extension_WebviewDelegate_closeWebpage00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"WebviewDelegate",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  WebviewDelegate* self = (WebviewDelegate*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'closeWebpage'", NULL);
+#endif
+  {
+   self->closeWebpage();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'closeWebpage'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: sharedDelegate of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_sharedDelegate00
+static int tolua_Extension_Misc_sharedDelegate00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertable(tolua_S,1,"Misc",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  {
+   Misc* tolua_ret = (Misc*)  Misc::sharedDelegate();
+    tolua_pushusertype(tolua_S,(void*)tolua_ret,"Misc");
+  }
+ }
+ return 1;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'sharedDelegate'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: copyToPasteboard of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_copyToPasteboard00
+static int tolua_Extension_Misc_copyToPasteboard00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+  const char* content = ((const char*)  tolua_tostring(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'copyToPasteboard'", NULL);
+#endif
+  {
+   self->copyToPasteboard(content);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'copyToPasteboard'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: selectImage of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_selectImage00
+static int tolua_Extension_Misc_selectImage00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,3,0,&tolua_err) ||
+     !tolua_isnumber(tolua_S,4,0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,5,&tolua_err) || !toluafix_isfunction(tolua_S,5,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,6,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+  char* path = ((char*)  tolua_tostring(tolua_S,2,0));
+  int width = ((int)  tolua_tonumber(tolua_S,3,0));
+  int height = ((int)  tolua_tonumber(tolua_S,4,0));
+  LUA_FUNCTION handler = (  toluafix_ref_function(tolua_S,5,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'selectImage'", NULL);
+#endif
+  {
+   self->selectImage(path,width,height,handler);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'selectImage'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: sendMail of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_sendMail00
+static int tolua_Extension_Misc_sendMail00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isstring(tolua_S,3,0,&tolua_err) ||
+     !tolua_isstring(tolua_S,4,0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,5,&tolua_err) || !toluafix_isfunction(tolua_S,5,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,6,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+  char* receiver = ((char*)  tolua_tostring(tolua_S,2,0));
+  char* subject = ((char*)  tolua_tostring(tolua_S,3,0));
+  char* body = ((char*)  tolua_tostring(tolua_S,4,0));
+  LUA_FUNCTION errorHandler = (  toluafix_ref_function(tolua_S,5,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'sendMail'", NULL);
+#endif
+  {
+   self->sendMail(receiver,subject,body,errorHandler);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'sendMail'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setFileToRequestData of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_setFileToRequestData00
+static int tolua_Extension_Misc_setFileToRequestData00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     !tolua_isusertype(tolua_S,2,"HttpRequestForLua",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,3,0,&tolua_err) ||
+     !tolua_isstring(tolua_S,4,0,&tolua_err) ||
+     !tolua_isstring(tolua_S,5,0,&tolua_err) ||
+     !tolua_isstring(tolua_S,6,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,7,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+  HttpRequestForLua* request = ((HttpRequestForLua*)  tolua_tousertype(tolua_S,2,0));
+  const char* begin = ((const char*)  tolua_tostring(tolua_S,3,0));
+  const char* end = ((const char*)  tolua_tostring(tolua_S,4,0));
+  const char* filePath = ((const char*)  tolua_tostring(tolua_S,5,0));
+  const char* pszMode = ((const char*)  tolua_tostring(tolua_S,6,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setFileToRequestData'", NULL);
+#endif
+  {
+   self->setFileToRequestData(request,begin,end,filePath,pszMode);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setFileToRequestData'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: sendSMS of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_sendSMS00
+static int tolua_Extension_Misc_sendSMS00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,3,&tolua_err) || !toluafix_isfunction(tolua_S,3,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,4,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+  char* body = ((char*)  tolua_tostring(tolua_S,2,0));
+  LUA_FUNCTION errorHandler = (  toluafix_ref_function(tolua_S,3,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'sendSMS'", NULL);
+#endif
+  {
+   self->sendSMS(body,errorHandler);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'sendSMS'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getDeepLink of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_getDeepLink00
+static int tolua_Extension_Misc_getDeepLink00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !toluafix_isfunction(tolua_S,2,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+  LUA_FUNCTION handler = (  toluafix_ref_function(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'getDeepLink'", NULL);
+#endif
+  {
+   self->getDeepLink(handler);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'getDeepLink'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: addEventListenerDeepLink of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_addEventListenerDeepLink00
+static int tolua_Extension_Misc_addEventListenerDeepLink00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !toluafix_isfunction(tolua_S,2,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+  LUA_FUNCTION handler = (  toluafix_ref_function(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'addEventListenerDeepLink'", NULL);
+#endif
+  {
+   self->addEventListenerDeepLink(handler);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'addEventListenerDeepLink'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: getUADeviceToken of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_getUADeviceToken00
+static int tolua_Extension_Misc_getUADeviceToken00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !toluafix_isfunction(tolua_S,2,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+  LUA_FUNCTION handler = (  toluafix_ref_function(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'getUADeviceToken'", NULL);
+#endif
+  {
+   self->getUADeviceToken(handler);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'getUADeviceToken'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: setUADeviceTokenHandler of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_setUADeviceTokenHandler00
+static int tolua_Extension_Misc_setUADeviceTokenHandler00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     (tolua_isvaluenil(tolua_S,2,&tolua_err) || !toluafix_isfunction(tolua_S,2,"LUA_FUNCTION",0,&tolua_err)) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+  LUA_FUNCTION handler = (  toluafix_ref_function(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'setUADeviceTokenHandler'", NULL);
+#endif
+  {
+   self->setUADeviceTokenHandler(handler);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'setUADeviceTokenHandler'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: requestPushNotification of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_requestPushNotification00
+static int tolua_Extension_Misc_requestPushNotification00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'requestPushNotification'", NULL);
+#endif
+  {
+   self->requestPushNotification();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'requestPushNotification'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: openUrl of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_openUrl00
+static int tolua_Extension_Misc_openUrl00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     !tolua_isstring(tolua_S,2,0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,3,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+  char* url = ((char*)  tolua_tostring(tolua_S,2,0));
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'openUrl'", NULL);
+#endif
+  {
+   self->openUrl(url);
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'openUrl'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: openRate of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_openRate00
+static int tolua_Extension_Misc_openRate00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'openRate'", NULL);
+#endif
+  {
+   self->openRate();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'openRate'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* method: terminate of class  Misc */
+#ifndef TOLUA_DISABLE_tolua_Extension_Misc_terminate00
+static int tolua_Extension_Misc_terminate00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+ tolua_Error tolua_err;
+ if (
+     !tolua_isusertype(tolua_S,1,"Misc",0,&tolua_err) ||
+     !tolua_isnoobj(tolua_S,2,&tolua_err)
+ )
+  goto tolua_lerror;
+ else
+#endif
+ {
+  Misc* self = (Misc*)  tolua_tousertype(tolua_S,1,0);
+#ifndef TOLUA_RELEASE
+  if (!self) tolua_error(tolua_S,"invalid 'self' in function 'terminate'", NULL);
+#endif
+  {
+   self->terminate();
+  }
+ }
+ return 0;
+#ifndef TOLUA_RELEASE
+ tolua_lerror:
+ tolua_error(tolua_S,"#ferror in function 'terminate'.",&tolua_err);
+ return 0;
+#endif
+}
+#endif //#ifndef TOLUA_DISABLE
+
+/* Open function */
+TOLUA_API int tolua_Extension_open (lua_State* tolua_S)
+{
+ tolua_open(tolua_S);
+ tolua_reg_types(tolua_S);
+ tolua_module(tolua_S,NULL,0);
+ tolua_beginmodule(tolua_S,NULL);
+  tolua_cclass(tolua_S,"FacebookDelegate","FacebookDelegate","",NULL);
+  tolua_beginmodule(tolua_S,"FacebookDelegate");
+   tolua_function(tolua_S,"sharedDelegate",tolua_Extension_FacebookDelegate_sharedDelegate00);
+   tolua_function(tolua_S,"login",tolua_Extension_FacebookDelegate_login00);
+   tolua_function(tolua_S,"grantPublishPermission",tolua_Extension_FacebookDelegate_grantPublishPermission00);
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,"CCHttpRequest","CCHttpRequest","CCObject",NULL);
+  tolua_beginmodule(tolua_S,"CCHttpRequest");
+   tolua_constant(tolua_S,"kHttpGet",CCHttpRequest::kHttpGet);
+   tolua_constant(tolua_S,"kHttpPost",CCHttpRequest::kHttpPost);
+   tolua_constant(tolua_S,"kHttpPut",CCHttpRequest::kHttpPut);
+   tolua_constant(tolua_S,"kHttpDelete",CCHttpRequest::kHttpDelete);
+   tolua_constant(tolua_S,"kHttpUnkown",CCHttpRequest::kHttpUnkown);
+   tolua_constant(tolua_S,"pVeryLow",CCHttpRequest::pVeryLow);
+   tolua_constant(tolua_S,"pLow",CCHttpRequest::pLow);
+   tolua_constant(tolua_S,"pMedium",CCHttpRequest::pMedium);
+   tolua_constant(tolua_S,"pHigh",CCHttpRequest::pHigh);
+   tolua_constant(tolua_S,"pVeryHigh",CCHttpRequest::pVeryHigh);
+   tolua_function(tolua_S,"setRequestType",tolua_Extension_CCHttpRequest_setRequestType00);
+   tolua_function(tolua_S,"getRequestType",tolua_Extension_CCHttpRequest_getRequestType00);
+   tolua_function(tolua_S,"setUrl",tolua_Extension_CCHttpRequest_setUrl00);
+   tolua_function(tolua_S,"getUrl",tolua_Extension_CCHttpRequest_getUrl00);
+   tolua_function(tolua_S,"setRequestData",tolua_Extension_CCHttpRequest_setRequestData00);
+   tolua_function(tolua_S,"getRequestData",tolua_Extension_CCHttpRequest_getRequestData00);
+   tolua_function(tolua_S,"getRequestDataSize",tolua_Extension_CCHttpRequest_getRequestDataSize00);
+   tolua_function(tolua_S,"setTag",tolua_Extension_CCHttpRequest_setTag00);
+   tolua_function(tolua_S,"getTag",tolua_Extension_CCHttpRequest_getTag00);
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,"HttpRequestForLua","HttpRequestForLua","CCObject",NULL);
+  tolua_beginmodule(tolua_S,"HttpRequestForLua");
+   tolua_function(tolua_S,"create",tolua_Extension_HttpRequestForLua_create00);
+   tolua_function(tolua_S,"addHeader",tolua_Extension_HttpRequestForLua_addHeader00);
+   tolua_function(tolua_S,"setUserpwd",tolua_Extension_HttpRequestForLua_setUserpwd00);
+   tolua_function(tolua_S,"setPriority",tolua_Extension_HttpRequestForLua_setPriority00);
+   tolua_function(tolua_S,"sendHttpRequest",tolua_Extension_HttpRequestForLua_sendHttpRequest00);
+   tolua_function(tolua_S,"onHttpRequestCompleted",tolua_Extension_HttpRequestForLua_onHttpRequestCompleted00);
+   tolua_function(tolua_S,"setRequest",tolua_Extension_HttpRequestForLua_setRequest00);
+   tolua_function(tolua_S,"getRequest",tolua_Extension_HttpRequestForLua_getRequest00);
+  tolua_endmodule(tolua_S);
+  tolua_constant(tolua_S,"EDIT_BOX_EVENT_DID_BEGIN",EDIT_BOX_EVENT_DID_BEGIN);
+  tolua_constant(tolua_S,"EDIT_BOX_EVENT_DID_END",EDIT_BOX_EVENT_DID_END);
+  tolua_constant(tolua_S,"EDIT_BOX_EVENT_TEXT_CHANGED",EDIT_BOX_EVENT_TEXT_CHANGED);
+  tolua_constant(tolua_S,"EDIT_BOX_EVENT_RETURN",EDIT_BOX_EVENT_RETURN);
+  tolua_constant(tolua_S,"EDIT_BOX_EVENT_MAX",EDIT_BOX_EVENT_MAX);
+  tolua_cclass(tolua_S,"CCEditBoxDelegate","CCEditBoxDelegate","",NULL);
+  tolua_beginmodule(tolua_S,"CCEditBoxDelegate");
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,"EditBoxDelegateForLua","EditBoxDelegateForLua","CCLayer",NULL);
+  tolua_beginmodule(tolua_S,"EditBoxDelegateForLua");
+   tolua_function(tolua_S,"create",tolua_Extension_EditBoxDelegateForLua_create00);
+   tolua_function(tolua_S,"registerEventScriptHandler",tolua_Extension_EditBoxDelegateForLua_registerEventScriptHandler00);
+   tolua_function(tolua_S,"unregisterEventScriptHandler",tolua_Extension_EditBoxDelegateForLua_unregisterEventScriptHandler00);
+   tolua_variable(tolua_S,"__CCEditBoxDelegate__",tolua_get_EditBoxDelegateForLua___CCEditBoxDelegate__,NULL);
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,"Analytics","Analytics","",NULL);
+  tolua_beginmodule(tolua_S,"Analytics");
+   tolua_function(tolua_S,"sharedDelegate",tolua_Extension_Analytics_sharedDelegate00);
+   tolua_function(tolua_S,"postEvent",tolua_Extension_Analytics_postEvent00);
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,"WebviewDelegate","WebviewDelegate","",NULL);
+  tolua_beginmodule(tolua_S,"WebviewDelegate");
+   tolua_function(tolua_S,"sharedDelegate",tolua_Extension_WebviewDelegate_sharedDelegate00);
+   tolua_function(tolua_S,"openWebpage",tolua_Extension_WebviewDelegate_openWebpage00);
+   tolua_function(tolua_S,"closeWebpage",tolua_Extension_WebviewDelegate_closeWebpage00);
+  tolua_endmodule(tolua_S);
+  tolua_cclass(tolua_S,"Misc","Misc","",NULL);
+  tolua_beginmodule(tolua_S,"Misc");
+   tolua_function(tolua_S,"sharedDelegate",tolua_Extension_Misc_sharedDelegate00);
+   tolua_function(tolua_S,"copyToPasteboard",tolua_Extension_Misc_copyToPasteboard00);
+   tolua_function(tolua_S,"selectImage",tolua_Extension_Misc_selectImage00);
+   tolua_function(tolua_S,"sendMail",tolua_Extension_Misc_sendMail00);
+   tolua_function(tolua_S,"setFileToRequestData",tolua_Extension_Misc_setFileToRequestData00);
+   tolua_function(tolua_S,"sendSMS",tolua_Extension_Misc_sendSMS00);
+   tolua_function(tolua_S,"getDeepLink",tolua_Extension_Misc_getDeepLink00);
+   tolua_function(tolua_S,"addEventListenerDeepLink",tolua_Extension_Misc_addEventListenerDeepLink00);
+   tolua_function(tolua_S,"getUADeviceToken",tolua_Extension_Misc_getUADeviceToken00);
+   tolua_function(tolua_S,"setUADeviceTokenHandler",tolua_Extension_Misc_setUADeviceTokenHandler00);
+   tolua_function(tolua_S,"requestPushNotification",tolua_Extension_Misc_requestPushNotification00);
+   tolua_function(tolua_S,"openUrl",tolua_Extension_Misc_openUrl00);
+   tolua_function(tolua_S,"openRate",tolua_Extension_Misc_openRate00);
+   tolua_function(tolua_S,"terminate",tolua_Extension_Misc_terminate00);
   tolua_endmodule(tolua_S);
  tolua_endmodule(tolua_S);
  return 1;
diff --git a/scripting/lua/cocos2dx_support/lua_cocos2dx_cocostudio_manual.cpp b/scripting/lua/cocos2dx_support/lua_cocos2dx_cocostudio_manual.cpp
old mode 100644
new mode 100755
index 347569c..c250f3b
--- a/scripting/lua/cocos2dx_support/lua_cocos2dx_cocostudio_manual.cpp
+++ b/scripting/lua/cocos2dx_support/lua_cocos2dx_cocostudio_manual.cpp
@@ -363,6 +363,55 @@ static void extendListView(lua_State* tolua_S)
     lua_pop(tolua_S, 1);
 }
 
+static int tolua_Cocos2dx_ScrollView_addEventListenerScrollView00(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+	tolua_Error tolua_err;
+	if (
+		!tolua_isusertype(tolua_S, 1, "ScrollView", 0, &tolua_err) ||
+		!toluafix_isfunction(tolua_S, 2, "LUA_FUNCTION", 0, &tolua_err) ||
+		!tolua_isnoobj(tolua_S, 3, &tolua_err)
+		)
+		goto tolua_lerror;
+	else
+#endif
+	{
+		ScrollView* self = (ScrollView*)tolua_tousertype(tolua_S, 1, 0);
+#ifndef TOLUA_RELEASE
+		if (!self) tolua_error(tolua_S, "invalid 'self' in function 'addTouchEventListener'", NULL);
+#endif
+		LuaCocoStudioEventListener* listener = LuaCocoStudioEventListener::create();
+		if (NULL == listener)
+		{
+			tolua_error(tolua_S, "LuaCocoStudioEventListener create fail\n", NULL);
+			return 0;
+		}
+
+		LUA_FUNCTION handler = (toluafix_ref_function(tolua_S, 2, 0));
+
+		listener->setHandler(handler);
+		self->setUserObject(listener);
+		self->addEventListenerScrollView(listener, scrollvieweventselector(LuaCocoStudioEventListener::eventCallbackFunc));
+	}
+	return 0;
+#ifndef TOLUA_RELEASE
+tolua_lerror :
+	tolua_error(tolua_S, "#ferror in function 'addEventListenerScrollView'.", &tolua_err);
+	return 0;
+#endif
+}
+
+static void extendScrollView(lua_State* tolua_S)
+{
+	lua_pushstring(tolua_S, "ScrollView");
+	lua_rawget(tolua_S, LUA_REGISTRYINDEX);
+	if (lua_istable(tolua_S, -1))
+	{
+		tolua_function(tolua_S, "addEventListenerScrollView", tolua_Cocos2dx_ScrollView_addEventListenerScrollView00);
+	}
+	lua_pop(tolua_S, 1);
+}
+
 static int tolua_Cocos2dx_LayoutParameter_setMargin00(lua_State* tolua_S)
 {
 #ifndef TOLUA_RELEASE
@@ -728,6 +777,7 @@ int register_all_cocos2dx_studio_manual(lua_State* tolua_S)
     extendTextFieldr(tolua_S);
     extendPageView(tolua_S);
     extendListView(tolua_S);
+	extendScrollView(tolua_S);
 	extendLayoutParameter(tolua_S);
     extendCCArmatureAnimation(tolua_S);
     extendCCArmatureDataManager(tolua_S);
diff --git a/scripting/lua/cocos2dx_support/lua_cocos2dx_extensions_manual.cpp b/scripting/lua/cocos2dx_support/lua_cocos2dx_extensions_manual.cpp
old mode 100644
new mode 100755
index cee9982..92f10bd
--- a/scripting/lua/cocos2dx_support/lua_cocos2dx_extensions_manual.cpp
+++ b/scripting/lua/cocos2dx_support/lua_cocos2dx_extensions_manual.cpp
@@ -13,10 +13,11 @@ extern "C" {
 #include "CCLuaStack.h"
 #include "CCLuaValue.h"
 #include "CCLuaEngine.h"
-
+#include "Misc.h"
 
 USING_NS_CC;
 USING_NS_CC_EXT;
+using namespace Utils;
 
 class LuaScrollViewDelegate:public CCObject, public CCScrollViewDelegate
 {
@@ -111,6 +112,55 @@ static void extendCCScrollView(lua_State* tolua_S)
     lua_pop(tolua_S, 1);
 }
 
+static int tolua_Cocos2dx_Misc_createFormWithFile(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+	tolua_Error tolua_err;
+	if (
+		!tolua_isusertype(tolua_S, 1, "Misc", 0, &tolua_err) ||
+		!tolua_isstring(tolua_S, 2, 0, &tolua_err) ||
+		!tolua_isstring(tolua_S, 3, 0, &tolua_err) ||
+		!tolua_isstring(tolua_S, 4, 0, &tolua_err) ||
+		!tolua_isstring(tolua_S, 5, 0, &tolua_err) ||
+		!tolua_isnoobj(tolua_S, 6, &tolua_err)
+		)
+		goto tolua_lerror;
+	else
+#endif
+	{
+		Misc* self = (Misc*)tolua_tousertype(tolua_S, 1, 0);
+#ifndef TOLUA_RELEASE
+		if (!self) tolua_error(tolua_S, "invalid 'self' in function 'createFormWithFile'", NULL);
+#endif
+		const char* begin = ((const char*)tolua_tostring(tolua_S, 2, 0));
+		const char* end = ((const char*)tolua_tostring(tolua_S, 3, 0));
+		const char* filePath = ((const char*)tolua_tostring(tolua_S, 4, 0));
+		const char* pszMode = ((const char*)tolua_tostring(tolua_S, 5, 0));
+		unsigned long pSize = 0;
+
+		unsigned char* tolua_ret = (unsigned char*)self->createFormWithFile(begin, end, filePath, pszMode, &pSize);
+		tolua_pushstring(tolua_S, (const char*)tolua_ret);
+		tolua_pushnumber(tolua_S, (lua_Number)pSize);
+	}
+	return 2;
+#ifndef TOLUA_RELEASE
+tolua_lerror :
+	tolua_error(tolua_S, "#ferror in function 'createFormWithFile'.", &tolua_err);
+	return 0;
+#endif
+}
+
+static void extendMisc(lua_State* tolua_S)
+{
+	lua_pushstring(tolua_S, "Misc");
+	lua_rawget(tolua_S, LUA_REGISTRYINDEX);
+	if (lua_istable(tolua_S, -1))
+	{
+		tolua_function(tolua_S, "createFormWithFile", tolua_Cocos2dx_Misc_createFormWithFile);
+	}
+	lua_pop(tolua_S, 1);
+}
+
 #define KEY_TABLEVIEW_DATA_SOURCE  "TableViewDataSource"
 #define KEY_TABLEVIEW_DELEGATE     "TableViewDelegate"
 
@@ -529,5 +579,6 @@ int register_all_cocos2dx_extension_manual(lua_State* tolua_S)
     extendCCScrollView(tolua_S);
     extendCCTableView(tolua_S);
     extendCCTableViewCell(tolua_S);
+	extendMisc(tolua_S);
     return 0;
 }
\ No newline at end of file
diff --git a/scripting/lua/cocos2dx_support/lua_cocos2dx_manual.cpp b/scripting/lua/cocos2dx_support/lua_cocos2dx_manual.cpp
old mode 100644
new mode 100755
index 97a231e..f4f5172
--- a/scripting/lua/cocos2dx_support/lua_cocos2dx_manual.cpp
+++ b/scripting/lua/cocos2dx_support/lua_cocos2dx_manual.cpp
@@ -4,6 +4,7 @@
 extern "C" {
 #endif
 #include  "tolua_fix.h"
+#include "des56.h"
 #ifdef __cplusplus
 }
 #endif
@@ -337,11 +338,107 @@ static void extendCCTwirl(lua_State* tolua_S)
     lua_pop(tolua_S, 1);
 }
 
+static int tolua_Cocos2d_CCFileUtils_getDecryptedFileData(lua_State* tolua_S)
+{
+#ifndef TOLUA_RELEASE
+	tolua_Error tolua_err;
+	if (
+		!tolua_isusertype(tolua_S, 1, "CCFileUtils", 0, &tolua_err) ||
+		!tolua_isstring(tolua_S, 2, 0, &tolua_err) ||
+		!tolua_isstring(tolua_S, 3, 0, &tolua_err) ||
+		!tolua_isnoobj(tolua_S, 4, &tolua_err)
+		)
+		goto tolua_lerror;
+	else
+#endif
+	{
+		CCFileUtils* self = (CCFileUtils*)tolua_tousertype(tolua_S, 1, 0);
+#ifndef TOLUA_RELEASE
+		if (!self) tolua_error(tolua_S, "invalid 'self' in function 'getDecryptedFileData'", NULL);
+#endif
+		const char* filePath = ((const char*)tolua_tostring(tolua_S, 2, 0));
+		const char* pszMode = ((const char*)tolua_tostring(tolua_S, 3, 0));
+		unsigned long pSize = 0;
+
+		unsigned char* cypheredText = (unsigned char*)self->getFileData(filePath, pszMode, &pSize);
+
+		char* decypheredText;
+		keysched KS;
+		int rel_index, abs_index;
+		unsigned long cypherlen = pSize;
+		const char *key = "tuantuan";
+		int padinfo;
+
+		padinfo = cypheredText[cypherlen - 1];
+		cypherlen--;
+
+		/* Aloca array */
+		decypheredText =
+			(char *)malloc((cypherlen + 1) * sizeof(char));
+		if (decypheredText == NULL) {
+			lua_pushstring(tolua_S, "Error decrypting file. Not enough memory.");
+			goto tolua_lerror;
+		}
+
+		/* Inicia decifragem */
+		if (key && strlen(key) >= 8)
+		{
+			char k[8];
+			int i;
+
+			for (i = 0; i < 8; i++)
+				k[i] = (unsigned char)key[i];
+			fsetkey(k, &KS);
+		}
+		else {
+			lua_pushstring(tolua_S, "Error decrypting file. Invalid key.");
+			goto tolua_lerror;
+		}
+
+		rel_index = 0;
+		abs_index = 0;
+
+		while (abs_index < (int)cypherlen)
+		{
+			decypheredText[abs_index] = cypheredText[abs_index];
+			abs_index++;
+			rel_index++;
+			if (rel_index == 8)
+			{
+				rel_index = 0;
+				fencrypt(&(decypheredText[abs_index - 8]), 1, &KS);
+			}
+		}
+		decypheredText[abs_index] = 0;
+
+		lua_pushlstring(tolua_S, decypheredText, (abs_index - padinfo));
+		free(decypheredText);
+	}
+	return 1;
+#ifndef TOLUA_RELEASE
+tolua_lerror :
+	tolua_error(tolua_S, "#ferror in function 'getDecryptedFileData'.", &tolua_err);
+	return 0;
+#endif
+}
+
+static void extendFileUtils(lua_State* tolua_S)
+{
+	lua_pushstring(tolua_S, "CCFileUtils");
+	lua_rawget(tolua_S, LUA_REGISTRYINDEX);
+	if (lua_istable(tolua_S, -1))
+	{
+		tolua_function(tolua_S, "getDecryptedFileData", tolua_Cocos2d_CCFileUtils_getDecryptedFileData);
+	}
+	lua_pop(tolua_S, 1);
+}
+
 int register_all_cocos2dx_manual(lua_State* tolua_S)
 {
     extendCCNode(tolua_S);
     extendCCLens3D(tolua_S);
     extendCCRipple3D(tolua_S);
     extendCCTwirl(tolua_S);
+	extendFileUtils(tolua_S);
     return 0;
 }
diff --git a/scripting/lua/crypt/des56.c b/scripting/lua/crypt/des56.c
new file mode 100755
index 0000000..1fb377b
--- /dev/null
+++ b/scripting/lua/crypt/des56.c
@@ -0,0 +1,548 @@
+
+/*
+ * Fast implementation of the DES, as described in the Federal Register,
+ * Vol. 40, No. 52, p. 12134, March 17, 1975.
+ *
+ * Stuart Levy, Minnesota Supercomputer Center, April 1988.
+ * Currently (2007) slevy@ncsa.uiuc.edu
+ * NCSA, University of Illinois Urbana-Champaign
+ *
+ * Calling sequence:
+ *
+ * typedef unsigned long keysched[32];
+ *
+ * fsetkey(key, keysched)	/ * Converts a DES key to a "key schedule" * /
+ *	unsigned char	key[8];
+ *	keysched	*ks;
+ *
+ * fencrypt(block, decrypt, keysched)	/ * En/decrypts one 64-bit block * /
+ *	unsigned char	block[8];	/ * data, en/decrypted in place * /
+ *	int		decrypt;	/ * 0=>encrypt, 1=>decrypt * /
+ *	keysched	*ks;		/ * key schedule, as set by fsetkey * /
+ *
+ * Key and data block representation:
+ * The 56-bit key (bits 1..64 including "parity" bits 8, 16, 24, ..., 64)
+ * and the 64-bit data block (bits 1..64)
+ * are each stored in arrays of 8 bytes.
+ * Following the NBS numbering, the MSB has the bit number 1, so
+ *  key[0] = 128*bit1 + 64*bit2 + ... + 1*bit8, ... through
+ *  key[7] = 128*bit57 + 64*bit58 + ... + 1*bit64.
+ * In the key, "parity" bits are not checked; their values are ignored.
+ *
+*/
+
+/*
+===============================================================================
+License
+
+des56.c is licensed under the terms of the MIT license reproduced below.
+This means that des56.c is free software and can be used for both academic
+and commercial purposes at absolutely no cost.
+===============================================================================
+Copyright (C) 1988 Stuart Levy
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+ */
+
+
+#include "des56.h"
+
+
+/*
+ * Key schedule generation.
+ * We begin by pointlessly permuting the 56 useful key bits into
+ * two groups of 28 bits called C and D.
+ * bK_C and bK_D are indexed by C and D bit numbers, respectively,
+ * and give the key bit number (1..64) which should initialize that C/D bit.
+ * This is the "permuted choice 1" table.
+ */
+
+static tiny bK_C[28] = {
+	57, 49, 41, 33, 25, 17,  9,
+	 1, 58, 50, 42, 34, 26, 18,
+	10,  2, 59, 51, 43, 35, 27,
+	19, 11,  3, 60, 52, 44, 36,
+};
+static tiny bK_D[28] = {
+	63, 55, 47, 39, 31, 23, 15,
+	 7, 62, 54, 46, 38, 30, 22,
+	14,  6, 61, 53, 45, 37, 29,
+	21, 13,  5, 28, 20, 12, 4,
+};
+
+/*
+ * For speed, we invert these, building tables to map groups of
+ * key bits into the corresponding C and D bits.
+ * We represent C and D each as 28 contiguous bits right-justified in a
+ * word, padded on the left with zeros.
+ * If key byte `i' is said to contain bits Ki,0 (MSB) Ki,1 ... Ki,7 (LSB)
+ * then
+ *	wC_K4[i][Ki,0 Ki,1 Ki,2 Ki,3] gives the C bits for Ki,0..3,
+ *	wD_K4[i][Ki,0 Ki,1 Ki,2 Ki,3] the corresponding D bits,
+ *	wC_K3[i][Ki,4 Ki,5 Ki,6] the C bits for Ki,4..6,
+ * and	wD_K3[i][Ki,4 Ki,5 Ki,6] the D bits for Ki,4..6.
+ * Ki,7 is ignored since it is the nominal parity bit.
+ * We could just use a single table for [i][Ki,0 .. Ki,6] but that
+ * would take a lot of storage for such a rarely-used function.
+ */
+
+static	word32 wC_K4[8][16], wC_K3[8][8];
+static	word32 wD_K4[8][16], wD_K3[8][8];
+
+/*
+ * Successive Ci and Di for the sixteen steps in the key schedule are
+ * created by independent 28-bit left circular shifts on C and D.
+ * The shift count varies with the step number.
+ */
+static tiny preshift[16] = {
+	1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1,
+};
+
+/*
+ * Each step in the key schedule is generated by selecting 48 bits
+ * (8 groups of 6 bits) from the appropriately shifted Ci and Di.
+ * bCD_KS, indexed by the key schedule bit number, gives the bit number
+ * in CD (CD1 = MSB of C, CD28 = LSB of C, CD29 = MSB of D, CD56 = LSB of D)
+ * which determines that bit of the key schedule.
+ * Note that only C bits (1..28) appear in the first (upper) 24 bits of
+ * the key schedule, and D bits (29..56) in the second (lower) 24 bits.
+ * This is the "permuted-choice-2" table.
+ */
+
+static tiny bCD_KS[48] = {
+	14, 17, 11, 24,  1,  5,
+	3,  28, 15,  6, 21, 10,
+	23, 19, 12,  4, 26,  8,
+	16,  7, 27, 20, 13,  2,
+	41, 52, 31, 37, 47, 55,
+	30, 40, 51, 45, 33, 48,
+	44, 49, 39, 56, 34, 53,
+	46, 42, 50, 36, 29, 32,
+};
+
+/*
+ * We invert bCD_KS into a pair of tables which map groups of 4
+ * C or D bits into corresponding key schedule bits.
+ * We represent each step of the key schedule as 8 groups of 8 bits,
+ * with the 6 real bits right-justified in each 8-bit group.
+ * hKS_C4[i][C4i+1 .. C4i+4] gives the bits in the high order (first four)
+ * key schedule "bytes" which correspond to C bits 4i+1 .. 4i+4.
+ * lKS_D4[i][D4i+1 .. D4i+4] gives the appropriate bits in the latter (last 4)
+ * key schedule bytes, from the corresponding D bits.
+ */
+
+static word32 hKS_C4[7][16];
+static word32 lKS_D4[7][16];
+
+/*
+ * Encryption/decryption.
+ * Before beginning, and after ending, we perform another useless permutation
+ * on the bits in the data block.
+ *
+ * The initial permutation and its inverse, final permutation
+ * are too simple to need a table for.	If we break the input I1 .. I64 into
+ * 8-bit chunks I0,0 I0,1 ... I0,7 I1,0 I1,1 ... I7,7
+ * then the initial permutation sets LR as follows:
+ * L = I7,1 I6,1 I5,1 ... I0,1	I7,3 I6,3 ... I0,3  I7,5 ... I0,5  I7,7 ... I0,7
+ * and
+ * R = I7,0 I6,0 I5,0 ... I0,0	I7,2 I6,2 ... I0,2  I7,4 ... I0,4  I7,6 ... I0,6
+ *
+ * If we number the bits in the final LR similarly,
+ * L = L0,0 L0,1 ... L3,7  R = R0,0 R0,1 ... R3,7
+ * then the output is
+ * O = R0,7 L0,7 R1,7 L1,7 ... R3,7 L3,7 R0,6 L0,6 ... L3,6 R0,5 ... R3,0 L3,0
+ *
+ * To speed I => LR shuffling we use an array of 32-bit values indexed by
+ * 8-bit input bytes.
+ * wL_I8[ 0 I0,1 0 I0,3 0 I0,5 0 I0,7 ] = the corresponding L bits.
+ * Other R and L bits are derived from wL_I8 by shifting.
+ *
+ * To speed LR => O shuffling, an array of 32-bit values indexed by 4-bit lumps:
+ * wO_L4[ L0,4 L0,5 L0,6 L0,7 ] = the corresponding high-order 32 O bits.
+ */
+
+static word32 wL_I8[0x55 + 1];
+static word32 wO_L4[16];
+
+/*
+ * Core of encryption/decryption.
+ * In each key schedule stage, we:
+ *	take 8 overlapping groups of 6 bits each from R
+ *	   (the NBS tabulates the bit selections in the E table,
+ *	    but it's so simple we just use shifting to get the right bits)
+ *	XOR each group with the corresponding bits from the key schedule
+ *	Use the resulting 6 bits as an index into the appropriate S table
+ *	   (there are 8 such tables, one per group of 6 bits)
+ *	Each S entry yields 4 bits.
+ *	The 8 groups of 4 bits are catenated into a 32-bit value.
+ *	Those 32 bits are permuted according to the P table.
+ *	Finally the permuted 32-bit value is XORed with L and becomes
+ *	the R value for the next stage, while the previous R becomes the new L.
+ *
+ * Here, we merge the P permutation with the S tables by making the
+ * S entries be 32-bit masks, already suitably permuted.
+ * Also, the bits in each six-bit group must be permuted before use as
+ * an index into the NBS-tabulated S tables.
+ * We rearrange entries in wPS so that natural bit order can be used.
+ */
+
+static word32 wPS[8][64];
+
+static tiny P[32] = {
+	16,  7, 20, 21,
+	29, 12, 28, 17,
+	 1, 15, 23, 26,
+	 5, 18, 31, 10,
+	 2,  8, 24, 14,
+	32, 27,  3,  9,
+	19, 13, 30,  6,
+	22, 11,  4, 25,
+};
+
+static tiny S[8][64] = {
+     {
+	14, 4,13, 1, 2,15,11, 8, 3,10, 6,12, 5, 9, 0, 7,
+	 0,15, 7, 4,14, 2,13, 1,10, 6,12,11, 9, 5, 3, 8,
+	 4, 1,14, 8,13, 6, 2,11,15,12, 9, 7, 3,10, 5, 0,
+	15,12, 8, 2, 4, 9, 1, 7, 5,11, 3,14,10, 0, 6,13,
+     },
+
+     {
+	15, 1, 8,14, 6,11, 3, 4, 9, 7, 2,13,12, 0, 5,10,
+	 3,13, 4, 7,15, 2, 8,14,12, 0, 1,10, 6, 9,11, 5,
+	 0,14, 7,11,10, 4,13, 1, 5, 8,12, 6, 9, 3, 2,15,
+	13, 8,10, 1, 3,15, 4, 2,11, 6, 7,12, 0, 5,14, 9,
+     },
+
+     {
+	10, 0, 9,14, 6, 3,15, 5, 1,13,12, 7,11, 4, 2, 8,
+	13, 7, 0, 9, 3, 4, 6,10, 2, 8, 5,14,12,11,15, 1,
+	13, 6, 4, 9, 8,15, 3, 0,11, 1, 2,12, 5,10,14, 7,
+	 1,10,13, 0, 6, 9, 8, 7, 4,15,14, 3,11, 5, 2,12,
+     },
+
+     {
+	 7,13,14, 3, 0, 6, 9,10, 1, 2, 8, 5,11,12, 4,15,
+	13, 8,11, 5, 6,15, 0, 3, 4, 7, 2,12, 1,10,14, 9,
+	10, 6, 9, 0,12,11, 7,13,15, 1, 3,14, 5, 2, 8, 4,
+	 3,15, 0, 6,10, 1,13, 8, 9, 4, 5,11,12, 7, 2,14,
+     },
+
+     {
+	 2,12, 4, 1, 7,10,11, 6, 8, 5, 3,15,13, 0,14, 9,
+	14,11, 2,12, 4, 7,13, 1, 5, 0,15,10, 3, 9, 8, 6,
+	 4, 2, 1,11,10,13, 7, 8,15, 9,12, 5, 6, 3, 0,14,
+	11, 8,12, 7, 1,14, 2,13, 6,15, 0, 9,10, 4, 5, 3,
+     },
+
+     {
+	12, 1,10,15, 9, 2, 6, 8, 0,13, 3, 4,14, 7, 5,11,
+	10,15, 4, 2, 7,12, 9, 5, 6, 1,13,14, 0,11, 3, 8,
+	 9,14,15, 5, 2, 8,12, 3, 7, 0, 4,10, 1,13,11, 6,
+	 4, 3, 2,12, 9, 5,15,10,11,14, 1, 7, 6, 0, 8,13,
+     },
+
+     {
+	 4,11, 2,14,15, 0, 8,13, 3,12, 9, 7, 5,10, 6, 1,
+	13, 0,11, 7, 4, 9, 1,10,14, 3, 5,12, 2,15, 8, 6,
+	 1, 4,11,13,12, 3, 7,14,10,15, 6, 8, 0, 5, 9, 2,
+	 6,11,13, 8, 1, 4,10, 7, 9, 5, 0,15,14, 2, 3,12,
+     },
+
+     {
+	13, 2, 8, 4, 6,15,11, 1,10, 9, 3,14, 5, 0,12, 7,
+	 1,15,13, 8,10, 3, 7, 4,12, 5, 6,11, 0,14, 9, 2,
+	 7,11, 4, 1, 9,12,14, 2, 0, 6,10,13,15, 3, 5, 8,
+	 2, 1,14, 7, 4,10, 8,13,15,12, 9, 0, 3, 5, 6,11,
+     },
+};
+
+static void buildtables( void )
+{
+	register int i, j;
+	register word32 v;
+	word32 wC_K[64], wD_K[64];
+	word32 hKS_C[28], lKS_D[28];
+	int Smap[64];
+	word32 wP[32];
+
+#if USG
+#  define	ZERO(array)	memset((char *)(array), '\0', sizeof(array))
+#else
+# if BSD
+#  define	ZERO(array)	bzero((char *)(array), sizeof(array))
+# else 
+#  define	ZERO(array)	{ register word32 *p = (word32 *)(array); \
+				  i = sizeof(array) / sizeof(*p); \
+				  do { *p++ = 0; } while(--i > 0); \
+				}
+# endif 
+#endif 
+
+
+	/* Invert permuted-choice-1 (key => C,D) */
+
+	ZERO(wC_K);
+	ZERO(wD_K);
+	v = 1;
+	for(j = 28; --j >= 0; ) {
+		wC_K[ bK_C[j] - 1 ] = wD_K[ bK_D[j] - 1 ] = v;
+		v += v; 	/* (i.e. v <<= 1) */
+	}
+
+	for(i = 0; i < 64; i++) {
+	    int t = 8 >> (i & 3);
+	    for(j = 0; j < 16; j++) {
+		if(j & t) {
+		    wC_K4[i >> 3][j] |= wC_K[i];
+		    wD_K4[i >> 3][j] |= wD_K[i];
+		    if(j < 8) {
+			wC_K3[i >> 3][j] |= wC_K[i + 3];
+			wD_K3[i >> 3][j] |= wD_K[i + 3];
+		    }
+		}
+	    }
+	    /* Generate the sequence 0,1,2,3, 8,9,10,11, ..., 56,57,58,59. */
+	    if(t == 1) i += 4;
+	}
+
+	/* Invert permuted-choice-2 */
+
+	ZERO(hKS_C);
+	ZERO(lKS_D);
+	v = 1;
+	for(i = 24; (i -= 6) >= 0; ) {
+	    j = i+5;
+	    do {
+		hKS_C[ bCD_KS[j] - 1 ] = lKS_D[ bCD_KS[j+24] - 28 - 1 ] = v;
+		v += v; 	/* Like v <<= 1 but may be faster */
+	    } while(--j >= i);
+	    v <<= 2;		/* Keep byte aligned */
+	}
+
+	for(i = 0; i < 28; i++) {
+	    v = 8 >> (i & 3);
+	    for(j = 0; j < 16; j++) {
+		if(j & v) {
+		    hKS_C4[i >> 2][j] |= hKS_C[i];
+		    lKS_D4[i >> 2][j] |= lKS_D[i];
+		}
+	    }
+	}
+
+	/* Initial permutation */
+
+	for(i = 0; i <= 0x55; i++) {
+	    v = 0;
+	    if(i & 64) v =  (word32) 1 << 24;
+	    if(i & 16) v |= (word32) 1 << 16;
+	    if(i & 4)  v |= (word32) 1 << 8;
+	    if(i & 1)  v |= 1;
+	    wL_I8[i] = v;
+	}
+
+	/* Final permutation */
+
+	for(i = 0; i < 16; i++) {
+	    v = 0;
+	    if(i & 1) v = (word32) 1 << 24;
+	    if(i & 2) v |= (word32) 1 << 16;
+	    if(i & 4) v |= (word32) 1 << 8;
+	    if(i & 8) v |= (word32) 1;
+	    wO_L4[i] = v;
+	}
+
+	/* Funny bit rearrangement on second index into S tables */
+
+	for(i = 0; i < 64; i++) {
+		Smap[i] = (i & 0x20) | (i & 1) << 4 | (i & 0x1e) >> 1;
+	}
+
+	/* Invert permutation P into mask indexed by R bit number */
+
+	v = 1;
+	for(i = 32; --i >= 0; ) {
+		wP[ P[i] - 1 ] = v;
+		v += v;
+	}
+
+	/* Build bit-mask versions of S tables, indexed in natural bit order */
+
+	for(i = 0; i < 8; i++) {
+	    for(j = 0; j < 64; j++) {
+		int k, t;
+
+		t = S[i][ Smap[j] ];
+		for(k = 0; k < 4; k++) {
+		    if(t & 8)
+			wPS[i][j] |= wP[4*i + k];
+		    t += t;
+		}
+	    }
+	}
+}
+
+
+void fsetkey(char key[8], keysched *ks)
+{
+	register int i;
+	register word32 C, D;
+	static int built = 0;
+
+	if(!built) {
+		buildtables();
+		built = 1;
+	}
+
+	C = D = 0;
+	for(i = 0; i < 8; i++) {
+		register int v;
+
+		v = key[i] >> 1;	/* Discard "parity" bit */
+		C |= wC_K4[i][(v>>3) & 15] | wC_K3[i][v & 7];
+		D |= wD_K4[i][(v>>3) & 15] | wD_K3[i][v & 7];
+	}
+
+	/*
+	 * C and D now hold the suitably right-justified
+	 * 28 permuted key bits each.
+	 */
+	for(i = 0; i < 16; i++) {
+#ifdef CRAY
+#define choice2(x, v)  x[6][v&15] | x[5][(v>>4)&15] | x[4][(v>>8)&15] | \
+		    x[3][(v>>12)&15] | x[2][(v>>16)&15] | x[1][(v>>20)&15] | \
+		    x[0][(v>>24)&15]
+#else
+		register word32 *ap;
+
+#  define choice2(x, v)  ( \
+		    ap = &(x)[0][0], \
+		    ap[16*6 + (v&15)] | \
+		    ap[16*5 + ((v>>4)&15)]  | ap[16*4 + ((v>>8)&15)]  | \
+		    ap[16*3 + ((v>>12)&15)] | ap[16*2 + ((v>>16)&15)] | \
+		    ap[16*1 + ((v>>20)&15)] | ap[16*0 + ((v>>24)&15)] )
+#endif 
+
+
+		/* 28-bit left circular shift */
+		C <<= preshift[i];
+		C = ((C >> 28) & 3) | (C & (((word32)1<<28) - 1));
+		ks->KS[i].h = choice2(hKS_C4, C);
+
+		D <<= preshift[i];
+		D = ((D >> 28) & 3) | (D & (((word32)1<<28) - 1));
+		ks->KS[i].l = choice2(lKS_D4, D);
+	}
+}
+
+void
+fencrypt(char block[8], int decrypt, keysched *ks)
+{
+	int i;
+	register word32 L, R;
+	register struct keystage *ksp;
+	register word32 *ap;
+
+	/* Initial permutation */
+
+	L = R = 0;
+	i = 7;
+	ap = wL_I8;
+	do {
+		register int v;
+
+		v = block[i];	/* Could optimize according to ENDIAN */
+		L = ap[v & 0x55] | (L << 1);
+		R = ap[(v >> 1) & 0x55] | (R << 1);
+	} while(--i >= 0);
+
+	if(decrypt) {
+		ksp = &ks->KS[15];
+	} else {
+		ksp = &ks->KS[0];
+	}
+
+#ifdef CRAY
+#  define PS(i,j)	wPS[i][j]
+#else 
+#  define PS(i,j)	ap[64*(i) + (j)]
+	ap = &wPS[0][0];
+#endif 
+
+	i = 16;
+	do {
+		register word32 k, tR;
+
+		tR = (R >> 15) | (R << 17);
+
+		k = ksp->h;
+		L ^= PS(0, ((tR >> 12) ^ (k >> 24)) & 63)
+		   | PS(1, ((tR >> 8) ^ (k >> 16)) & 63)
+		   | PS(2, ((tR >> 4) ^ (k >> 8)) & 63)
+		   | PS(3, (tR ^ k) & 63);
+
+		k = ksp->l;
+		L ^= PS(4, ((R >> 11) ^ (k >> 24)) & 63)
+		   | PS(5, ((R >> 7) ^ (k >> 16)) & 63)
+		   | PS(6, ((R >> 3) ^ (k >> 8)) & 63)
+		   | PS(7, ((tR >> 16) ^ k) & 63);
+
+		tR = L;
+		L = R;
+		R = tR;
+
+
+		if(decrypt)
+			ksp--;
+		else
+			ksp++;
+	} while(--i > 0);
+	{
+		register word32 t;
+
+#ifdef CRAY
+# define FP(k)	(wO_L4[ (L >> (k)) & 15 ] << 1 | wO_L4[ (R >> (k)) & 15 ])
+#else 
+# define FP(k)	(ap[ (L >> (k)) & 15 ] << 1 | ap[ (R >> (k)) & 15 ])
+
+		ap = wO_L4;
+#endif 
+
+		t = FP(0) | (FP(8) | (FP(16) | (FP(24) << 2)) << 2) << 2;
+		R = FP(4) | (FP(12) | (FP(20) | (FP(28) << 2)) << 2) << 2;
+		L = t;
+	}
+	{
+		register word32 t;
+		register char *bp;
+
+		bp = &block[7];
+		t = R;
+		*bp = t & 255;
+		*--bp = (t >>= 8) & 255;
+		*--bp = (t >>= 8) & 255;
+		*--bp = (t >> 8) & 255;
+		t = L;
+		*--bp = t & 255;
+		*--bp = (t >>= 8) & 255;
+		*--bp = (t >>= 8) & 255;
+		*--bp = (t >> 8) & 255;
+	}
+}
+
diff --git a/scripting/lua/crypt/des56.h b/scripting/lua/crypt/des56.h
new file mode 100755
index 0000000..88e5f13
--- /dev/null
+++ b/scripting/lua/crypt/des56.h
@@ -0,0 +1,77 @@
+#ifndef DES56_H
+#define DES56_H 1
+/*
+ * Fast implementation of the DES, as described in the Federal Register,
+ * Vol. 40, No. 52, p. 12134, March 17, 1975.
+ *
+ * Stuart Levy, Minnesota Supercomputer Center, April 1988.
+ * Currently (2007) slevy@ncsa.uiuc.edu
+ * NCSA, University of Illinois Urbana-Champaign
+ *
+ * Calling sequence:
+ *
+ * typedef unsigned long keysched[32];
+ *
+ * fsetkey(key, keysched)	/ * Converts a DES key to a "key schedule" * /
+ *	unsigned char	key[8];
+ *	keysched	*ks;
+ *
+ * fencrypt(block, decrypt, keysched)	/ * En/decrypts one 64-bit block * /
+ *	unsigned char	block[8];	/ * data, en/decrypted in place * /
+ *	int		decrypt;	/ * 0=>encrypt, 1=>decrypt * /
+ *	keysched	*ks;		/ * key schedule, as set by fsetkey * /
+ *
+ * Key and data block representation:
+ * The 56-bit key (bits 1..64 including "parity" bits 8, 16, 24, ..., 64)
+ * and the 64-bit data block (bits 1..64)
+ * are each stored in arrays of 8 bytes.
+ * Following the NBS numbering, the MSB has the bit number 1, so
+ *  key[0] = 128*bit1 + 64*bit2 + ... + 1*bit8, ... through
+ *  key[7] = 128*bit57 + 64*bit58 + ... + 1*bit64.
+ * In the key, "parity" bits are not checked; their values are ignored.
+ *
+*/
+
+/*
+===============================================================================
+License
+
+des56.c is licensed under the terms of the MIT license reproduced below.
+This means that des56.c is free software and can be used for both academic
+and commercial purposes at absolutely no cost.
+===============================================================================
+Copyright (C) 1988 Stuart Levy
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+ */
+
+typedef unsigned long word32;
+typedef unsigned char tiny;
+
+typedef struct keysched {
+	struct keystage {
+		word32 h, l;
+	} KS[16];
+} keysched;
+
+extern void fsetkey(char key[8], keysched *ks);
+
+extern void fencrypt(char block[8], int decrypt, keysched *ks);
+
+#endif /*DES56_H*/
diff --git a/scripting/lua/crypt/ldes56.c b/scripting/lua/crypt/ldes56.c
new file mode 100755
index 0000000..0b5ad8d
--- /dev/null
+++ b/scripting/lua/crypt/ldes56.c
@@ -0,0 +1,157 @@
+#include <stdlib.h>
+#include <string.h>
+
+#include "des56.h"
+
+#include "lua.h"
+#include "lauxlib.h"
+
+#include "ldes56.h"
+
+#define DES56_LIBNAME "crypt2"
+#if LUA_VERSION_NUM < 502
+#  define luaL_newlib(L,l) (lua_newtable(L), luaL_register(L,NULL,l))
+#endif
+
+static int des56_decrypt( lua_State *L )
+{
+  char* decypheredText;
+  keysched KS;
+  int rel_index, abs_index;
+  size_t cypherlen;
+  const char *cypheredText = 
+    luaL_checklstring( L, 1, &cypherlen );
+  const char *key = luaL_optstring( L, 2, NULL );
+  int padinfo;
+
+  padinfo = cypheredText[cypherlen-1];
+  cypherlen--;
+
+  /* Aloca array */
+  decypheredText = 
+    (char *) malloc( (cypherlen+1) * sizeof(char));
+  if(decypheredText == NULL) {
+    lua_pushstring(L, "Error decrypting file. Not enough memory.");
+    lua_error(L);
+  }
+
+  /* Inicia decifragem */
+  if (key && strlen(key) >= 8)
+  {
+    char k[8];
+    int i;
+
+    for (i=0; i<8; i++)
+      k[i] = (unsigned char)key[i];
+    fsetkey(k, &KS);
+  } else {
+    lua_pushstring(L, "Error decrypting file. Invalid key.");
+    lua_error(L);
+  }
+
+  rel_index = 0;
+  abs_index = 0;
+
+  while (abs_index < (int) cypherlen)
+  {
+    decypheredText[abs_index] = cypheredText[abs_index];
+    abs_index++;
+    rel_index++;
+    if( rel_index == 8 )
+    {
+      rel_index = 0;
+      fencrypt(&(decypheredText[abs_index - 8]), 1, &KS);
+    }
+  }
+  decypheredText[abs_index] = 0;
+
+  lua_pushlstring(L, decypheredText, (abs_index-padinfo));
+  free( decypheredText );
+  return 1;
+}
+
+static int des56_crypt( lua_State *L )
+{
+  char *cypheredText;
+  keysched KS;
+  int rel_index, pad, abs_index;
+  size_t plainlen;
+  const char *plainText = luaL_checklstring( L, 1, &plainlen );
+  const char *key = luaL_optstring( L, 2, NULL );
+
+  cypheredText = (char *) malloc( (plainlen+8) * sizeof(char));
+  if(cypheredText == NULL) {
+    lua_pushstring(L, "Error encrypting file. Not enough memory."); 
+    lua_error(L);
+  }
+
+  if (key && strlen(key) >= 8)
+  {
+    char k[8];
+    int i;
+
+    for (i=0; i<8; i++)
+      k[i] = (unsigned char)key[i];
+    fsetkey(k, &KS);
+  } else {
+    lua_pushstring(L, "Error encrypting file. Invalid key.");
+    lua_error(L);
+  }
+
+  rel_index = 0;
+  abs_index = 0;
+  while (abs_index < (int) plainlen) {
+    cypheredText[abs_index] = plainText[abs_index];
+    abs_index++;
+    rel_index++;
+    if( rel_index == 8 ) {
+      rel_index = 0;
+      fencrypt(&(cypheredText[abs_index - 8]), 0, &KS);
+    }
+  }
+
+  pad = 0;
+  if(rel_index != 0) { /* Pads remaining bytes with zeroes */
+    while(rel_index < 8)
+    {
+      pad++;
+      cypheredText[abs_index++] = 0;
+      rel_index++;
+    }
+    fencrypt(&(cypheredText[abs_index - 8]), 0, &KS);
+  }
+  cypheredText[abs_index] = pad;
+
+  lua_pushlstring( L, cypheredText, abs_index+1 );
+  free( cypheredText );
+  return 1;
+}
+
+/*
+** Assumes the table is on top of the stack.
+*/
+static void set_info (lua_State *L) {
+	lua_pushliteral (L, "_COPYRIGHT");
+	lua_pushliteral (L, "Copyright (C) 2007-2013 PUC-Rio");
+	lua_settable (L, -3);
+	lua_pushliteral (L, "_DESCRIPTION");
+	lua_pushliteral (L, "DES 56 cryptographic facilities for Lua");
+	lua_settable (L, -3);
+	lua_pushliteral (L, "_VERSION");
+	lua_pushliteral (L, "DES56 1.2");
+	lua_settable (L, -3);
+}
+
+static const struct luaL_Reg des56lib[] = {
+  {"crypt", des56_crypt},
+  {"decrypt", des56_decrypt},
+  {NULL, NULL},
+};
+
+int luaopen_des56 (lua_State *L) {
+	luaL_newlib (L, des56lib);
+	lua_pushvalue(L, -1);
+	lua_setglobal(L, DES56_LIBNAME);
+	set_info (L);
+	return 1;
+}
diff --git a/scripting/lua/crypt/ldes56.h b/scripting/lua/crypt/ldes56.h
new file mode 100755
index 0000000..df12a40
--- /dev/null
+++ b/scripting/lua/crypt/ldes56.h
@@ -0,0 +1,6 @@
+#ifndef des56_h
+#define des56_h
+
+int luaopen_des56 (lua_State *L);
+
+#endif
diff --git a/scripting/lua/crypt/lua_zlib.c b/scripting/lua/crypt/lua_zlib.c
new file mode 100755
index 0000000..5b058e1
--- /dev/null
+++ b/scripting/lua/crypt/lua_zlib.c
@@ -0,0 +1,396 @@
+#include <ctype.h>
+#include "lauxlib.h"
+#include "lua.h"
+#include <stdlib.h>
+#include <string.h>
+#include <zlib.h>
+
+/*
+ * ** compatibility with Lua 5.2
+ * */
+#if (LUA_VERSION_NUM == 502)
+#undef luaL_register
+#define luaL_register(L,n,f) \
+               { if ((n) == NULL) luaL_setfuncs(L,f,0); else luaL_newlib(L,f); }
+
+#endif
+
+#define DEF_MEM_LEVEL 8
+
+typedef uLong (*checksum_t)        (uLong crc, const Bytef *buf, uInt len);
+typedef uLong (*checksum_combine_t)(uLong crc1, uLong crc2, z_off_t len2);
+
+
+static int lz_deflate(lua_State *L);
+static int lz_deflate_delete(lua_State *L);
+static int lz_inflate_delete(lua_State *L);
+static int lz_inflate(lua_State *L);
+static int lz_checksum(lua_State *L);
+static int lz_checksum_new(lua_State *L, checksum_t checksum, checksum_combine_t combine);
+static int lz_adler32(lua_State *L);
+static int lz_crc32(lua_State *L);
+
+static int lz_version(lua_State *L) {
+    const char* version = zlibVersion();
+    int         count   = strlen(version) + 1;
+    char*       cur     = (char*)memcpy(lua_newuserdata(L, count),
+                                        version, count);
+
+    count = 0;
+    while ( *cur ) {
+        char* begin = cur;
+        /* Find all digits: */
+        while ( isdigit(*cur) ) cur++;
+        if ( begin != cur ) {
+            int is_end = *cur == '\0';
+            *cur = '\0';
+            lua_pushnumber(L, atoi(begin));
+            count++;
+            if ( is_end ) break;
+            cur++;
+        }
+        while ( *cur && ! isdigit(*cur) ) cur++;
+    }
+
+    return count;
+}
+
+static int lz_assert(lua_State *L, int result, const z_stream* stream, const char* file, int line) {
+    /* Both of these are "normal" return codes: */
+    if ( result == Z_OK || result == Z_STREAM_END ) return result;
+    switch ( result ) {
+    case Z_NEED_DICT:
+        lua_pushfstring(L, "RequiresDictionary: input stream requires a dictionary to be deflated (%s) at %s line %d",
+                        stream->msg, file, line);
+        break;
+    case Z_STREAM_ERROR:
+        lua_pushfstring(L, "InternalError: inconsistent internal zlib stream (%s) at %s line %d",
+                        stream->msg, file, line);
+        break;
+    case Z_DATA_ERROR:
+        lua_pushfstring(L, "InvalidInput: input string does not conform to zlib format or checksum failed at %s line %d",
+                        file, line);
+        break;
+    case Z_MEM_ERROR:
+        lua_pushfstring(L, "OutOfMemory: not enough memory (%s) at %s line %d",
+                        stream->msg, file, line);
+        break;
+    case Z_BUF_ERROR:
+        lua_pushfstring(L, "InternalError: no progress possible (%s) at %s line %d",
+                        stream->msg, file, line);
+        break;
+    case Z_VERSION_ERROR:
+        lua_pushfstring(L, "IncompatibleLibrary: built with version %s, but dynamically linked with version %s (%s) at %s line %d",
+                        ZLIB_VERSION,  zlibVersion(), stream->msg, file, line);
+        break;
+    default:
+        lua_pushfstring(L, "ZLibError: unknown code %d (%s) at %s line %d",
+                        result, stream->msg, file, line);
+    }
+    lua_error(L);
+    return result;
+}
+
+/**
+ * @upvalue z_stream - Memory for the z_stream.
+ * @upvalue remainder - Any remainder from the last deflate call.
+ *
+ * @param string - "print" to deflate stream.
+ * @param int - flush output buffer? Z_SYNC_FLUSH, Z_FULL_FLUSH, or Z_FINISH.
+ *
+ * if no params, terminates the stream (as if we got empty string and Z_FINISH).
+ */
+static int lz_filter_impl(lua_State *L, int (*filter)(z_streamp, int), int (*end)(z_streamp), char* name) {
+    int flush = Z_NO_FLUSH, result;
+    z_stream* stream;
+    luaL_Buffer buff;
+    size_t avail_in;
+
+    if ( filter == deflate ) {
+        const char *const opts[] = { "none", "sync", "full", "finish", NULL };
+        flush = luaL_checkoption(L, 2, opts[0], opts);
+        if ( flush ) flush++; 
+        /* Z_NO_FLUSH(0) Z_SYNC_FLUSH(2), Z_FULL_FLUSH(3), Z_FINISH (4) */
+
+        /* No arguments or nil, we are terminating the stream: */
+        if ( lua_gettop(L) == 0 || lua_isnil(L, 1) ) {
+            flush = Z_FINISH;
+        }
+    }
+
+    stream = (z_stream*)lua_touserdata(L, lua_upvalueindex(1));
+    if ( stream == NULL ) {
+        if ( lua_gettop(L) >= 1 && lua_isstring(L, 1) ) {
+            lua_pushfstring(L, "IllegalState: calling %s function when stream was previously closed", name);
+            lua_error(L);
+        }
+        lua_pushstring(L, "");
+        lua_pushboolean(L, 1);
+        return 2; /* Ignore duplicate calls to "close". */
+    }
+
+    luaL_buffinit(L, &buff);
+
+    if ( lua_gettop(L) > 1 ) lua_pushvalue(L, 1);
+
+    if ( lua_isstring(L, lua_upvalueindex(2)) ) {
+        lua_pushvalue(L, lua_upvalueindex(2));
+        if ( lua_gettop(L) > 1 && lua_isstring(L, -2) ) {
+            lua_concat(L, 2);
+        }
+    }
+
+    /*  Do the actual deflate'ing: */
+    if (lua_gettop(L) > 0) {
+        stream->next_in = (unsigned char*)lua_tolstring(L, -1, &avail_in);
+    } else {
+        stream->next_in = NULL;
+        avail_in = 0;
+    }
+    stream->avail_in = avail_in;
+
+    if ( ! stream->avail_in && ! flush ) {
+        /*  Passed empty string, make it a noop instead of erroring out. */
+        lua_pushstring(L, "");
+        lua_pushboolean(L, 0);
+        lua_pushinteger(L, stream->total_in);
+        lua_pushinteger(L, stream->total_out);
+        return 4;
+    }
+
+    do {
+        stream->next_out  = (unsigned char*)luaL_prepbuffer(&buff);
+        stream->avail_out = LUAL_BUFFERSIZE;
+        result = filter(stream, flush);
+        if ( Z_BUF_ERROR != result ) {
+            /* Ignore Z_BUF_ERROR since that just indicates that we
+             * need a larger buffer in order to proceed.  Thanks to
+             * Tobias Markmann for finding this bug!
+             */
+            lz_assert(L, result, stream, __FILE__, __LINE__);
+        }
+        luaL_addsize(&buff, LUAL_BUFFERSIZE - stream->avail_out);
+    } while ( stream->avail_out == 0 );
+
+    /*  Need to do this before we alter the stack: */
+    luaL_pushresult(&buff);
+
+    /*  Save remainder in lua_upvalueindex(2): */
+    if ( NULL != stream->next_in ) {
+        lua_pushlstring(L, (char*)stream->next_in, stream->avail_in);
+        lua_replace(L, lua_upvalueindex(2));
+    }
+
+    /*  "close" the stream/remove finalizer: */
+    if ( result == Z_STREAM_END ) {
+        /*  Clear-out the metatable so end is not called twice: */
+        lua_pushnil(L);
+        lua_setmetatable(L, lua_upvalueindex(1));
+
+        /*  nil the upvalue: */
+        lua_pushnil(L);
+        lua_replace(L, lua_upvalueindex(1));
+
+        /*  Close the stream: */
+        lz_assert(L, end(stream), stream, __FILE__, __LINE__);
+
+        lua_pushboolean(L, 1);
+    } else {
+        lua_pushboolean(L, 0);
+    }
+    lua_pushinteger(L, stream->total_in);
+    lua_pushinteger(L, stream->total_out);
+    return 4;
+}
+
+static void lz_create_deflate_mt(lua_State *L) {
+    luaL_newmetatable(L, "lz.deflate.meta"); /*  {} */
+
+    lua_pushcfunction(L, lz_deflate_delete);
+    lua_setfield(L, -2, "__gc");
+
+    lua_pop(L, 1); /*  <empty> */
+}
+
+static int lz_deflate_new(lua_State *L) {
+    int level = luaL_optint(L, 1, Z_DEFAULT_COMPRESSION);
+    int window_size = luaL_optint(L, 2, MAX_WBITS);
+
+    /*  Allocate the stream: */
+    z_stream* stream = (z_stream*)lua_newuserdata(L, sizeof(z_stream));
+
+    stream->zalloc = Z_NULL;
+    stream->zfree  = Z_NULL;
+
+    int result = deflateInit2(stream, level, Z_DEFLATED, window_size,
+                              DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
+
+    lz_assert(L, result, stream, __FILE__, __LINE__);
+
+    /*  Don't allow destructor to execute unless deflateInit2 was successful: */
+    luaL_getmetatable(L, "lz.deflate.meta");
+    lua_setmetatable(L, -2);
+
+    lua_pushnil(L);
+    lua_pushcclosure(L, lz_deflate, 2);
+    return 1;
+}
+
+static int lz_deflate(lua_State *L) {
+    return lz_filter_impl(L, deflate, deflateEnd, "deflate");
+}
+
+static int lz_deflate_delete(lua_State *L) {
+    z_stream* stream  = (z_stream*)lua_touserdata(L, 1);
+
+    /*  Ignore errors. */
+    deflateEnd(stream);
+
+    return 0;
+}
+
+
+static void lz_create_inflate_mt(lua_State *L) {
+    luaL_newmetatable(L, "lz.inflate.meta"); /*  {} */
+
+    lua_pushcfunction(L, lz_inflate_delete);
+    lua_setfield(L, -2, "__gc");
+
+    lua_pop(L, 1); /*  <empty> */
+}
+
+static int lz_inflate_new(lua_State *L) {
+    /* Allocate the stream */
+    z_stream* stream = (z_stream*)lua_newuserdata(L, sizeof(z_stream));
+
+    /*  By default, we will do gzip header detection w/ max window size */
+    int window_size = lua_isnumber(L, 1) ? lua_tointeger(L, 1) : MAX_WBITS + 32;
+
+    stream->zalloc   = Z_NULL;
+    stream->zfree    = Z_NULL;
+    stream->next_in  = Z_NULL;
+    stream->avail_in = 0;
+
+    lz_assert(L, inflateInit2(stream, window_size), stream, __FILE__, __LINE__);
+
+    /*  Don't allow destructor to execute unless deflateInit was successful: */
+    luaL_getmetatable(L, "lz.inflate.meta");
+    lua_setmetatable(L, -2);
+
+    lua_pushnil(L);
+    lua_pushcclosure(L, lz_inflate, 2);
+    return 1;
+}
+
+static int lz_inflate(lua_State *L) {
+    return lz_filter_impl(L, inflate, inflateEnd, "inflate");
+}
+
+static int lz_inflate_delete(lua_State *L) {
+    z_stream* stream  = (z_stream*)lua_touserdata(L, 1);
+
+    /*  Ignore errors: */
+    inflateEnd(stream);
+
+    return 0;
+}
+
+static int lz_checksum(lua_State *L) {
+    if ( lua_gettop(L) <= 0 ) {
+        lua_pushvalue(L, lua_upvalueindex(3));
+        lua_pushvalue(L, lua_upvalueindex(4));
+    } else if ( lua_isfunction(L, 1) ) {
+        checksum_combine_t combine = (checksum_combine_t)
+            lua_touserdata(L, lua_upvalueindex(2));
+
+        lua_pushvalue(L, 1);
+        lua_call(L, 0, 2);
+        if ( ! lua_isnumber(L, -2) || ! lua_isnumber(L, -1) ) {
+            luaL_argerror(L, 1, "expected function to return two numbers");
+        }
+
+        /* Calculate and replace the checksum */
+        lua_pushnumber(L,
+                       combine((uLong)lua_tonumber(L, lua_upvalueindex(3)),
+                               (uLong)lua_tonumber(L, -2),
+                               (z_off_t)lua_tonumber(L, -1)));
+        lua_pushvalue(L, -1);
+        lua_replace(L, lua_upvalueindex(3));
+
+        /* Calculate and replace the length */
+        lua_pushnumber(L,
+                       lua_tonumber(L, lua_upvalueindex(4)) + lua_tonumber(L, -2));
+        lua_pushvalue(L, -1);
+        lua_replace(L, lua_upvalueindex(4));
+    } else {
+        const Bytef* str;
+        size_t       len;
+
+        checksum_t checksum = (checksum_t)
+            lua_touserdata(L, lua_upvalueindex(1));
+        str = (const Bytef*)luaL_checklstring(L, 1, &len);
+ 
+        /* Calculate and replace the checksum */
+        lua_pushnumber(L,
+                       checksum((uLong)lua_tonumber(L, lua_upvalueindex(3)),
+                                str,
+                                len));
+        lua_pushvalue(L, -1);
+        lua_replace(L, lua_upvalueindex(3));
+        
+        /* Calculate and replace the length */
+        lua_pushnumber(L,
+                       lua_tonumber(L, lua_upvalueindex(4)) + len);
+        lua_pushvalue(L, -1);
+        lua_replace(L, lua_upvalueindex(4));
+    }
+    return 2;
+}
+
+static int lz_checksum_new(lua_State *L, checksum_t checksum, checksum_combine_t combine) {
+    lua_pushlightuserdata(L, checksum);
+    lua_pushlightuserdata(L, combine);
+    lua_pushnumber(L, checksum(0L, Z_NULL, 0));
+    lua_pushnumber(L, 0);
+    lua_pushcclosure(L, lz_checksum, 4);
+    return 1;
+}
+
+static int lz_adler32(lua_State *L) {
+    return lz_checksum_new(L, adler32, adler32_combine);
+}
+
+static int lz_crc32(lua_State *L) {
+    return lz_checksum_new(L, crc32, crc32_combine);
+}
+
+static const luaL_Reg zlib_functions[] = {
+    { "deflate", lz_deflate_new },
+    { "inflate", lz_inflate_new },
+    { "adler32", lz_adler32     },
+    { "crc32",   lz_crc32       },
+    { "version", lz_version     },
+    { NULL,      NULL           }
+};
+
+#define SETLITERAL(n,v) (lua_pushliteral(L, n), lua_pushliteral(L, v), lua_settable(L, -3))
+#define SETINT(n,v) (lua_pushliteral(L, n), lua_pushinteger(L, v), lua_settable(L, -3))
+
+LUALIB_API int luaopen_zlib(lua_State * const L) {
+    lz_create_deflate_mt(L);
+    lz_create_inflate_mt(L);
+
+    luaL_register(L, "zlib", zlib_functions);
+
+    SETINT("BEST_SPEED", Z_BEST_SPEED);
+    SETINT("BEST_COMPRESSION", Z_BEST_COMPRESSION);
+
+    SETLITERAL("_COPYRIGHT", "Copyright (c) 2009-2010 Brian Maher");
+    SETLITERAL("_DESCRIPTION", "Yet another binding to the zlib library");
+    SETLITERAL("_VERSION", "lua-zlib $Id$ $Format:%d$");
+
+    /* Expose this to lua so we can do a test: */
+    SETINT("_TEST_BUFSIZ", LUAL_BUFFERSIZE);
+
+    return 1;
+}
\ No newline at end of file
diff --git a/scripting/lua/crypt/lua_zlib.h b/scripting/lua/crypt/lua_zlib.h
new file mode 100755
index 0000000..90c2326
--- /dev/null
+++ b/scripting/lua/crypt/lua_zlib.h
@@ -0,0 +1,8 @@
+#ifndef lua_zlib_h
+#define lua_zlib_h
+
+#include "lua.h"
+
+LUALIB_API int luaopen_zlib(lua_State * const L);
+
+#endif
diff --git a/scripting/lua/crypt/md5.c b/scripting/lua/crypt/md5.c
new file mode 100755
index 0000000..8b15b43
--- /dev/null
+++ b/scripting/lua/crypt/md5.c
@@ -0,0 +1,214 @@
+/**
+*  $Id: md5.c,v 1.2 2008/03/24 20:59:12 mascarenhas Exp $
+*  Hash function MD5
+*  @author  Marcela Ozorio Suarez, Roberto I.
+*/
+
+
+#include <string.h>
+
+#include "md5.h"
+
+
+#define WORD 32
+#define MASK 0xFFFFFFFF
+#if __STDC_VERSION__ >= 199901L
+#include <stdint.h>
+typedef uint32_t WORD32;
+#else
+typedef unsigned int WORD32;
+#endif
+
+
+/**
+*  md5 hash function.
+*  @param message: aribtary string.
+*  @param len: message length.
+*  @param output: buffer to receive the hash value. Its size must be
+*  (at least) HASHSIZE.
+*/
+void md5 (const char *message, long len, char *output);
+
+
+
+/*
+** Realiza a rotacao no sentido horario dos bits da variavel 'D' do tipo WORD32.
+** Os bits sao deslocados de 'num' posicoes
+*/
+#define rotate(D, num)  (D<<num) | (D>>(WORD-num))
+
+/*Macros que definem operacoes relizadas pelo algoritmo  md5 */
+#define F(x, y, z) (((x) & (y)) | ((~(x)) & (z)))
+#define G(x, y, z) (((x) & (z)) | ((y) & (~(z))))
+#define H(x, y, z) ((x) ^ (y) ^ (z))
+#define I(x, y, z) ((y) ^ ((x) | (~(z))))
+
+
+/*vetor de numeros utilizados pelo algoritmo md5 para embaralhar bits */
+static const WORD32 T[64]={
+                     0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
+                     0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
+                     0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
+                     0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
+                     0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
+                     0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
+                     0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
+                     0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
+                     0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
+                     0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
+                     0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
+                     0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
+                     0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
+                     0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
+                     0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
+                     0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
+};
+
+
+static void word32tobytes (const WORD32 *input, char *output) {
+  int j = 0;
+  while (j<4*4) {
+    WORD32 v = *input++;
+    output[j++] = (char)(v & 0xff); v >>= 8;
+    output[j++] = (char)(v & 0xff); v >>= 8;
+    output[j++] = (char)(v & 0xff); v >>= 8;
+    output[j++] = (char)(v & 0xff);
+  }
+}
+
+
+static void inic_digest(WORD32 *d) {
+  d[0] = 0x67452301;
+  d[1] = 0xEFCDAB89;
+  d[2] = 0x98BADCFE;
+  d[3] = 0x10325476;
+}
+
+
+/*funcao que implemeta os quatro passos principais do algoritmo MD5 */
+static void digest(const WORD32 *m, WORD32 *d) {
+  int j;
+  /*MD5 PASSO1 */
+  for (j=0; j<4*4; j+=4) {
+    d[0] = d[0]+ F(d[1], d[2], d[3])+ m[j] + T[j];       d[0]=rotate(d[0], 7);
+    d[0]+=d[1];
+    d[3] = d[3]+ F(d[0], d[1], d[2])+ m[(j)+1] + T[j+1]; d[3]=rotate(d[3], 12);
+    d[3]+=d[0];
+    d[2] = d[2]+ F(d[3], d[0], d[1])+ m[(j)+2] + T[j+2]; d[2]=rotate(d[2], 17);
+    d[2]+=d[3];
+    d[1] = d[1]+ F(d[2], d[3], d[0])+ m[(j)+3] + T[j+3]; d[1]=rotate(d[1], 22);
+    d[1]+=d[2];
+  }
+  /*MD5 PASSO2 */
+  for (j=0; j<4*4; j+=4) {
+    d[0] = d[0]+ G(d[1], d[2], d[3])+ m[(5*j+1)&0x0f] + T[(j-1)+17];
+    d[0] = rotate(d[0],5);
+    d[0]+=d[1];
+    d[3] = d[3]+ G(d[0], d[1], d[2])+ m[((5*(j+1)+1)&0x0f)] + T[(j+0)+17];
+    d[3] = rotate(d[3], 9);
+    d[3]+=d[0];
+    d[2] = d[2]+ G(d[3], d[0], d[1])+ m[((5*(j+2)+1)&0x0f)] + T[(j+1)+17];
+    d[2] = rotate(d[2], 14);
+    d[2]+=d[3];
+    d[1] = d[1]+ G(d[2], d[3], d[0])+ m[((5*(j+3)+1)&0x0f)] + T[(j+2)+17];
+    d[1] = rotate(d[1], 20);
+    d[1]+=d[2];
+  }
+  /*MD5 PASSO3 */
+  for (j=0; j<4*4; j+=4) {
+    d[0] = d[0]+ H(d[1], d[2], d[3])+ m[(3*j+5)&0x0f] + T[(j-1)+33];
+    d[0] = rotate(d[0], 4);
+    d[0]+=d[1];
+    d[3] = d[3]+ H(d[0], d[1], d[2])+ m[(3*(j+1)+5)&0x0f] + T[(j+0)+33];
+    d[3] = rotate(d[3], 11);
+    d[3]+=d[0];
+    d[2] = d[2]+ H(d[3], d[0], d[1])+ m[(3*(j+2)+5)&0x0f] + T[(j+1)+33];
+    d[2] = rotate(d[2], 16);
+    d[2]+=d[3];
+    d[1] = d[1]+ H(d[2], d[3], d[0])+ m[(3*(j+3)+5)&0x0f] + T[(j+2)+33];
+    d[1] = rotate(d[1], 23);
+    d[1]+=d[2];
+  }
+  /*MD5 PASSO4 */
+  for (j=0; j<4*4; j+=4) {
+    d[0] = d[0]+ I(d[1], d[2], d[3])+ m[(7*j)&0x0f] + T[(j-1)+49];
+    d[0] = rotate(d[0], 6);
+    d[0]+=d[1];
+    d[3] = d[3]+ I(d[0], d[1], d[2])+ m[(7*(j+1))&0x0f] + T[(j+0)+49];
+    d[3] = rotate(d[3], 10);
+    d[3]+=d[0];
+    d[2] = d[2]+ I(d[3], d[0], d[1])+ m[(7*(j+2))&0x0f] + T[(j+1)+49];
+    d[2] = rotate(d[2], 15);
+    d[2]+=d[3];
+    d[1] = d[1]+ I(d[2], d[3], d[0])+ m[(7*(j+3))&0x0f] + T[(j+2)+49];
+    d[1] = rotate(d[1], 21);
+    d[1]+=d[2];
+  }
+}
+
+
+static void bytestoword32 (WORD32 *x, const char *pt) {
+  int i;
+  for (i=0; i<16; i++) {
+    int j=i*4;
+    x[i] = (((WORD32)(unsigned char)pt[j+3] << 8 |
+           (WORD32)(unsigned char)pt[j+2]) << 8 |
+           (WORD32)(unsigned char)pt[j+1]) << 8 |
+           (WORD32)(unsigned char)pt[j];
+  }
+
+}
+
+
+static void put_length(WORD32 *x, long len) {
+  /* in bits! */
+  x[14] = (WORD32)((len<<3) & MASK);
+  x[15] = (WORD32)(len>>(32-3) & 0x7);
+}
+
+
+/*
+** returned status:
+*  0 - normal message (full 64 bytes)
+*  1 - enough room for 0x80, but not for message length (two 4-byte words)
+*  2 - enough room for 0x80 plus message length (at least 9 bytes free)
+*/
+static int converte (WORD32 *x, const char *pt, int num, int old_status) {
+  int new_status = 0;
+  char buff[64];
+  if (num<64) {
+    memcpy(buff, pt, num);  /* to avoid changing original string */
+    memset(buff+num, 0, 64-num);
+    if (old_status == 0)
+      buff[num] = '\200';
+    new_status = 1;
+    pt = buff;
+  }
+  bytestoword32(x, pt);
+  if (num <= (64 - 9))
+    new_status = 2;
+  return new_status;
+}
+
+
+
+void md5 (const char *message, long len, char *output) {
+  WORD32 d[4];
+  int status = 0;
+  long i = 0;
+  inic_digest(d);
+  while (status != 2) {
+    WORD32 d_old[4];
+    WORD32 wbuff[16];
+    int numbytes = (len-i >= 64) ? 64 : len-i;
+    /*salva os valores do vetor digest*/
+    d_old[0]=d[0]; d_old[1]=d[1]; d_old[2]=d[2]; d_old[3]=d[3];
+    status = converte(wbuff, message+i, numbytes, status);
+    if (status == 2) put_length(wbuff, len);
+    digest(wbuff, d);
+    d[0]+=d_old[0]; d[1]+=d_old[1]; d[2]+=d_old[2]; d[3]+=d_old[3];
+    i += numbytes;
+  }
+  word32tobytes(d, output);
+}
+
diff --git a/scripting/lua/crypt/md5.h b/scripting/lua/crypt/md5.h
new file mode 100755
index 0000000..c8dc2fb
--- /dev/null
+++ b/scripting/lua/crypt/md5.h
@@ -0,0 +1,20 @@
+/**
+*  $Id: md5.h,v 1.2 2006/03/03 15:04:49 tomas Exp $
+*  Cryptographic module for Lua.
+*  @author  Roberto Ierusalimschy
+*/
+
+
+#ifndef md5_h
+#define md5_h
+
+#include "lua.h"
+
+
+#define HASHSIZE       16
+
+void md5 (const char *message, long len, char *output);
+int luaopen_md5_core (lua_State *L);
+
+
+#endif
diff --git a/scripting/lua/crypt/md5lib.c b/scripting/lua/crypt/md5lib.c
new file mode 100755
index 0000000..b18907f
--- /dev/null
+++ b/scripting/lua/crypt/md5lib.c
@@ -0,0 +1,205 @@
+/**
+*  $Id: md5lib.c,v 1.10 2008/05/12 20:51:27 carregal Exp $
+*  Cryptographic and Hash functions for Lua
+*  @author  Roberto Ierusalimschy
+*/
+
+
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include "lua.h"
+#include "lauxlib.h"
+
+#include "md5.h"
+
+#define MD5_LIBNAME "crypt1"
+
+#if LUA_VERSION_NUM < 502
+#  define luaL_newlib(L,l) (lua_newtable(L), luaL_register(L,NULL,l))
+#endif
+
+/**
+*  Hash function. Returns a hash for a given string.
+*  @param message: arbitrary binary string.
+*  @return  A 128-bit hash string.
+*/
+static int lmd5 (lua_State *L) {
+  char buff[16];
+  size_t l;
+  const char *message = luaL_checklstring(L, 1, &l);
+  md5(message, l, buff);
+  lua_pushlstring(L, buff, 16L);
+  return 1;
+}
+
+
+/**
+*  X-Or. Does a bit-a-bit exclusive-or of two strings.
+*  @param s1: arbitrary binary string.
+*  @param s2: arbitrary binary string with same length as s1.
+*  @return  a binary string with same length as s1 and s2,
+*   where each bit is the exclusive-or of the corresponding bits in s1-s2.
+*/
+static int ex_or (lua_State *L) {
+  size_t l1, l2;
+  const char *s1 = luaL_checklstring(L, 1, &l1);
+  const char *s2 = luaL_checklstring(L, 2, &l2);
+  luaL_Buffer b;
+  luaL_argcheck( L, l1 == l2, 2, "lengths must be equal" );
+  luaL_buffinit(L, &b);
+  while (l1--) luaL_addchar(&b, (*s1++)^(*s2++));
+  luaL_pushresult(&b);
+  return 1;
+}
+
+
+static void checkseed (lua_State *L) {
+  if (lua_isnone(L, 3)) {  /* no seed? */
+    time_t tm = time(NULL);  /* for `random' seed */
+    lua_pushlstring(L, (char *)&tm, sizeof(tm));
+  }
+}
+
+
+#define MAXKEY	256
+#define BLOCKSIZE	16
+
+
+
+static int initblock (lua_State *L, const char *seed, int lseed, char *block) {
+  size_t lkey;
+  const char *key = luaL_checklstring(L, 2, &lkey);
+  if (lkey > MAXKEY)
+    luaL_error(L, "key too long (> %d)", MAXKEY);
+  memset(block, 0, BLOCKSIZE);
+  memcpy(block, seed, lseed);
+  memcpy(block+BLOCKSIZE, key, lkey);
+  return (int)lkey+BLOCKSIZE;
+}
+
+
+static void codestream (lua_State *L, const char *msg, size_t lmsg,
+                                      char *block, int lblock) {
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while (lmsg > 0) {
+    char code[BLOCKSIZE];
+    int i;
+    md5(block, lblock, code);
+    for (i=0; i<BLOCKSIZE && lmsg > 0; i++, lmsg--)
+      code[i] ^= *msg++;
+    luaL_addlstring(&b, code, i); 
+    memcpy(block, code, i); /* update seed */
+  }
+  luaL_pushresult(&b);
+}
+
+
+static void decodestream (lua_State *L, const char *cypher, size_t lcypher,
+                          char *block, int lblock) {
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while (lcypher > 0) {
+    char code[BLOCKSIZE];
+    int i;
+    md5(block, lblock, code);  /* update seed */
+    for (i=0; i<BLOCKSIZE && lcypher > 0; i++, lcypher--)
+      code[i] ^= *cypher++;
+    luaL_addlstring(&b, code, i); 
+    memcpy(block, cypher-i, i);
+  }
+  luaL_pushresult(&b);
+}
+
+
+/**
+*  Encrypts a string. Uses the hash function md5 in CFB (Cipher-feedback
+*  mode).
+*  @param message: arbitrary binary string to be encrypted.
+*  @param key: arbitrary binary string to be used as a key.
+*  @param [seed]: optional arbitrary binary string to be used as a seed.
+*  if no seed is provided, the function uses the result of
+*  <code>time()</code> as a seed.  
+*  @return  The cyphertext (as a binary string).
+*/
+static int crypt (lua_State *L) {
+  size_t lmsg;
+  const char *msg = luaL_checklstring(L, 1, &lmsg);
+  size_t lseed;
+  const char *seed;
+  int lblock;
+  char block[BLOCKSIZE+MAXKEY];
+  checkseed(L);
+  seed = luaL_checklstring(L, 3, &lseed);
+  if (lseed > BLOCKSIZE)
+    luaL_error(L, "seed too long (> %d)", BLOCKSIZE);
+  /* put seed and seed length at the beginning of result */
+  block[0] = (char)lseed;
+  memcpy(block+1, seed, lseed);
+  lua_pushlstring(L, block, lseed+1);  /* to concat with result */
+  lblock = initblock(L, seed, lseed, block);
+  codestream(L, msg, lmsg, block, lblock);
+  lua_concat(L, 2);
+  return 1;
+}
+
+
+/**
+*  Decrypts a string. For any message, key, and seed, we have that
+*  <code>decrypt(crypt(msg, key, seed), key) == msg</code>.
+*  @param cyphertext: message to be decrypted (this must be the result of
+   a previous call to <code>crypt</code>.
+*  @param key: arbitrary binary string to be used as a key.
+*  @return  The plaintext.
+*/
+static int decrypt (lua_State *L) {
+  size_t lcyphertext;
+  const char *cyphertext = luaL_checklstring(L, 1, &lcyphertext);
+  size_t lseed = cyphertext[0];
+  const char *seed = cyphertext+1;
+  int lblock;
+  char block[BLOCKSIZE+MAXKEY];
+  luaL_argcheck(L, lcyphertext >= lseed+1 && lseed <= BLOCKSIZE, 1,
+                 "invalid cyphered string");
+  cyphertext += lseed+1;
+  lcyphertext -= lseed+1;
+  lblock = initblock(L, seed, lseed, block);
+  decodestream(L, cyphertext, lcyphertext, block, lblock);
+  return 1;
+}
+
+
+/*
+** Assumes the table is on top of the stack.
+*/
+static void set_info (lua_State *L) {
+	lua_pushliteral (L, "_COPYRIGHT");
+	lua_pushliteral (L, "Copyright (C) 2003-2013 PUC-Rio");
+	lua_settable (L, -3);
+	lua_pushliteral (L, "_DESCRIPTION");
+	lua_pushliteral (L, "Basic cryptographic facilities");
+	lua_settable (L, -3);
+	lua_pushliteral (L, "_VERSION");
+	lua_pushliteral (L, "MD5 1.2");
+	lua_settable (L, -3);
+}
+
+
+static struct luaL_Reg md5lib[] = {
+  {"sum", lmd5},
+  {"exor", ex_or},
+  {"crypt", crypt},
+  {"decrypt", decrypt},
+  {NULL, NULL}
+};
+
+
+int luaopen_md5_core (lua_State *L) {
+  luaL_newlib (L, md5lib);
+  lua_pushvalue(L, -1);
+  lua_setglobal(L, MD5_LIBNAME);
+  set_info (L);
+  return 1;
+}
diff --git a/scripting/lua/lfs/lfs.c b/scripting/lua/lfs/lfs.c
new file mode 100755
index 0000000..eb53d18
--- /dev/null
+++ b/scripting/lua/lfs/lfs.c
@@ -0,0 +1,889 @@
+/*
+** LuaFileSystem
+** Copyright Kepler Project 2003 (http://www.keplerproject.org/luafilesystem)
+**
+** File system manipulation library.
+** This library offers these functions:
+**   lfs.attributes (filepath [, attributename])
+**   lfs.chdir (path)
+**   lfs.currentdir ()
+**   lfs.dir (path)
+**   lfs.lock (fh, mode)
+**   lfs.lock_dir (path)
+**   lfs.mkdir (path)
+**   lfs.rmdir (path)
+**   lfs.setmode (filepath, mode)
+**   lfs.symlinkattributes (filepath [, attributename]) -- thanks to Sam Roberts
+**   lfs.touch (filepath [, atime [, mtime]])
+**   lfs.unlock (fh)
+**
+** $Id: lfs.c,v 1.61 2009/07/04 02:10:16 mascarenhas Exp $
+*/
+
+#ifndef _WIN32
+#ifndef _AIX
+#define _FILE_OFFSET_BITS 64 /* Linux, Solaris and HP-UX */
+#else
+#define _LARGE_FILES 1 /* AIX */
+#endif
+#endif
+
+#define _LARGEFILE64_SOURCE
+
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sys/stat.h>
+
+#ifdef _WIN32
+#include <direct.h>
+#include <windows.h>
+#include <io.h>
+#include <sys/locking.h>
+#ifdef __BORLANDC__
+ #include <utime.h>
+#else
+ #include <sys/utime.h>
+#endif
+#include <fcntl.h>
+#else
+#include <unistd.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <utime.h>
+#endif
+
+#include "lua.h"
+#include "lauxlib.h"
+#include "lualib.h"
+
+#include "lfs.h"
+
+#define LFS_VERSION "1.6.2"
+#define LFS_LIBNAME "lfs"
+
+#if LUA_VERSION_NUM < 502
+#  define luaL_newlib(L,l) (lua_newtable(L), luaL_register(L,NULL,l))
+#endif
+
+/* Define 'strerror' for systems that do not implement it */
+#ifdef NO_STRERROR
+#define strerror(_)     "System unable to describe the error"
+#endif
+
+/* Define 'getcwd' for systems that do not implement it */
+#ifdef NO_GETCWD
+#define getcwd(p,s)     NULL
+#define getcwd_error    "Function 'getcwd' not provided by system"
+#else
+#define getcwd_error    strerror(errno)
+  #ifdef _WIN32
+	 /* MAX_PATH seems to be 260. Seems kind of small. Is there a better one? */
+    #define LFS_MAXPATHLEN MAX_PATH
+  #else
+	/* For MAXPATHLEN: */
+    #include <sys/param.h>
+    #define LFS_MAXPATHLEN MAXPATHLEN
+  #endif
+#endif
+
+#define DIR_METATABLE "directory metatable"
+typedef struct dir_data {
+        int  closed;
+#ifdef _WIN32
+        long hFile;
+        char pattern[MAX_PATH+1];
+#else
+        DIR *dir;
+#endif
+} dir_data;
+
+#define LOCK_METATABLE "lock metatable"
+
+#ifdef _WIN32
+ #ifdef __BORLANDC__
+  #define lfs_setmode(L,file,m)   ((void)L, setmode(_fileno(file), m))
+  #define STAT_STRUCT struct stati64
+ #else
+  #define lfs_setmode(L,file,m)   ((void)L, _setmode(_fileno(file), m))
+  #define STAT_STRUCT struct _stati64
+ #endif
+#define STAT_FUNC _stati64
+#define LSTAT_FUNC STAT_FUNC
+#else
+#define _O_TEXT               0
+#define _O_BINARY             0
+#define lfs_setmode(L,file,m)   ((void)L, (void)file, (void)m, 0)
+#define STAT_STRUCT struct stat
+#define STAT_FUNC stat
+#define LSTAT_FUNC lstat
+#endif
+
+/*
+** Utility functions
+*/
+static int pusherror(lua_State *L, const char *info)
+{
+        lua_pushnil(L);
+        if (info==NULL)
+                lua_pushstring(L, strerror(errno));
+        else
+                lua_pushfstring(L, "%s: %s", info, strerror(errno));
+        lua_pushinteger(L, errno);
+        return 3;
+}
+
+static int pushresult(lua_State *L, int i, const char *info)
+{
+        if (i==-1)
+                return pusherror(L, info);
+        lua_pushinteger(L, i);
+        return 1;
+}
+
+
+/*
+** This function changes the working (current) directory
+*/
+static int change_dir (lua_State *L) {
+        const char *path = luaL_checkstring(L, 1);
+		
+        if (chdir(path)) {
+                lua_pushnil (L);
+                lua_pushfstring (L,"Unable to change working directory to '%s'\n%s\n",
+                                path, chdir_error);
+                return 2;
+        } else {
+                lua_pushboolean (L, 1);
+                return 1;
+        }
+}
+
+/*
+** This function returns the current directory
+** If unable to get the current directory, it returns nil
+**  and a string describing the error
+*/
+static int get_dir (lua_State *L) {
+  char *path;
+  /* Passing (NULL, 0) is not guaranteed to work. Use a temp buffer and size instead. */
+  char buf[LFS_MAXPATHLEN];
+  if ((path = getcwd(buf, LFS_MAXPATHLEN)) == NULL) {
+    lua_pushnil(L);
+    lua_pushstring(L, getcwd_error);
+    return 2;
+  }
+  else {
+    lua_pushstring(L, path);
+    return 1;
+  }
+}
+
+/*
+** Check if the given element on the stack is a file and returns it.
+*/
+static FILE *check_file (lua_State *L, int idx, const char *funcname) {
+        FILE **fh = (FILE **)luaL_checkudata (L, idx, "FILE*");
+        if (fh == NULL) {
+                luaL_error (L, "%s: not a file", funcname);
+                return 0;
+        } else if (*fh == NULL) {
+                luaL_error (L, "%s: closed file", funcname);
+                return 0;
+        } else
+                return *fh;
+}
+
+
+/*
+**
+*/
+static int _file_lock (lua_State *L, FILE *fh, const char *mode, const long start, long len, const char *funcname) {
+        int code;
+#ifdef _WIN32
+        /* lkmode valid values are:
+           LK_LOCK    Locks the specified bytes. If the bytes cannot be locked, the program immediately tries again after 1 second. If, after 10 attempts, the bytes cannot be locked, the constant returns an error.
+           LK_NBLCK   Locks the specified bytes. If the bytes cannot be locked, the constant returns an error.
+           LK_NBRLCK  Same as _LK_NBLCK.
+           LK_RLCK    Same as _LK_LOCK.
+           LK_UNLCK   Unlocks the specified bytes, which must have been previously locked.
+
+           Regions should be locked only briefly and should be unlocked before closing a file or exiting the program.
+
+           http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclib/html/_crt__locking.asp
+        */
+        int lkmode;
+        switch (*mode) {
+                case 'r': lkmode = LK_NBLCK; break;
+                case 'w': lkmode = LK_NBLCK; break;
+                case 'u': lkmode = LK_UNLCK; break;
+                default : return luaL_error (L, "%s: invalid mode", funcname);
+        }
+        if (!len) {
+                fseek (fh, 0L, SEEK_END);
+                len = ftell (fh);
+        }
+        fseek (fh, start, SEEK_SET);
+#ifdef __BORLANDC__
+        code = locking (_fileno(fh), lkmode, len);
+#else
+        code = _locking (_fileno(fh), lkmode, len);
+#endif
+#else
+        struct flock f;
+        switch (*mode) {
+                case 'w': f.l_type = F_WRLCK; break;
+                case 'r': f.l_type = F_RDLCK; break;
+                case 'u': f.l_type = F_UNLCK; break;
+                default : return luaL_error (L, "%s: invalid mode", funcname);
+        }
+        f.l_whence = SEEK_SET;
+        f.l_start = (off_t)start;
+        f.l_len = (off_t)len;
+        code = fcntl (fileno(fh), F_SETLK, &f);
+#endif
+        return (code != -1);
+}
+
+#ifdef _WIN32
+typedef struct lfs_Lock {
+  HANDLE fd;
+} lfs_Lock;
+static int lfs_lock_dir(lua_State *L) {
+  size_t pathl; HANDLE fd;
+  lfs_Lock *lock;
+  char *ln;
+  const char *lockfile = "/lockfile.lfs";
+  const char *path = luaL_checklstring(L, 1, &pathl);
+  ln = (char*)malloc(pathl + strlen(lockfile) + 1);
+  if(!ln) {
+    lua_pushnil(L); lua_pushstring(L, strerror(errno)); return 2;
+  }
+  strcpy(ln, path); strcat(ln, lockfile);
+  if((fd = CreateFile(ln, GENERIC_WRITE, 0, NULL, CREATE_NEW,
+                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL)) == INVALID_HANDLE_VALUE) {
+        int en = GetLastError();
+        free(ln); lua_pushnil(L);
+        if(en == ERROR_FILE_EXISTS || en == ERROR_SHARING_VIOLATION)
+                lua_pushstring(L, "File exists");
+        else
+                lua_pushstring(L, strerror(en));
+        return 2;
+  }
+  free(ln);
+  lock = (lfs_Lock*)lua_newuserdata(L, sizeof(lfs_Lock));
+  lock->fd = fd;
+  luaL_getmetatable (L, LOCK_METATABLE);
+  lua_setmetatable (L, -2);
+  return 1;
+}
+static int lfs_unlock_dir(lua_State *L) {
+  lfs_Lock *lock = luaL_checkudata(L, 1, LOCK_METATABLE);
+  CloseHandle(lock->fd);
+  return 0;
+}
+#else
+typedef struct lfs_Lock {
+  char *ln;
+} lfs_Lock;
+static int lfs_lock_dir(lua_State *L) {
+  lfs_Lock *lock;
+  size_t pathl;
+  char *ln;
+  const char *lockfile = "/lockfile.lfs";
+  const char *path = luaL_checklstring(L, 1, &pathl);
+  lock = (lfs_Lock*)lua_newuserdata(L, sizeof(lfs_Lock));
+  ln = (char*)malloc(pathl + strlen(lockfile) + 1);
+  if(!ln) {
+    lua_pushnil(L); lua_pushstring(L, strerror(errno)); return 2;
+  }
+  strcpy(ln, path); strcat(ln, lockfile);
+  if(symlink("lock", ln) == -1) {
+    free(ln); lua_pushnil(L);
+    lua_pushstring(L, strerror(errno)); return 2;
+  }
+  lock->ln = ln;
+  luaL_getmetatable (L, LOCK_METATABLE);
+  lua_setmetatable (L, -2);
+  return 1;
+}
+static int lfs_unlock_dir(lua_State *L) {
+  lfs_Lock *lock = luaL_checkudata(L, 1, LOCK_METATABLE);
+  if(lock->ln) {
+    unlink(lock->ln);
+    free(lock->ln);
+    lock->ln = NULL;
+  }
+  return 0;
+}
+#endif
+
+static int lfs_g_setmode (lua_State *L, FILE *f, int arg) {
+  static const int mode[] = {_O_BINARY, _O_TEXT};
+  static const char *const modenames[] = {"binary", "text", NULL};
+  int op = luaL_checkoption(L, arg, NULL, modenames);
+  int res = lfs_setmode(L, f, mode[op]);
+  if (res != -1) {
+    int i;
+    lua_pushboolean(L, 1);
+    for (i = 0; modenames[i] != NULL; i++) {
+      if (mode[i] == res) {
+        lua_pushstring(L, modenames[i]);
+        goto exit;
+      }
+    }
+    lua_pushnil(L);
+  exit:
+    return 2;
+  } else {
+    int en = errno;
+    lua_pushnil(L);
+    lua_pushfstring(L, "%s", strerror(en));
+    lua_pushinteger(L, en);
+    return 3;
+  }
+}
+
+static int lfs_f_setmode(lua_State *L) {
+  return lfs_g_setmode(L, check_file(L, 1, "setmode"), 2);
+}
+
+/*
+** Locks a file.
+** @param #1 File handle.
+** @param #2 String with lock mode ('w'rite, 'r'ead).
+** @param #3 Number with start position (optional).
+** @param #4 Number with length (optional).
+*/
+static int file_lock (lua_State *L) {
+        FILE *fh = check_file (L, 1, "lock");
+        const char *mode = luaL_checkstring (L, 2);
+        const long start = luaL_optlong (L, 3, 0);
+        long len = luaL_optlong (L, 4, 0);
+        if (_file_lock (L, fh, mode, start, len, "lock")) {
+                lua_pushboolean (L, 1);
+                return 1;
+        } else {
+                lua_pushnil (L);
+                lua_pushfstring (L, "%s", strerror(errno));
+                return 2;
+        }
+}
+
+
+/*
+** Unlocks a file.
+** @param #1 File handle.
+** @param #2 Number with start position (optional).
+** @param #3 Number with length (optional).
+*/
+static int file_unlock (lua_State *L) {
+        FILE *fh = check_file (L, 1, "unlock");
+        const long start = luaL_optlong (L, 2, 0);
+        long len = luaL_optlong (L, 3, 0);
+        if (_file_lock (L, fh, "u", start, len, "unlock")) {
+                lua_pushboolean (L, 1);
+                return 1;
+        } else {
+                lua_pushnil (L);
+                lua_pushfstring (L, "%s", strerror(errno));
+                return 2;
+        }
+}
+
+
+/*
+** Creates a link.
+** @param #1 Object to link to.
+** @param #2 Name of link.
+** @param #3 True if link is symbolic (optional).
+*/
+static int make_link(lua_State *L)
+{
+#ifndef _WIN32
+        const char *oldpath = luaL_checkstring(L, 1);
+        const char *newpath = luaL_checkstring(L, 2);
+        return pushresult(L,
+                (lua_toboolean(L,3) ? symlink : link)(oldpath, newpath), NULL);
+#else
+        pusherror(L, "make_link is not supported on Windows");
+#endif
+}
+
+
+/*
+** Creates a directory.
+** @param #1 Directory path.
+*/
+static int make_dir (lua_State *L) {
+        const char *path = luaL_checkstring (L, 1);
+        int fail;
+#ifdef _WIN32
+        fail = _mkdir (path);
+#else
+        fail =  mkdir (path, S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP |
+                             S_IWGRP | S_IXGRP | S_IROTH | S_IXOTH );
+#endif
+        if (fail) {
+                lua_pushnil (L);
+        lua_pushfstring (L, "%s", strerror(errno));
+                return 2;
+        }
+        lua_pushboolean (L, 1);
+        return 1;
+}
+
+/*
+** Removes a directory.
+** @param #1 Directory path.
+*/
+static int remove_dir (lua_State *L) {
+        const char *path = luaL_checkstring (L, 1);
+        int fail;
+
+        fail = rmdir (path);
+
+        if (fail) {
+                lua_pushnil (L);
+                lua_pushfstring (L, "%s", strerror(errno));
+                return 2;
+        }
+        lua_pushboolean (L, 1);
+        return 1;
+}
+
+/*
+** Directory iterator
+*/
+static int dir_iter (lua_State *L) {
+#ifdef _WIN32
+        struct _finddata_t c_file;
+#else
+        struct dirent *entry;
+#endif
+        dir_data *d = (dir_data *)luaL_checkudata (L, 1, DIR_METATABLE);
+        luaL_argcheck (L, d->closed == 0, 1, "closed directory");
+#ifdef _WIN32
+        if (d->hFile == 0L) { /* first entry */
+                if ((d->hFile = _findfirst (d->pattern, &c_file)) == -1L) {
+                        lua_pushnil (L);
+                        lua_pushstring (L, strerror (errno));
+                        d->closed = 1;
+                        return 2;
+                } else {
+                        lua_pushstring (L, c_file.name);
+                        return 1;
+                }
+        } else { /* next entry */
+                if (_findnext (d->hFile, &c_file) == -1L) {
+                        /* no more entries => close directory */
+                        _findclose (d->hFile);
+                        d->closed = 1;
+                        return 0;
+                } else {
+                        lua_pushstring (L, c_file.name);
+                        return 1;
+                }
+        }
+#else
+        if ((entry = readdir (d->dir)) != NULL) {
+                lua_pushstring (L, entry->d_name);
+                return 1;
+        } else {
+                /* no more entries => close directory */
+                closedir (d->dir);
+                d->closed = 1;
+                return 0;
+        }
+#endif
+}
+
+
+/*
+** Closes directory iterators
+*/
+static int dir_close (lua_State *L) {
+        dir_data *d = (dir_data *)lua_touserdata (L, 1);
+#ifdef _WIN32
+        if (!d->closed && d->hFile) {
+                _findclose (d->hFile);
+        }
+#else
+        if (!d->closed && d->dir) {
+                closedir (d->dir);
+        }
+#endif
+        d->closed = 1;
+        return 0;
+}
+
+
+/*
+** Factory of directory iterators
+*/
+static int dir_iter_factory (lua_State *L) {
+        const char *path = luaL_checkstring (L, 1);
+        dir_data *d;
+        lua_pushcfunction (L, dir_iter);
+        d = (dir_data *) lua_newuserdata (L, sizeof(dir_data));
+        luaL_getmetatable (L, DIR_METATABLE);
+        lua_setmetatable (L, -2);
+        d->closed = 0;
+#ifdef _WIN32
+        d->hFile = 0L;
+        if (strlen(path) > MAX_PATH-2)
+          luaL_error (L, "path too long: %s", path);
+        else
+          sprintf (d->pattern, "%s/*", path);
+#else
+        d->dir = opendir (path);
+        if (d->dir == NULL)
+          luaL_error (L, "cannot open %s: %s", path, strerror (errno));
+#endif
+        return 2;
+}
+
+
+/*
+** Creates directory metatable.
+*/
+static int dir_create_meta (lua_State *L) {
+        luaL_newmetatable (L, DIR_METATABLE);
+
+        /* Method table */
+        lua_newtable(L);
+        lua_pushcfunction (L, dir_iter);
+        lua_setfield(L, -2, "next");
+        lua_pushcfunction (L, dir_close);
+        lua_setfield(L, -2, "close");
+
+        /* Metamethods */
+        lua_setfield(L, -2, "__index");
+        lua_pushcfunction (L, dir_close);
+        lua_setfield (L, -2, "__gc");
+        return 1;
+}
+
+/*
+** Creates lock metatable.
+*/
+static int lock_create_meta (lua_State *L) {
+        luaL_newmetatable (L, LOCK_METATABLE);
+
+        /* Method table */
+        lua_newtable(L);
+        lua_pushcfunction(L, lfs_unlock_dir);
+        lua_setfield(L, -2, "free");
+
+        /* Metamethods */
+        lua_setfield(L, -2, "__index");
+        lua_pushcfunction(L, lfs_unlock_dir);
+        lua_setfield(L, -2, "__gc");
+        return 1;
+}
+
+
+#ifdef _WIN32
+ #ifndef S_ISDIR
+   #define S_ISDIR(mode)  (mode&_S_IFDIR)
+ #endif
+ #ifndef S_ISREG
+   #define S_ISREG(mode)  (mode&_S_IFREG)
+ #endif
+ #ifndef S_ISLNK
+   #define S_ISLNK(mode)  (0)
+ #endif
+ #ifndef S_ISSOCK
+   #define S_ISSOCK(mode)  (0)
+ #endif
+ #ifndef S_ISFIFO
+   #define S_ISFIFO(mode)  (0)
+ #endif
+ #ifndef S_ISCHR
+   #define S_ISCHR(mode)  (mode&_S_IFCHR)
+ #endif
+ #ifndef S_ISBLK
+   #define S_ISBLK(mode)  (0)
+ #endif
+#endif
+/*
+** Convert the inode protection mode to a string.
+*/
+#ifdef _WIN32
+static const char *mode2string (unsigned short mode) {
+#else
+static const char *mode2string (mode_t mode) {
+#endif
+  if ( S_ISREG(mode) )
+    return "file";
+  else if ( S_ISDIR(mode) )
+    return "directory";
+  else if ( S_ISLNK(mode) )
+        return "link";
+  else if ( S_ISSOCK(mode) )
+    return "socket";
+  else if ( S_ISFIFO(mode) )
+        return "named pipe";
+  else if ( S_ISCHR(mode) )
+        return "char device";
+  else if ( S_ISBLK(mode) )
+        return "block device";
+  else
+        return "other";
+}
+
+
+/*
+** Set access time and modification values for file
+*/
+static int file_utime (lua_State *L) {
+        const char *file = luaL_checkstring (L, 1);
+        struct utimbuf utb, *buf;
+
+        if (lua_gettop (L) == 1) /* set to current date/time */
+                buf = NULL;
+        else {
+                utb.actime = (time_t)luaL_optnumber (L, 2, 0);
+                utb.modtime = (time_t)luaL_optnumber (L, 3, utb.actime);
+                buf = &utb;
+        }
+        if (utime (file, buf)) {
+                lua_pushnil (L);
+                lua_pushfstring (L, "%s", strerror (errno));
+                return 2;
+        }
+        lua_pushboolean (L, 1);
+        return 1;
+}
+
+
+/* inode protection mode */
+static void push_st_mode (lua_State *L, STAT_STRUCT *info) {
+        lua_pushstring (L, mode2string (info->st_mode));
+}
+/* device inode resides on */
+static void push_st_dev (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, (lua_Number)info->st_dev);
+}
+/* inode's number */
+static void push_st_ino (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, (lua_Number)info->st_ino);
+}
+/* number of hard links to the file */
+static void push_st_nlink (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, (lua_Number)info->st_nlink);
+}
+/* user-id of owner */
+static void push_st_uid (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, (lua_Number)info->st_uid);
+}
+/* group-id of owner */
+static void push_st_gid (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, (lua_Number)info->st_gid);
+}
+/* device type, for special file inode */
+static void push_st_rdev (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, (lua_Number)info->st_rdev);
+}
+/* time of last access */
+static void push_st_atime (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, info->st_atime);
+}
+/* time of last data modification */
+static void push_st_mtime (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, info->st_mtime);
+}
+/* time of last file status change */
+static void push_st_ctime (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, info->st_ctime);
+}
+/* file size, in bytes */
+static void push_st_size (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, (lua_Number)info->st_size);
+}
+#ifndef _WIN32
+/* blocks allocated for file */
+static void push_st_blocks (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, (lua_Number)info->st_blocks);
+}
+/* optimal file system I/O blocksize */
+static void push_st_blksize (lua_State *L, STAT_STRUCT *info) {
+        lua_pushnumber (L, (lua_Number)info->st_blksize);
+}
+#endif
+static void push_invalid (lua_State *L, STAT_STRUCT *info) {
+  luaL_error(L, "invalid attribute name");
+#ifndef _WIN32
+  info->st_blksize = 0; /* never reached */
+#endif
+}
+
+ /*
+** Convert the inode protection mode to a permission list.
+*/
+
+#ifdef _WIN32
+static const char *perm2string (unsigned short mode) {
+  static char perms[10] = "---------\0";
+  int i;
+  for (i=0;i<9;i++) perms[i]='-';
+  if (mode  & _S_IREAD)
+   { perms[0] = 'r'; perms[3] = 'r'; perms[6] = 'r'; }
+  if (mode  & _S_IWRITE)
+   { perms[1] = 'w'; perms[4] = 'w'; perms[7] = 'w'; }
+  if (mode  & _S_IEXEC)
+   { perms[2] = 'x'; perms[5] = 'x'; perms[8] = 'x'; }
+  return perms;
+}
+#else
+static const char *perm2string (mode_t mode) {
+  static char perms[10] = "---------\0";
+  int i;
+  for (i=0;i<9;i++) perms[i]='-';
+  if (mode & S_IRUSR) perms[0] = 'r';
+  if (mode & S_IWUSR) perms[1] = 'w';
+  if (mode & S_IXUSR) perms[2] = 'x';
+  if (mode & S_IRGRP) perms[3] = 'r';
+  if (mode & S_IWGRP) perms[4] = 'w';
+  if (mode & S_IXGRP) perms[5] = 'x';
+  if (mode & S_IROTH) perms[6] = 'r';
+  if (mode & S_IWOTH) perms[7] = 'w';
+  if (mode & S_IXOTH) perms[8] = 'x';
+  return perms;
+}
+#endif
+
+/* permssions string */
+static void push_st_perm (lua_State *L, STAT_STRUCT *info) {
+    lua_pushstring (L, perm2string (info->st_mode));
+}
+
+typedef void (*_push_function) (lua_State *L, STAT_STRUCT *info);
+
+struct _stat_members {
+        const char *name;
+        _push_function push;
+};
+
+struct _stat_members members[] = {
+        { "mode",         push_st_mode },
+        { "dev",          push_st_dev },
+        { "ino",          push_st_ino },
+        { "nlink",        push_st_nlink },
+        { "uid",          push_st_uid },
+        { "gid",          push_st_gid },
+        { "rdev",         push_st_rdev },
+        { "access",       push_st_atime },
+        { "modification", push_st_mtime },
+        { "change",       push_st_ctime },
+        { "size",         push_st_size },
+        { "permissions",  push_st_perm },
+#ifndef _WIN32
+        { "blocks",       push_st_blocks },
+        { "blksize",      push_st_blksize },
+#endif
+        { NULL, push_invalid }
+};
+
+/*
+** Get file or symbolic link information
+*/
+static int _file_info_ (lua_State *L, int (*st)(const char*, STAT_STRUCT*)) {
+        int i;
+        STAT_STRUCT info;
+        const char *file = luaL_checkstring (L, 1);
+
+        if (st(file, &info)) {
+                lua_pushnil (L);
+                lua_pushfstring (L, "cannot obtain information from file `%s'", file);
+                return 2;
+        }
+        if (lua_isstring (L, 2)) {
+                int v;
+                const char *member = lua_tostring (L, 2);
+                if (strcmp (member, "mode") == 0) v = 0;
+#ifndef _WIN32
+                else if (strcmp (member, "blocks")  == 0) v = 11;
+                else if (strcmp (member, "blksize") == 0) v = 12;
+#endif
+                else /* look for member */
+                        for (v = 1; members[v].name; v++)
+                                if (*members[v].name == *member)
+                                        break;
+                /* push member value and return */
+                members[v].push (L, &info);
+                return 1;
+        } else if (!lua_istable (L, 2))
+                /* creates a table if none is given */
+                lua_newtable (L);
+        /* stores all members in table on top of the stack */
+        for (i = 0; members[i].name; i++) {
+                lua_pushstring (L, members[i].name);
+                members[i].push (L, &info);
+                lua_rawset (L, -3);
+        }
+        return 1;
+}
+
+
+/*
+** Get file information using stat.
+*/
+static int file_info (lua_State *L) {
+        return _file_info_ (L, STAT_FUNC);
+}
+
+
+/*
+** Get symbolic link information using lstat.
+*/
+static int link_info (lua_State *L) {
+        return _file_info_ (L, LSTAT_FUNC);
+}
+
+
+/*
+** Assumes the table is on top of the stack.
+*/
+static void set_info (lua_State *L) {
+        lua_pushliteral (L, "_COPYRIGHT");
+        lua_pushliteral (L, "Copyright (C) 2003-2012 Kepler Project");
+        lua_settable (L, -3);
+        lua_pushliteral (L, "_DESCRIPTION");
+        lua_pushliteral (L, "LuaFileSystem is a Lua library developed to complement the set of functions related to file systems offered by the standard Lua distribution");
+        lua_settable (L, -3);
+        lua_pushliteral (L, "_VERSION");
+        lua_pushliteral (L, "LuaFileSystem "LFS_VERSION);
+        lua_settable (L, -3);
+}
+
+
+static const struct luaL_Reg fslib[] = {
+        {"attributes", file_info},
+        {"chdir", change_dir},
+        {"currentdir", get_dir},
+        {"dir", dir_iter_factory},
+        {"link", make_link},
+        {"lock", file_lock},
+        {"mkdir", make_dir},
+        {"rmdir", remove_dir},
+        {"symlinkattributes", link_info},
+        {"setmode", lfs_f_setmode},
+        {"touch", file_utime},
+        {"unlock", file_unlock},
+        {"lock_dir", lfs_lock_dir},
+        {NULL, NULL},
+};
+
+int luaopen_lfs (lua_State *L) {
+        dir_create_meta (L);
+        lock_create_meta (L);
+        luaL_newlib (L, fslib);
+        lua_pushvalue(L, -1);
+        lua_setglobal(L, LFS_LIBNAME);
+        set_info (L);
+        return 1;
+}
diff --git a/scripting/lua/lfs/lfs.h b/scripting/lua/lfs/lfs.h
new file mode 100755
index 0000000..006eda6
--- /dev/null
+++ b/scripting/lua/lfs/lfs.h
@@ -0,0 +1,17 @@
+/*
+** LuaFileSystem
+** Copyright Kepler Project 2003 (http://www.keplerproject.org/luafilesystem)
+**
+** $Id: lfs.h,v 1.5 2008/02/19 20:08:23 mascarenhas Exp $
+*/
+
+/* Define 'chdir' for systems that do not implement it */
+#ifdef NO_CHDIR
+#define chdir(p)	(-1)
+#define chdir_error	"Function 'chdir' not provided by system"
+#else
+#define chdir_error	strerror(errno)
+#endif
+
+
+extern int luaopen_lfs (lua_State *L);
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/host/buildvm_arch.h b/scripting/lua/luajit/LuaJIT-2.0.1/src/host/buildvm_arch.h
new file mode 100755
index 0000000..c4eb05e
--- /dev/null
+++ b/scripting/lua/luajit/LuaJIT-2.0.1/src/host/buildvm_arch.h
@@ -0,0 +1,2133 @@
+/*
+** This file has been pre-processed with DynASM.
+** http://luajit.org/dynasm.html
+** DynASM version 1.3.0, DynASM x86 version 1.3.0
+** DO NOT EDIT! The original file is in "vm_x86.dasc".
+*/
+
+#if DASM_VERSION != 10300
+#error "Version mismatch between DynASM and included encoding engine"
+#endif
+
+#define DASM_SECTION_CODE_OP	0
+#define DASM_SECTION_CODE_SUB	1
+#define DASM_MAXSECTION		2
+static const unsigned char build_actionlist[14066] = {
+  254,1,248,10,252,247,198,237,15,132,244,11,131,230,252,248,41,252,242,141,
+  76,49,252,248,139,114,252,252,199,68,10,4,237,248,12,131,192,1,15,132,244,
+  13,137,68,36,20,252,247,198,237,15,132,244,14,248,15,129,252,246,239,252,
+  247,198,237,15,133,244,10,199,131,233,237,131,230,252,248,41,214,252,247,
+  222,131,232,1,15,132,244,248,248,1,255,139,44,10,137,106,252,248,139,108,
+  10,4,137,106,252,252,131,194,8,131,232,1,15,133,244,1,248,2,139,108,36,48,
+  137,181,233,248,3,139,68,36,20,139,76,36,56,248,4,57,193,15,133,244,252,248,
+  5,131,252,234,8,137,149,233,248,16,139,76,36,52,137,141,233,49,192,248,17,
+  131,196,28,91,94,95,93,195,248,6,15,130,244,253,59,149,233,15,135,244,254,
+  199,66,252,252,237,255,131,194,8,131,192,1,252,233,244,4,248,7,133,201,15,
+  132,244,5,41,193,141,20,202,252,233,244,5,248,8,137,149,233,137,68,36,20,
+  137,202,137,252,233,232,251,1,0,139,149,233,252,233,244,3,248,13,176,235,
+  252,233,244,18,248,19,137,208,137,204,248,18,139,108,36,48,139,173,233,199,
+  133,233,237,255,252,233,244,17,248,20,248,21,129,225,239,137,204,248,22,139,
+  108,36,48,185,252,248,252,255,252,255,252,255,184,237,139,149,233,139,157,
+  233,129,195,239,139,114,252,252,199,66,252,252,237,199,131,233,237,252,233,
+  244,12,248,23,186,237,252,233,244,248,248,24,255,131,232,8,252,233,244,247,
+  248,25,141,68,194,252,248,248,1,15,182,142,233,131,198,4,137,149,233,137,
+  133,233,137,116,36,24,137,202,248,2,137,252,233,232,251,1,0,139,149,233,139,
+  133,233,139,106,252,248,41,208,193,232,3,131,192,1,139,181,233,139,14,15,
+  182,252,233,15,182,205,131,198,4,252,255,36,171,248,26,85,87,86,83,131,252,
+  236,28,139,108,36,48,139,76,36,52,190,237,49,192,141,188,253,36,233,139,157,
+  233,129,195,239,137,189,233,137,68,36,24,137,68,36,52,56,133,233,15,132,244,
+  249,255,199,131,233,237,136,133,233,139,149,233,139,133,233,41,200,193,232,
+  3,131,192,1,41,209,139,114,252,252,137,68,36,20,252,247,198,237,15,132,244,
+  14,252,233,244,15,248,27,85,87,86,83,131,252,236,28,190,237,252,233,244,247,
+  248,28,85,87,86,83,131,252,236,28,190,237,248,1,139,108,36,48,139,76,36,52,
+  139,189,233,137,124,36,52,137,108,36,24,137,165,233,248,2,255,139,157,233,
+  129,195,239,248,3,199,131,233,237,139,149,233,1,206,41,214,139,133,233,41,
+  200,193,232,3,131,192,1,248,29,139,105,252,248,129,121,253,252,252,239,15,
+  133,244,30,248,31,137,202,137,114,252,252,139,181,233,139,14,15,182,252,233,
+  15,182,205,131,198,4,252,255,36,171,248,32,85,87,86,83,131,252,236,28,139,
+  108,36,48,139,68,36,56,139,76,36,52,139,84,36,60,137,108,36,24,139,189,233,
+  43,189,233,199,68,36,60,0,0,0,0,137,124,36,56,137,68,36,8,137,76,36,4,137,
+  44,36,139,189,233,137,124,36,52,137,165,233,252,255,210,133,192,15,132,244,
+  16,255,137,193,190,237,252,233,244,2,248,11,1,209,131,230,252,248,137,213,
+  41,252,242,199,68,193,252,252,237,137,200,139,117,252,244,139,77,252,240,
+  131,252,249,1,15,134,244,247,139,122,252,248,139,191,233,139,191,233,252,
+  255,225,248,1,15,132,244,33,41,213,193,252,237,3,141,69,252,255,252,233,244,
+  34,248,35,15,182,78,252,255,131,252,237,16,141,12,202,41,252,233,15,132,244,
+  36,252,247,217,193,252,233,3,137,76,36,8,139,72,4,139,0,137,77,4,137,69,0,
+  137,108,36,4,252,233,244,37,248,38,255,137,68,36,16,199,68,36,20,237,141,
+  68,36,16,128,126,252,252,235,15,133,244,247,141,139,233,137,41,199,65,4,237,
+  137,205,252,233,244,248,248,39,15,182,70,252,254,137,68,36,12,219,68,36,12,
+  221,92,36,16,141,68,36,16,252,233,244,247,248,40,15,182,70,252,254,141,4,
+  194,248,1,15,182,110,252,255,141,44,252,234,248,2,137,108,36,4,139,108,36,
+  48,137,68,36,8,137,44,36,137,149,233,137,116,36,24,232,251,1,1,139,149,233,
+  133,192,15,132,244,249,248,36,15,182,78,252,253,139,104,4,139,0,137,108,202,
+  4,137,4,202,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,
+  248,3,255,139,141,233,137,113,252,244,141,177,233,41,214,139,105,252,248,
+  184,237,252,233,244,31,248,41,137,68,36,16,199,68,36,20,237,141,68,36,16,
+  128,126,252,252,235,15,133,244,247,141,139,233,137,41,199,65,4,237,137,205,
+  252,233,244,248,248,42,15,182,70,252,254,137,68,36,12,219,68,36,12,221,92,
+  36,16,141,68,36,16,252,233,244,247,248,43,15,182,70,252,254,141,4,194,248,
+  1,15,182,110,252,255,141,44,252,234,248,2,255,137,108,36,4,139,108,36,48,
+  137,68,36,8,137,44,36,137,149,233,137,116,36,24,232,251,1,2,139,149,233,133,
+  192,15,132,244,249,15,182,78,252,253,139,108,202,4,139,12,202,137,104,4,137,
+  8,248,44,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,
+  248,3,139,141,233,137,113,252,244,15,182,70,252,253,139,108,194,4,139,4,194,
+  137,105,20,137,65,16,141,177,233,41,214,139,105,252,248,184,237,252,233,244,
+  31,248,45,15,182,110,252,252,141,4,194,141,12,202,137,108,36,12,139,108,36,
+  48,137,68,36,8,137,76,36,4,137,44,36,137,149,233,137,116,36,24,232,251,1,
+  3,248,3,139,149,233,131,252,248,1,15,135,244,46,248,4,141,118,4,15,130,244,
+  252,248,5,255,15,183,70,252,254,141,180,253,134,233,248,6,139,6,15,182,204,
+  15,182,232,131,198,4,193,232,16,252,255,36,171,248,47,131,198,4,129,120,253,
+  4,239,15,130,244,5,252,233,244,6,248,48,129,120,253,4,239,252,233,244,4,248,
+  49,131,252,238,4,137,108,36,12,139,108,36,48,137,68,36,8,137,76,36,4,137,
+  44,36,137,149,233,137,116,36,24,232,251,1,4,252,233,244,3,248,50,131,252,
+  238,4,139,108,36,48,137,149,233,137,252,233,139,86,252,252,137,116,36,24,
+  232,251,1,5,252,233,244,3,248,51,248,52,255,141,4,199,252,233,244,247,248,
+  53,248,54,141,4,199,141,44,252,234,149,252,233,244,248,248,55,141,4,194,137,
+  197,252,233,244,248,248,56,248,57,141,4,194,248,1,141,44,252,234,248,2,141,
+  12,202,137,108,36,8,139,108,36,48,137,68,36,12,15,182,70,252,252,137,76,36,
+  4,137,68,36,16,137,44,36,137,149,233,137,116,36,24,232,251,1,6,139,149,233,
+  133,192,15,132,244,44,248,46,137,193,41,208,137,113,252,244,141,176,233,184,
+  237,255,252,233,244,29,248,58,139,108,36,48,137,149,233,141,20,194,137,252,
+  233,137,116,36,24,232,251,1,7,139,149,233,255,133,192,15,133,244,46,15,183,
+  70,252,254,139,12,194,252,233,244,59,255,252,233,244,46,255,248,60,141,76,
+  202,8,248,30,137,76,36,20,137,68,36,16,131,252,233,8,141,4,193,139,108,36,
+  48,137,76,36,4,137,68,36,8,137,44,36,137,149,233,137,116,36,24,232,251,1,
+  8,139,149,233,139,76,36,20,139,68,36,16,139,105,252,248,131,192,1,57,215,
+  15,132,244,61,137,202,137,114,252,252,139,181,233,139,14,15,182,252,233,15,
+  182,205,131,198,4,252,255,36,171,248,62,139,108,36,48,137,149,233,137,202,
+  137,252,233,137,116,36,24,232,251,1,9,139,149,233,139,70,252,252,15,182,204,
+  15,182,232,193,232,16,252,255,164,253,171,233,248,63,129,252,248,239,15,130,
+  244,64,139,106,4,129,252,253,239,15,131,244,64,139,114,252,252,137,68,36,
+  20,137,106,252,252,139,42,137,106,252,248,131,232,2,15,132,244,248,255,137,
+  209,248,1,131,193,8,139,105,4,137,105,252,252,139,41,137,105,252,248,131,
+  232,1,15,133,244,1,248,2,139,68,36,20,252,233,244,65,248,66,129,252,248,239,
+  15,130,244,64,139,106,4,184,237,252,247,213,57,232,15,71,197,248,2,139,106,
+  252,248,139,132,253,197,233,139,114,252,252,199,66,252,252,237,137,66,252,
+  248,252,233,244,67,248,68,129,252,248,239,15,130,244,64,255,139,106,4,139,
+  114,252,252,129,252,253,239,15,133,244,252,248,1,139,42,139,173,233,248,2,
+  133,252,237,199,66,252,252,237,15,132,244,67,139,131,233,199,66,252,252,237,
+  137,106,252,248,139,141,233,35,136,233,105,201,239,3,141,233,248,3,129,185,
+  233,239,15,133,244,250,255,57,129,233,15,132,244,251,248,4,139,137,233,133,
+  201,15,133,244,3,252,233,244,67,248,5,139,105,4,129,252,253,239,15,132,244,
+  67,139,1,137,106,252,252,137,66,252,248,252,233,244,67,248,6,129,252,253,
+  239,15,132,244,1,129,252,253,239,255,15,135,244,254,189,237,248,8,252,247,
+  213,139,172,253,171,233,252,233,244,2,248,69,129,252,248,239,15,130,244,64,
+  129,122,253,4,239,15,133,244,64,139,42,131,189,233,0,15,133,244,64,129,122,
+  253,12,239,15,133,244,64,255,139,66,8,137,133,233,139,114,252,252,199,66,
+  252,252,237,137,106,252,248,252,246,133,233,235,15,132,244,247,128,165,233,
+  235,139,131,233,137,171,233,137,133,233,248,1,252,233,244,67,248,70,129,252,
+  248,239,15,130,244,64,129,122,253,4,239,15,133,244,64,255,139,2,139,108,36,
+  48,137,68,36,4,137,44,36,137,213,131,194,8,137,84,36,8,232,251,1,10,137,252,
+  234,139,40,139,64,4,139,114,252,252,137,106,252,248,137,66,252,252,252,233,
+  244,67,248,71,129,252,248,239,15,133,244,64,129,122,253,4,239,15,131,244,
+  64,221,2,252,233,244,72,248,73,129,252,248,239,15,130,244,64,139,114,252,
+  252,129,122,253,4,239,15,133,244,249,139,2,248,2,199,66,252,252,237,255,137,
+  66,252,248,252,233,244,67,248,3,129,122,253,4,239,15,135,244,64,131,187,233,
+  0,15,133,244,64,139,171,233,59,171,233,15,130,244,247,232,244,74,248,1,139,
+  108,36,48,137,149,233,137,116,36,24,137,252,233,232,251,1,11,139,149,233,
+  252,233,244,2,248,75,255,129,252,248,239,15,130,244,64,15,132,244,248,248,
+  1,129,122,253,4,239,15,133,244,64,139,108,36,48,137,149,233,137,149,233,139,
+  114,252,252,139,2,137,68,36,4,137,44,36,131,194,8,137,84,36,8,137,116,36,
+  24,232,251,1,12,139,149,233,133,192,15,132,244,249,139,106,8,139,66,12,137,
+  106,252,248,137,66,252,252,139,106,16,139,66,20,137,42,137,66,4,248,76,184,
+  237,252,233,244,77,248,2,199,66,12,237,255,252,233,244,1,248,3,199,66,252,
+  252,237,252,233,244,67,248,78,129,252,248,239,15,130,244,64,139,42,129,122,
+  253,4,239,15,133,244,64,255,131,189,233,0,15,133,244,64,255,139,106,252,248,
+  139,133,233,139,114,252,252,199,66,252,252,237,137,66,252,248,199,66,12,237,
+  184,237,252,233,244,77,248,79,129,252,248,239,15,130,244,64,129,122,253,4,
+  239,15,133,244,64,129,122,253,12,239,15,131,244,64,139,114,252,252,221,66,
+  8,217,232,222,193,219,20,36,221,90,252,248,139,4,36,139,42,59,133,233,15,
+  131,244,248,193,224,3,3,133,233,248,1,255,129,120,253,4,239,15,132,244,80,
+  139,40,139,64,4,137,42,137,66,4,252,233,244,76,248,2,131,189,233,0,15,132,
+  244,80,137,252,233,137,213,137,194,232,251,1,13,137,252,234,133,192,15,133,
+  244,1,248,80,184,237,252,233,244,77,248,81,129,252,248,239,15,130,244,64,
+  139,42,129,122,253,4,239,255,139,106,252,248,139,133,233,139,114,252,252,
+  199,66,252,252,237,137,66,252,248,217,252,238,221,90,8,184,237,252,233,244,
+  77,248,82,129,252,248,239,15,130,244,64,141,74,8,131,232,1,190,237,248,1,
+  15,182,171,233,193,252,237,235,131,229,1,1,252,238,252,233,244,29,248,83,
+  129,252,248,239,15,130,244,64,129,122,253,12,239,255,15,133,244,64,139,106,
+  4,137,106,12,199,66,4,237,139,42,139,114,8,137,106,8,137,50,141,74,16,131,
+  232,2,190,237,252,233,244,1,248,84,129,252,248,239,15,130,244,64,139,42,139,
+  114,252,252,137,116,36,24,137,44,36,129,122,253,4,239,15,133,244,64,131,189,
+  233,0,15,133,244,64,128,189,233,235,15,135,244,64,255,139,141,233,15,132,
+  244,247,59,141,233,15,132,244,64,248,1,141,116,193,252,240,59,181,233,15,
+  135,244,64,137,181,233,139,108,36,48,137,149,233,131,194,8,137,149,233,141,
+  108,194,232,41,252,245,57,206,15,132,244,249,248,2,139,68,46,4,137,70,252,
+  252,139,4,46,137,70,252,248,131,252,238,8,57,206,15,133,244,2,248,3,137,76,
+  36,4,49,201,137,76,36,12,137,76,36,8,232,244,26,255,199,131,233,237,139,108,
+  36,48,139,52,36,139,149,233,129,252,248,239,15,135,244,254,248,4,139,142,
+  233,139,190,233,137,142,233,137,252,254,41,206,15,132,244,252,141,4,50,193,
+  252,238,3,59,133,233,15,135,244,255,137,213,41,205,248,5,139,1,137,4,41,139,
+  65,4,137,68,41,4,131,193,8,57,252,249,15,133,244,5,248,6,141,70,2,199,66,
+  252,252,237,248,7,255,139,116,36,24,137,68,36,20,185,252,248,252,255,252,
+  255,252,255,252,247,198,237,15,132,244,14,252,233,244,15,248,8,199,66,252,
+  252,237,139,142,233,131,252,233,8,137,142,233,139,1,137,2,139,65,4,137,66,
+  4,184,237,252,233,244,7,248,9,139,12,36,137,185,233,137,252,242,137,252,233,
+  232,251,1,0,139,52,36,139,149,233,252,233,244,4,248,85,139,106,252,248,139,
+  173,233,139,114,252,252,137,116,36,24,137,44,36,131,189,233,0,255,15,133,
+  244,64,128,189,233,235,15,135,244,64,139,141,233,15,132,244,247,59,141,233,
+  15,132,244,64,248,1,141,116,193,252,248,59,181,233,15,135,244,64,137,181,
+  233,139,108,36,48,137,149,233,137,149,233,141,108,194,252,240,41,252,245,
+  57,206,15,132,244,249,248,2,255,139,68,46,4,137,70,252,252,139,4,46,137,70,
+  252,248,131,252,238,8,57,206,15,133,244,2,248,3,137,76,36,4,49,201,137,76,
+  36,12,137,76,36,8,232,244,26,199,131,233,237,139,108,36,48,139,52,36,139,
+  149,233,129,252,248,239,15,135,244,254,248,4,139,142,233,139,190,233,137,
+  142,233,137,252,254,41,206,15,132,244,252,141,4,50,193,252,238,3,59,133,233,
+  15,135,244,255,255,137,213,41,205,248,5,139,1,137,4,41,139,65,4,137,68,41,
+  4,131,193,8,57,252,249,15,133,244,5,248,6,141,70,1,248,7,139,116,36,24,137,
+  68,36,20,49,201,252,247,198,237,15,132,244,14,252,233,244,15,248,8,137,252,
+  242,137,252,233,232,251,1,14,248,9,139,12,36,137,185,233,137,252,242,137,
+  252,233,232,251,1,0,139,52,36,139,149,233,252,233,244,4,248,86,139,108,36,
+  48,252,247,133,233,237,15,132,244,64,255,137,149,233,141,68,194,252,248,137,
+  133,233,49,192,137,133,233,176,235,136,133,233,252,233,244,17,248,87,248,
+  88,129,252,248,239,15,130,244,64,129,122,253,4,239,15,131,244,64,221,2,217,
+  225,248,89,248,72,139,114,252,252,221,90,252,248,248,67,184,237,248,77,255,
+  137,68,36,20,248,65,252,247,198,237,15,133,244,253,248,5,56,70,252,255,15,
+  135,244,252,15,182,78,252,253,252,247,209,141,20,202,139,6,15,182,204,15,
+  182,232,131,198,4,193,232,16,252,255,36,171,248,6,199,68,194,252,244,237,
+  131,192,1,252,233,244,5,248,7,185,252,248,252,255,252,255,252,255,252,233,
+  244,15,248,90,129,122,253,4,239,15,131,244,64,221,2,232,244,91,255,252,233,
+  244,72,248,92,129,122,253,4,239,15,131,244,64,221,2,232,244,93,252,233,244,
+  72,248,94,129,252,248,239,15,130,244,64,129,122,253,4,239,15,131,244,64,221,
+  2,217,252,250,252,233,244,72,248,95,255,129,252,248,239,15,133,244,64,129,
+  122,253,4,239,15,131,244,64,217,252,237,221,2,217,252,241,252,233,244,72,
+  248,96,129,252,248,239,15,130,244,64,129,122,253,4,239,15,131,244,64,217,
+  252,236,221,2,217,252,241,252,233,244,72,248,97,129,252,248,239,15,130,244,
+  64,255,129,122,253,4,239,15,131,244,64,221,2,232,244,98,252,233,244,72,248,
+  99,129,252,248,239,15,130,244,64,129,122,253,4,239,15,131,244,64,221,2,217,
+  252,254,252,233,244,72,248,100,129,252,248,239,15,130,244,64,255,129,122,
+  253,4,239,15,131,244,64,221,2,217,252,255,252,233,244,72,248,101,129,252,
+  248,239,15,130,244,64,129,122,253,4,239,15,131,244,64,221,2,217,252,242,221,
+  216,252,233,244,72,248,102,129,252,248,239,15,130,244,64,129,122,253,4,239,
+  15,131,244,64,255,221,2,217,192,216,200,217,232,222,225,217,252,250,217,252,
+  243,252,233,244,72,248,103,129,252,248,239,15,130,244,64,129,122,253,4,239,
+  15,131,244,64,221,2,217,192,216,200,217,232,222,225,217,252,250,217,201,217,
+  252,243,252,233,244,72,248,104,129,252,248,239,15,130,244,64,129,122,253,
+  4,239,15,131,244,64,221,2,217,232,217,252,243,252,233,244,72,248,105,255,
+  129,252,248,239,15,130,244,64,129,122,253,4,239,15,131,244,64,221,2,221,28,
+  36,137,213,232,251,1,15,137,252,234,252,233,244,72,248,106,129,252,248,239,
+  15,130,244,64,129,122,253,4,239,15,131,244,64,221,2,221,28,36,137,213,232,
+  251,1,16,137,252,234,252,233,244,72,248,107,129,252,248,239,15,130,244,64,
+  255,129,122,253,4,239,15,131,244,64,221,2,221,28,36,137,213,232,251,1,17,
+  137,252,234,252,233,244,72,248,108,248,109,129,252,248,239,15,130,244,64,
+  129,122,253,4,239,15,131,244,64,221,2,139,106,252,248,220,141,233,252,233,
+  244,72,248,110,129,252,248,239,15,130,244,64,255,129,122,253,4,239,15,131,
+  244,64,129,122,253,12,239,15,131,244,64,221,2,221,66,8,217,252,243,252,233,
+  244,72,248,111,129,252,248,239,15,130,244,64,129,122,253,4,239,15,131,244,
+  64,129,122,253,12,239,15,131,244,64,221,66,8,221,2,217,252,253,221,217,252,
+  233,244,72,248,112,255,129,252,248,239,15,130,244,64,139,106,4,129,252,253,
+  239,15,131,244,64,139,114,252,252,139,2,137,106,252,252,137,66,252,248,209,
+  229,129,252,253,0,0,224,252,255,15,131,244,249,9,232,15,132,244,249,184,252,
+  254,3,0,0,129,252,253,0,0,32,0,15,130,244,250,248,1,193,252,237,21,41,197,
+  137,108,36,16,219,68,36,16,139,106,252,252,129,229,252,255,252,255,15,128,
+  129,205,0,0,224,63,137,106,252,252,248,2,221,26,184,237,252,233,244,77,248,
+  3,217,252,238,252,233,244,2,248,4,255,221,2,199,68,36,16,0,0,128,90,216,76,
+  36,16,221,90,252,248,139,106,252,252,184,52,4,0,0,209,229,252,233,244,1,248,
+  113,129,252,248,239,15,130,244,64,129,122,253,4,239,15,131,244,64,221,2,139,
+  106,4,139,114,252,252,209,229,129,252,253,0,0,224,252,255,15,132,244,250,
+  217,192,232,244,114,220,252,233,248,1,221,90,252,248,221,26,139,66,252,252,
+  139,106,4,49,232,15,136,244,249,248,2,184,237,252,233,244,77,248,3,255,129,
+  252,245,0,0,0,128,137,106,4,252,233,244,2,248,4,217,252,238,217,201,252,233,
+  244,1,248,115,129,252,248,239,15,130,244,64,129,122,253,4,239,15,131,244,
+  64,129,122,253,12,239,15,131,244,64,221,66,8,221,2,248,1,217,252,248,223,
+  224,158,15,138,244,1,221,217,252,233,244,72,248,116,255,129,252,248,239,15,
+  130,244,64,129,122,253,4,239,15,131,244,64,129,122,253,12,239,15,131,244,
+  64,221,2,221,66,8,232,244,117,252,233,244,72,248,118,185,2,0,0,0,129,122,
+  253,4,239,15,131,244,64,221,2,248,5,57,193,15,131,244,72,255,129,124,253,
+  202,252,252,239,15,131,244,255,248,6,221,68,202,252,248,248,7,219,252,233,
+  219,209,221,217,131,193,1,252,233,244,5,248,119,185,2,0,0,0,129,122,253,4,
+  239,15,131,244,64,221,2,248,5,57,193,15,131,244,72,129,124,253,202,252,252,
+  239,15,131,244,255,248,6,221,68,202,252,248,248,7,219,252,233,218,209,221,
+  217,131,193,1,252,233,244,5,248,9,255,221,216,252,233,244,64,248,120,129,
+  252,248,239,15,130,244,64,129,122,253,4,239,15,133,244,64,139,42,219,133,
+  233,252,233,244,72,248,121,129,252,248,239,15,133,244,64,129,122,253,4,239,
+  15,133,244,64,139,42,139,114,252,252,131,189,233,1,255,15,130,244,80,15,182,
+  173,233,137,108,36,16,219,68,36,16,252,233,244,72,248,122,139,171,233,59,
+  171,233,15,130,244,247,232,244,74,248,1,129,252,248,239,15,133,244,64,129,
+  122,253,4,239,15,131,244,64,221,2,219,92,36,20,129,124,36,20,252,255,0,0,
+  0,15,135,244,64,255,199,68,36,8,1,0,0,0,141,68,36,20,248,123,139,108,36,48,
+  137,149,233,137,68,36,4,137,44,36,137,116,36,24,232,251,1,18,139,149,233,
+  139,114,252,252,199,66,252,252,237,137,66,252,248,252,233,244,67,248,124,
+  139,171,233,59,171,233,15,130,244,247,232,244,74,248,1,199,68,36,20,252,255,
+  252,255,252,255,252,255,129,252,248,239,15,130,244,64,15,134,244,247,129,
+  122,253,20,239,255,15,131,244,64,221,66,16,219,92,36,20,248,1,129,122,253,
+  4,239,15,133,244,64,129,122,253,12,239,15,131,244,64,139,42,137,108,36,12,
+  139,173,233,221,66,8,219,92,36,8,139,76,36,8,139,68,36,20,57,197,15,130,244,
+  251,248,2,133,201,15,142,244,253,248,3,139,108,36,12,41,200,15,140,244,125,
+  141,172,253,13,233,131,192,1,248,4,255,137,68,36,8,137,232,252,233,244,123,
+  248,5,15,140,244,252,141,68,40,1,252,233,244,2,248,6,137,232,252,233,244,
+  2,248,7,15,132,244,254,1,252,233,131,193,1,15,143,244,3,248,8,185,1,0,0,0,
+  252,233,244,3,248,125,49,192,252,233,244,4,248,126,255,139,171,233,59,171,
+  233,15,130,244,247,232,244,74,248,1,129,252,248,239,15,133,244,64,129,122,
+  253,4,239,15,133,244,64,129,122,253,12,239,139,42,15,131,244,64,221,66,8,
+  219,92,36,20,139,68,36,20,133,192,15,142,244,125,131,189,233,1,15,130,244,
+  125,255,15,133,244,127,57,131,233,15,130,244,127,15,182,141,233,139,171,233,
+  137,68,36,8,248,1,136,77,0,131,197,1,131,232,1,15,133,244,1,139,131,233,252,
+  233,244,123,248,128,129,252,248,239,15,130,244,64,139,171,233,59,171,233,
+  15,130,244,247,255,232,244,74,248,1,129,122,253,4,239,15,133,244,64,139,42,
+  139,133,233,133,192,15,132,244,125,57,131,233,15,130,244,129,129,197,239,
+  137,116,36,20,137,68,36,8,139,179,233,248,1,15,182,77,0,131,197,1,131,232,
+  1,136,12,6,15,133,244,1,137,252,240,139,116,36,20,252,233,244,123,248,130,
+  255,129,252,248,239,15,130,244,64,139,171,233,59,171,233,15,130,244,247,232,
+  244,74,248,1,129,122,253,4,239,15,133,244,64,139,42,139,133,233,57,131,233,
+  15,130,244,129,129,197,239,137,116,36,20,137,68,36,8,139,179,233,252,233,
+  244,249,248,1,255,15,182,76,5,0,131,252,249,65,15,130,244,248,131,252,249,
+  90,15,135,244,248,131,252,241,32,248,2,136,12,6,248,3,131,232,1,15,137,244,
+  1,137,252,240,139,116,36,20,252,233,244,123,248,131,129,252,248,239,15,130,
+  244,64,139,171,233,59,171,233,15,130,244,247,232,244,74,248,1,255,129,122,
+  253,4,239,15,133,244,64,139,42,139,133,233,57,131,233,15,130,244,129,129,
+  197,239,137,116,36,20,137,68,36,8,139,179,233,252,233,244,249,248,1,15,182,
+  76,5,0,131,252,249,97,15,130,244,248,131,252,249,122,15,135,244,248,131,252,
+  241,32,248,2,136,12,6,248,3,131,232,1,15,137,244,1,255,137,252,240,139,116,
+  36,20,252,233,244,123,248,132,129,252,248,239,15,130,244,64,129,122,253,4,
+  239,15,133,244,64,137,213,139,10,232,251,1,19,137,252,234,137,4,36,219,4,
+  36,252,233,244,72,248,133,129,252,248,239,15,130,244,64,129,122,253,4,239,
+  15,131,244,64,221,2,199,68,36,16,0,0,192,89,216,68,36,16,221,28,36,248,2,
+  219,4,36,252,233,244,72,248,134,255,129,252,248,239,15,130,244,64,199,68,
+  36,16,0,0,192,89,129,122,253,4,239,15,131,244,64,221,2,216,68,36,16,221,28,
+  36,139,44,36,248,2,137,68,36,20,141,68,194,252,240,248,1,57,208,15,134,244,
+  135,129,120,253,4,239,15,131,244,136,221,0,216,68,36,16,221,28,36,35,44,36,
+  131,232,8,252,233,244,1,248,137,129,252,248,239,15,130,244,64,199,68,36,16,
+  0,0,192,89,129,122,253,4,239,255,15,131,244,64,221,2,216,68,36,16,221,28,
+  36,139,44,36,248,2,137,68,36,20,141,68,194,252,240,248,1,57,208,15,134,244,
+  135,129,120,253,4,239,15,131,244,136,221,0,216,68,36,16,221,28,36,11,44,36,
+  131,232,8,252,233,244,1,248,138,129,252,248,239,15,130,244,64,199,68,36,16,
+  0,0,192,89,129,122,253,4,239,15,131,244,64,221,2,216,68,36,16,221,28,36,139,
+  44,36,248,2,137,68,36,20,141,68,194,252,240,248,1,255,57,208,15,134,244,135,
+  129,120,253,4,239,15,131,244,136,221,0,216,68,36,16,221,28,36,51,44,36,131,
+  232,8,252,233,244,1,248,139,129,252,248,239,15,130,244,64,129,122,253,4,239,
+  15,131,244,64,221,2,199,68,36,16,0,0,192,89,216,68,36,16,221,28,36,139,44,
+  36,248,2,15,205,252,233,244,135,248,140,129,252,248,239,15,130,244,64,255,
+  129,122,253,4,239,15,131,244,64,221,2,199,68,36,16,0,0,192,89,216,68,36,16,
+  221,28,36,139,44,36,248,2,252,247,213,248,135,137,44,36,219,4,36,252,233,
+  244,72,248,136,139,68,36,20,252,233,244,64,248,141,129,252,248,239,15,130,
+  244,64,129,122,253,4,239,15,131,244,64,129,122,253,12,239,15,131,244,64,255,
+  221,2,221,66,8,199,68,36,16,0,0,192,89,216,68,36,16,221,92,36,8,216,68,36,
+  16,221,28,36,139,76,36,8,139,44,36,211,229,252,233,244,135,248,142,129,252,
+  248,239,15,130,244,64,129,122,253,4,239,15,131,244,64,129,122,253,12,239,
+  15,131,244,64,221,2,221,66,8,199,68,36,16,0,0,192,89,216,68,36,16,221,92,
+  36,8,216,68,36,16,221,28,36,139,76,36,8,139,44,36,211,252,237,252,233,244,
+  135,248,143,129,252,248,239,15,130,244,64,129,122,253,4,239,15,131,244,64,
+  255,129,122,253,12,239,15,131,244,64,221,2,221,66,8,199,68,36,16,0,0,192,
+  89,216,68,36,16,221,92,36,8,216,68,36,16,221,28,36,139,76,36,8,139,44,36,
+  211,252,253,252,233,244,135,248,144,129,252,248,239,15,130,244,64,129,122,
+  253,4,239,15,131,244,64,129,122,253,12,239,15,131,244,64,221,2,221,66,8,199,
+  68,36,16,0,0,192,89,216,68,36,16,221,92,36,8,216,68,36,16,221,28,36,139,76,
+  36,8,139,44,36,211,197,252,233,244,135,248,145,129,252,248,239,15,130,244,
+  64,255,129,122,253,4,239,15,131,244,64,129,122,253,12,239,15,131,244,64,221,
+  2,221,66,8,199,68,36,16,0,0,192,89,216,68,36,16,221,92,36,8,216,68,36,16,
+  221,28,36,139,76,36,8,139,44,36,211,205,252,233,244,135,248,127,184,237,252,
+  233,244,64,248,129,184,237,248,64,139,108,36,48,139,114,252,252,137,116,36,
+  24,137,149,233,141,68,194,252,248,141,136,233,137,133,233,139,66,252,248,
+  59,141,233,15,135,244,251,255,137,44,36,252,255,144,233,139,149,233,133,192,
+  15,143,244,77,248,1,139,141,233,41,209,193,252,233,3,133,192,141,65,1,139,
+  106,252,248,15,133,244,34,139,181,233,139,14,15,182,252,233,15,182,205,131,
+  198,4,252,255,36,171,248,34,137,209,252,247,198,237,15,133,244,249,15,182,
+  110,252,253,252,247,213,141,20,252,234,252,233,244,29,248,3,137,252,245,131,
+  229,252,248,41,252,234,252,233,244,29,248,5,186,237,255,137,252,233,232,251,
+  1,0,139,149,233,49,192,252,233,244,1,248,74,93,137,108,36,16,139,108,36,48,
+  137,116,36,24,137,149,233,141,68,194,252,248,137,252,233,137,133,233,232,
+  251,1,20,139,149,233,139,133,233,41,208,193,232,3,131,192,1,139,108,36,16,
+  85,195,248,146,15,182,131,233,168,235,15,133,244,251,168,235,15,133,244,247,
+  168,235,15,132,244,247,252,255,139,233,255,252,233,244,247,248,147,15,182,
+  131,233,168,235,15,133,244,251,252,233,244,247,248,148,15,182,131,233,168,
+  235,15,133,244,251,168,235,15,132,244,251,252,255,139,233,15,132,244,247,
+  255,168,235,15,132,244,251,248,1,139,108,36,48,137,149,233,137,252,242,137,
+  252,233,232,251,1,21,248,3,139,149,233,248,4,15,182,78,252,253,248,5,15,182,
+  110,252,252,15,183,70,252,254,252,255,164,253,171,233,248,149,131,198,4,139,
+  77,232,137,76,36,20,252,233,244,4,248,150,139,106,252,248,139,173,233,15,
+  182,133,233,141,4,194,139,108,36,48,137,149,233,137,133,233,137,252,242,141,
+  139,233,137,171,233,255,137,116,36,24,232,251,1,22,252,233,244,3,248,151,
+  137,116,36,24,252,233,244,247,248,152,137,116,36,24,131,206,1,248,1,141,68,
+  194,252,248,139,108,36,48,137,149,233,137,133,233,137,252,242,137,252,233,
+  232,251,1,23,199,68,36,24,0,0,0,0,131,230,252,254,139,149,233,137,193,139,
+  133,233,41,208,137,205,15,182,78,252,253,193,232,3,131,192,1,252,255,229,
+  248,153,85,141,108,36,12,85,83,82,81,80,15,182,69,252,252,138,101,252,248,
+  137,125,252,252,137,117,252,248,139,93,0,139,139,233,199,131,233,237,137,
+  131,233,137,139,233,129,252,236,239,252,242,15,17,125,216,252,242,15,17,117,
+  208,252,242,15,17,109,200,252,242,15,17,101,192,252,242,15,17,93,184,252,
+  242,15,17,85,176,252,242,15,17,77,168,252,242,15,17,69,160,139,171,233,139,
+  147,233,255,137,171,233,199,131,233,0,0,0,0,137,149,233,141,84,36,16,141,
+  139,233,232,251,1,24,139,141,233,129,225,239,137,204,137,169,233,139,149,
+  233,139,177,233,248,154,133,192,15,136,244,249,137,68,36,20,139,122,252,248,
+  139,191,233,139,191,233,199,131,233,0,0,0,0,199,131,233,237,139,6,15,182,
+  204,15,182,232,131,198,4,193,232,16,129,252,253,239,15,130,244,248,255,139,
+  68,36,20,248,2,252,255,36,171,248,3,252,247,216,137,252,233,137,194,232,251,
+  1,25,248,91,217,124,36,4,137,68,36,8,102,184,0,4,102,11,68,36,4,102,37,252,
+  255,252,247,102,137,68,36,6,217,108,36,6,217,252,252,217,108,36,4,139,68,
+  36,8,195,248,155,102,15,252,239,210,102,15,118,210,102,15,115,210,1,184,0,
+  0,48,67,102,15,110,216,102,15,112,219,81,15,40,200,102,15,84,202,102,15,46,
+  217,15,134,244,247,102,15,85,208,252,242,15,88,203,252,242,15,92,203,102,
+  15,86,202,184,0,0,252,240,63,102,15,110,208,102,15,112,210,81,252,242,15,
+  194,193,1,102,15,84,194,252,242,15,92,200,15,40,193,248,1,195,248,93,217,
+  124,36,4,137,68,36,8,102,184,0,8,102,11,68,36,4,102,37,252,255,252,251,102,
+  137,68,36,6,217,108,36,6,217,252,252,217,108,36,4,139,68,36,8,195,248,156,
+  102,15,252,239,210,102,15,118,210,102,15,115,210,1,184,0,0,48,67,102,15,110,
+  216,102,15,112,219,81,15,40,200,102,15,84,202,102,15,46,217,15,134,244,247,
+  102,15,85,208,252,242,15,88,203,252,242,15,92,203,102,15,86,202,184,0,0,252,
+  240,191,102,15,110,208,102,15,112,210,81,252,242,15,194,193,6,102,15,84,194,
+  252,242,15,92,200,15,40,193,248,1,195,248,114,217,124,36,4,137,68,36,8,102,
+  184,0,12,102,11,68,36,4,102,137,68,36,6,217,108,36,6,217,252,252,217,108,
+  36,4,139,68,36,8,195,248,157,102,15,252,239,210,102,15,118,210,102,15,115,
+  210,1,184,0,0,48,67,102,15,110,216,102,15,112,219,81,15,40,200,102,15,84,
+  202,102,15,46,217,15,134,244,247,102,15,85,208,15,40,193,252,242,15,88,203,
+  252,242,15,92,203,184,0,0,252,240,63,102,15,110,216,102,15,112,219,81,252,
+  242,15,194,193,1,102,15,84,195,252,242,15,92,200,102,15,86,202,15,40,193,
+  248,1,195,248,158,217,193,216,252,241,217,124,36,4,102,184,0,4,102,11,68,
+  36,4,102,37,252,255,252,247,102,137,68,36,6,217,108,36,6,217,252,252,217,
+  108,36,4,222,201,222,252,233,195,248,159,217,232,221,68,36,4,217,252,241,
+  195,248,98,255,217,252,234,222,201,248,160,217,84,36,4,129,124,36,4,0,0,128,
+  127,15,132,244,247,129,124,36,4,0,0,128,252,255,15,132,244,248,248,161,217,
+  192,217,252,252,220,252,233,217,201,217,252,240,217,232,222,193,217,252,253,
+  221,217,248,1,195,248,2,221,216,217,252,238,195,248,117,219,84,36,4,219,68,
+  36,4,223,252,233,15,133,244,254,15,138,244,255,221,216,139,68,36,4,131,252,
+  248,1,15,142,244,252,248,1,169,1,0,0,0,15,133,244,248,216,200,209,232,252,
+  233,244,1,248,2,255,209,232,15,132,244,251,217,192,248,3,216,200,209,232,
+  15,132,244,250,15,131,244,3,220,201,252,233,244,3,248,4,222,201,248,5,195,
+  248,6,15,132,244,5,15,130,244,253,217,232,222,252,241,252,247,216,131,252,
+  248,1,15,132,244,5,252,233,244,1,248,7,255,221,216,217,232,195,248,8,217,
+  84,36,4,217,201,217,84,36,8,139,68,36,4,209,224,61,0,0,0,252,255,15,132,244,
+  248,139,68,36,8,209,224,15,132,244,250,61,0,0,0,252,255,15,132,244,250,217,
+  252,241,252,233,244,161,248,9,217,232,223,252,234,15,132,244,247,217,201,
+  248,1,221,216,195,248,2,217,225,217,232,223,252,233,15,132,244,249,221,216,
+  217,225,217,252,238,184,0,0,0,0,15,146,208,209,200,51,68,36,4,15,137,244,
+  249,217,201,248,3,221,217,217,225,195,248,4,255,131,124,36,4,0,15,141,244,
+  3,221,216,221,216,133,192,15,132,244,251,217,252,238,195,248,5,199,68,36,
+  4,0,0,128,127,217,68,36,4,195,248,162,252,242,15,45,193,252,242,15,42,208,
+  102,15,46,202,15,133,244,254,15,138,244,255,248,163,131,252,248,1,15,142,
+  244,252,248,1,169,1,0,0,0,15,133,244,248,252,242,15,89,192,209,232,252,233,
+  244,1,248,2,209,232,15,132,244,251,255,15,40,200,248,3,252,242,15,89,192,
+  209,232,15,132,244,250,15,131,244,3,252,242,15,89,200,252,233,244,3,248,4,
+  252,242,15,89,193,248,5,195,248,6,15,132,244,5,15,130,244,253,252,247,216,
+  232,244,1,184,0,0,252,240,63,102,15,110,200,102,15,112,201,81,252,242,15,
+  94,200,15,40,193,195,248,7,184,0,0,252,240,63,102,15,110,192,102,15,112,192,
+  81,195,248,8,252,242,15,17,76,36,12,252,242,15,17,68,36,4,131,124,36,12,0,
+  15,133,244,247,255,139,68,36,16,209,224,61,0,0,224,252,255,15,132,244,248,
+  248,1,131,124,36,4,0,15,133,244,247,139,68,36,8,209,224,15,132,244,250,61,
+  0,0,224,252,255,15,132,244,251,248,1,221,68,36,12,221,68,36,4,217,252,241,
+  217,192,217,252,252,220,252,233,217,201,217,252,240,217,232,222,193,217,252,
+  253,221,217,221,92,36,4,252,242,15,16,68,36,4,195,248,9,184,0,0,252,240,63,
+  102,15,110,208,102,15,112,210,81,102,15,46,194,15,132,244,247,15,40,193,248,
+  1,195,248,2,102,15,252,239,210,102,15,118,210,102,15,115,210,1,102,15,84,
+  194,184,0,0,252,240,63,102,15,110,208,102,15,112,210,81,102,15,46,194,15,
+  132,244,1,102,15,80,193,15,87,192,136,196,15,146,208,48,224,15,133,244,1,
+  248,3,255,184,0,0,252,240,127,102,15,110,192,102,15,112,192,81,195,248,4,
+  102,15,80,193,133,192,15,133,244,3,15,87,192,195,248,5,102,15,80,193,133,
+  192,15,132,244,3,15,87,192,195,248,164,139,68,36,12,221,68,36,4,131,252,248,
+  1,15,130,244,91,15,132,244,93,131,252,248,3,15,130,244,114,15,135,244,248,
+  217,252,250,195,248,2,131,252,248,5,15,130,244,98,15,132,244,160,255,131,
+  252,248,7,15,132,244,247,15,135,244,248,217,252,237,217,201,217,252,241,195,
+  248,1,217,232,217,201,217,252,241,195,248,2,131,252,248,9,15,132,244,247,
+  15,135,244,248,217,252,236,217,201,217,252,241,195,248,1,217,252,254,195,
+  248,2,131,252,248,11,15,132,244,247,15,135,244,255,217,252,255,195,248,1,
+  217,252,242,221,216,195,248,9,204,248,165,139,68,36,20,221,68,36,4,221,68,
+  36,12,131,252,248,1,15,132,244,247,255,15,135,244,248,222,193,195,248,1,222,
+  252,233,195,248,2,131,252,248,3,15,132,244,247,15,135,244,248,222,201,195,
+  248,1,222,252,249,195,248,2,131,252,248,5,15,130,244,158,15,132,244,117,131,
+  252,248,7,15,132,244,247,15,135,244,248,221,216,217,224,195,248,1,221,216,
+  217,225,195,248,2,255,131,252,248,9,15,132,244,247,15,135,244,248,217,252,
+  243,195,248,1,217,201,217,252,253,221,217,195,248,2,131,252,248,11,15,132,
+  244,247,15,135,244,255,219,252,233,219,209,221,217,195,248,1,219,252,233,
+  218,209,221,217,195,248,9,204,248,166,156,90,137,209,129,252,242,0,0,32,0,
+  82,157,156,90,49,192,57,209,15,132,244,247,139,68,36,4,87,83,15,162,139,124,
+  36,16,137,7,137,95,4,137,79,8,137,87,12,91,95,248,1,195,248,167,255,204,255,
+  204,248,168,131,252,236,16,87,86,83,131,252,236,28,141,157,233,139,181,233,
+  15,183,192,137,134,233,141,132,253,36,233,137,142,233,137,150,233,137,134,
+  233,139,140,253,36,233,139,148,253,36,233,137,76,36,44,137,84,36,40,137,226,
+  137,116,36,24,137,252,241,232,251,1,26,199,131,233,237,139,144,233,139,128,
+  233,41,208,139,106,252,248,193,232,3,131,192,1,139,181,233,139,14,15,182,
+  252,233,15,182,205,131,198,4,252,255,36,171,248,33,139,76,36,48,139,179,233,
+  137,142,233,137,145,233,137,169,233,255,137,252,241,137,194,232,251,1,27,
+  139,108,36,48,139,134,233,139,150,233,131,190,233,1,15,130,244,253,15,132,
+  244,252,221,134,233,252,233,244,253,248,6,217,134,233,248,7,139,141,233,15,
+  183,73,6,137,76,36,48,131,196,28,91,94,95,93,89,3,36,36,131,196,16,81,195,
+  248,169,85,137,229,83,137,203,43,163,233,137,163,233,15,182,139,233,131,252,
+  233,1,15,136,244,248,248,1,255,139,132,253,139,233,137,4,140,131,252,233,
+  1,15,137,244,1,248,2,139,139,233,139,147,233,252,255,147,233,137,131,233,
+  137,147,233,128,187,233,1,15,130,244,253,15,132,244,252,221,155,233,252,233,
+  244,253,248,6,217,155,233,248,7,255,41,163,233,139,93,252,252,201,195,255,
+  129,124,253,202,4,239,15,131,244,45,129,124,253,194,4,239,15,131,244,45,248,
+  1,221,4,202,248,2,221,4,194,248,3,131,198,4,223,252,233,221,216,255,15,134,
+  244,247,255,15,135,244,247,255,15,131,244,247,255,15,183,70,252,254,141,180,
+  253,134,233,248,1,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,
+  36,171,255,139,108,194,4,131,198,4,255,129,252,253,239,15,131,244,251,129,
+  124,253,202,4,239,15,131,244,251,248,1,221,4,202,248,2,221,4,194,248,4,223,
+  252,233,221,216,255,15,138,244,248,15,133,244,248,255,15,138,244,248,15,132,
+  244,247,255,248,1,15,183,70,252,254,141,180,253,134,233,248,2,255,248,2,15,
+  183,70,252,254,141,180,253,134,233,248,1,255,252,233,244,9,255,248,5,129,
+  252,253,239,15,132,244,50,129,124,253,202,4,239,15,132,244,50,57,108,202,
+  4,15,133,244,2,129,252,253,239,15,131,244,1,139,12,202,139,4,194,57,193,15,
+  132,244,1,129,252,253,239,15,135,244,2,139,169,233,133,252,237,15,132,244,
+  2,255,252,246,133,233,235,15,133,244,2,255,49,252,237,255,189,1,0,0,0,255,
+  252,233,244,49,255,248,3,129,252,253,239,255,15,133,244,9,255,252,233,244,
+  50,255,252,247,208,139,108,202,4,131,198,4,129,252,253,239,15,133,244,249,
+  139,12,202,59,12,135,255,139,108,202,4,131,198,4,255,129,252,253,239,15,131,
+  244,249,248,1,221,4,199,248,2,221,4,202,248,4,223,252,233,221,216,255,252,
+  247,208,139,108,202,4,131,198,4,57,197,255,15,133,244,249,15,183,70,252,254,
+  141,180,253,134,233,248,2,139,6,15,182,204,15,182,232,131,198,4,193,232,16,
+  252,255,36,171,248,3,129,252,253,239,15,133,244,2,252,233,244,50,255,15,132,
+  244,248,129,252,253,239,15,132,244,50,15,183,70,252,254,141,180,253,134,233,
+  248,2,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,255,
+  139,108,194,4,131,198,4,129,252,253,239,255,137,108,202,4,139,44,194,137,
+  44,202,255,139,108,194,4,139,4,194,137,108,202,4,137,4,202,139,6,15,182,204,
+  15,182,232,131,198,4,193,232,16,252,255,36,171,255,49,252,237,129,124,253,
+  194,4,239,129,213,239,137,108,202,4,139,6,15,182,204,15,182,232,131,198,4,
+  193,232,16,252,255,36,171,255,129,124,253,194,4,239,15,131,244,55,221,4,194,
+  217,224,221,28,202,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,
+  36,171,255,129,124,253,194,4,239,15,133,244,248,139,4,194,219,128,233,248,
+  1,221,28,202,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,
+  171,248,2,129,124,253,194,4,239,15,133,244,58,139,12,194,255,139,169,233,
+  131,252,253,0,15,133,244,255,248,3,255,248,59,137,213,232,251,1,19,137,4,
+  36,219,4,36,137,252,234,15,182,78,252,253,252,233,244,1,255,248,9,252,246,
+  133,233,235,15,133,244,3,252,233,244,58,255,15,182,252,236,15,182,192,255,
+  129,124,253,252,234,4,239,15,131,244,52,221,4,252,234,220,4,199,255,129,124,
+  253,252,234,4,239,15,131,244,54,221,4,199,220,4,252,234,255,129,124,253,252,
+  234,4,239,15,131,244,57,129,124,253,194,4,239,15,131,244,57,221,4,252,234,
+  220,4,194,255,129,124,253,252,234,4,239,15,131,244,52,221,4,252,234,220,36,
+  199,255,129,124,253,252,234,4,239,15,131,244,54,221,4,199,220,36,252,234,
+  255,129,124,253,252,234,4,239,15,131,244,57,129,124,253,194,4,239,15,131,
+  244,57,221,4,252,234,220,36,194,255,129,124,253,252,234,4,239,15,131,244,
+  52,221,4,252,234,220,12,199,255,129,124,253,252,234,4,239,15,131,244,54,221,
+  4,199,220,12,252,234,255,129,124,253,252,234,4,239,15,131,244,57,129,124,
+  253,194,4,239,15,131,244,57,221,4,252,234,220,12,194,255,129,124,253,252,
+  234,4,239,15,131,244,52,221,4,252,234,220,52,199,255,129,124,253,252,234,
+  4,239,15,131,244,54,221,4,199,220,52,252,234,255,129,124,253,252,234,4,239,
+  15,131,244,57,129,124,253,194,4,239,15,131,244,57,221,4,252,234,220,52,194,
+  255,129,124,253,252,234,4,239,15,131,244,52,221,4,252,234,221,4,199,255,129,
+  124,253,252,234,4,239,15,131,244,54,221,4,199,221,4,252,234,255,129,124,253,
+  252,234,4,239,15,131,244,57,129,124,253,194,4,239,15,131,244,57,221,4,252,
+  234,221,4,194,255,248,170,232,244,158,221,28,202,139,6,15,182,204,15,182,
+  232,131,198,4,193,232,16,252,255,36,171,255,252,233,244,170,255,232,244,117,
+  221,28,202,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,
+  255,15,182,252,236,15,182,192,141,12,194,41,232,137,76,36,4,137,68,36,8,248,
+  37,139,108,36,48,137,44,36,137,149,233,137,116,36,24,232,251,1,28,139,149,
+  233,133,192,15,133,244,46,15,182,110,252,255,15,182,78,252,253,139,68,252,
+  234,4,139,44,252,234,137,68,202,4,137,44,202,139,6,15,182,204,15,182,232,
+  131,198,4,193,232,16,252,255,36,171,255,252,247,208,139,4,135,199,68,202,
+  4,237,137,4,202,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,
+  36,171,255,223,70,252,254,221,28,202,139,6,15,182,204,15,182,232,131,198,
+  4,193,232,16,252,255,36,171,255,221,4,199,221,28,202,139,6,15,182,204,15,
+  182,232,131,198,4,193,232,16,252,255,36,171,255,252,247,208,137,68,202,4,
+  139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,255,141,76,
+  202,12,141,68,194,4,189,237,137,105,252,248,248,1,137,41,131,193,8,57,193,
+  15,134,244,1,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,
+  171,255,139,106,252,248,139,172,253,133,233,139,173,233,139,69,4,139,109,
+  0,137,68,202,4,137,44,202,139,6,15,182,204,15,182,232,131,198,4,193,232,16,
+  252,255,36,171,255,139,106,252,248,139,172,253,141,233,128,189,233,0,139,
+  173,233,139,12,194,139,68,194,4,137,77,0,137,69,4,15,132,244,247,252,246,
+  133,233,235,15,133,244,248,248,1,139,6,15,182,204,15,182,232,131,198,4,193,
+  232,16,252,255,36,171,248,2,129,232,239,129,252,248,239,15,134,244,1,252,
+  246,129,233,235,15,132,244,1,135,213,141,139,233,255,232,251,1,29,137,252,
+  234,252,233,244,1,255,252,247,208,139,106,252,248,139,172,253,141,233,139,
+  12,135,139,133,233,137,8,199,64,4,237,252,246,133,233,235,15,133,244,248,
+  248,1,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,248,
+  2,252,246,129,233,235,15,132,244,1,128,189,233,0,15,132,244,1,137,213,137,
+  194,141,139,233,232,251,1,29,137,252,234,252,233,244,1,255,139,106,252,248,
+  221,4,199,139,172,253,141,233,139,141,233,221,25,139,6,15,182,204,15,182,
+  232,131,198,4,193,232,16,252,255,36,171,255,252,247,208,139,106,252,248,139,
+  172,253,141,233,139,141,233,137,65,4,139,6,15,182,204,15,182,232,131,198,
+  4,193,232,16,252,255,36,171,255,141,180,253,134,233,139,108,36,48,131,189,
+  233,0,15,132,244,247,137,149,233,141,20,202,137,252,233,232,251,1,30,139,
+  149,233,248,1,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,
+  171,255,252,247,208,139,74,252,248,139,4,135,139,108,36,48,137,76,36,8,137,
+  68,36,4,137,44,36,137,149,233,137,116,36,24,232,251,1,31,139,149,233,15,182,
+  78,252,253,137,4,202,199,68,202,4,237,139,6,15,182,204,15,182,232,131,198,
+  4,193,232,16,252,255,36,171,255,139,108,36,48,137,149,233,139,139,233,59,
+  139,233,137,116,36,24,15,131,244,251,248,1,137,193,37,252,255,7,0,0,193,252,
+  233,11,137,76,36,8,61,252,255,7,0,0,15,132,244,249,248,2,137,44,36,137,68,
+  36,4,232,251,1,32,139,149,233,15,182,78,252,253,137,4,202,199,68,202,4,237,
+  139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,248,3,184,
+  1,8,0,0,252,233,244,2,248,5,137,252,233,232,251,1,33,15,183,70,252,254,252,
+  233,244,1,255,252,247,208,139,108,36,48,139,139,233,137,116,36,24,59,139,
+  233,137,149,233,15,131,244,249,248,2,139,20,135,137,252,233,232,251,1,34,
+  139,149,233,15,182,78,252,253,137,4,202,199,68,202,4,237,139,6,15,182,204,
+  15,182,232,131,198,4,193,232,16,252,255,36,171,248,3,137,252,233,232,251,
+  1,33,15,183,70,252,254,252,247,208,252,233,244,2,255,252,247,208,139,106,
+  252,248,139,173,233,139,4,135,252,233,244,171,255,252,247,208,139,106,252,
+  248,139,173,233,139,4,135,252,233,244,172,255,15,182,252,236,15,182,192,129,
+  124,253,252,234,4,239,15,133,244,40,139,44,252,234,129,124,253,194,4,239,
+  15,131,244,251,221,4,194,219,20,36,219,4,36,223,252,233,221,216,139,4,36,
+  15,133,244,40,59,133,233,15,131,244,40,193,224,3,3,133,233,129,120,253,4,
+  239,15,132,244,248,139,40,139,64,4,137,44,202,137,68,202,4,248,1,139,6,15,
+  182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,248,2,131,189,233,
+  0,15,132,244,249,255,139,141,233,252,246,129,233,235,15,132,244,40,15,182,
+  78,252,253,248,3,199,68,202,4,237,252,233,244,1,248,5,129,124,253,194,4,239,
+  15,133,244,40,139,4,194,252,233,244,171,255,15,182,252,236,15,182,192,252,
+  247,208,139,4,135,129,124,253,252,234,4,239,15,133,244,38,139,44,252,234,
+  248,171,139,141,233,35,136,233,105,201,239,3,141,233,248,1,129,185,233,239,
+  15,133,244,250,57,129,233,15,133,244,250,129,121,253,4,239,15,132,244,251,
+  15,182,70,252,253,139,41,139,73,4,137,44,194,137,76,194,4,248,2,255,139,6,
+  15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,248,3,15,182,70,
+  252,253,199,68,194,4,237,252,233,244,2,248,4,139,137,233,133,201,15,133,244,
+  1,248,5,139,141,233,133,201,15,132,244,3,252,246,129,233,235,15,133,244,3,
+  252,233,244,38,255,15,182,252,236,15,182,192,129,124,253,252,234,4,239,15,
+  133,244,39,139,44,252,234,59,133,233,15,131,244,39,193,224,3,3,133,233,129,
+  120,253,4,239,15,132,244,248,139,40,139,64,4,137,44,202,137,68,202,4,248,
+  1,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,248,2,131,
+  189,233,0,15,132,244,249,139,141,233,252,246,129,233,235,15,132,244,39,255,
+  15,182,78,252,253,248,3,199,68,202,4,237,252,233,244,1,255,15,182,252,236,
+  15,182,192,129,124,253,252,234,4,239,15,133,244,43,139,44,252,234,129,124,
+  253,194,4,239,15,131,244,251,221,4,194,219,20,36,219,4,36,223,252,233,221,
+  216,139,4,36,15,133,244,43,59,133,233,15,131,244,43,193,224,3,3,133,233,129,
+  120,253,4,239,15,132,244,249,248,1,252,246,133,233,235,15,133,244,253,248,
+  2,255,139,108,202,4,139,12,202,137,104,4,137,8,139,6,15,182,204,15,182,232,
+  131,198,4,193,232,16,252,255,36,171,248,3,131,189,233,0,15,132,244,1,139,
+  141,233,252,246,129,233,235,15,132,244,43,15,182,78,252,253,252,233,244,1,
+  248,5,129,124,253,194,4,239,15,133,244,43,139,4,194,252,233,244,172,248,7,
+  128,165,233,235,255,139,139,233,137,171,233,137,141,233,15,182,78,252,253,
+  252,233,244,2,255,15,182,252,236,15,182,192,252,247,208,139,4,135,129,124,
+  253,252,234,4,239,15,133,244,41,139,44,252,234,248,172,139,141,233,35,136,
+  233,105,201,239,198,133,233,0,3,141,233,248,1,129,185,233,239,15,133,244,
+  251,57,129,233,15,133,244,251,129,121,253,4,239,15,132,244,250,248,2,255,
+  252,246,133,233,235,15,133,244,253,248,3,15,182,70,252,253,139,108,194,4,
+  139,4,194,137,105,4,137,1,139,6,15,182,204,15,182,232,131,198,4,193,232,16,
+  252,255,36,171,248,4,131,189,233,0,15,132,244,2,137,76,36,16,139,141,233,
+  252,246,129,233,235,15,132,244,41,139,76,36,16,252,233,244,2,248,5,139,137,
+  233,133,201,15,133,244,1,255,139,141,233,133,201,15,132,244,252,252,246,129,
+  233,235,15,132,244,41,248,6,137,68,36,16,199,68,36,20,237,137,108,36,12,141,
+  68,36,16,137,108,36,4,139,108,36,48,137,68,36,8,137,44,36,137,149,233,137,
+  116,36,24,232,251,1,35,139,149,233,139,108,36,12,137,193,252,233,244,2,248,
+  7,128,165,233,235,139,131,233,137,171,233,137,133,233,252,233,244,3,255,15,
+  182,252,236,15,182,192,129,124,253,252,234,4,239,15,133,244,42,139,44,252,
+  234,59,133,233,15,131,244,42,193,224,3,3,133,233,129,120,253,4,239,15,132,
+  244,249,248,1,252,246,133,233,235,15,133,244,253,248,2,139,108,202,4,139,
+  12,202,137,104,4,137,8,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,
+  255,36,171,248,3,131,189,233,0,15,132,244,1,255,139,141,233,252,246,129,233,
+  235,15,132,244,42,15,182,78,252,253,252,233,244,1,248,7,128,165,233,235,139,
+  139,233,137,171,233,137,141,233,15,182,78,252,253,252,233,244,2,255,137,124,
+  36,16,139,60,199,248,1,141,12,202,139,105,252,248,252,246,133,233,235,15,
+  133,244,253,248,2,139,68,36,20,131,232,1,15,132,244,250,1,252,248,59,133,
+  233,15,135,244,251,41,252,248,193,231,3,3,189,233,248,3,139,41,137,47,139,
+  105,4,131,193,8,137,111,4,131,199,8,131,232,1,15,133,244,3,248,4,139,124,
+  36,16,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,248,
+  5,137,108,36,4,139,108,36,48,137,149,233,137,68,36,8,137,44,36,137,116,36,
+  24,232,251,1,36,139,149,233,15,182,78,252,253,252,233,244,1,248,7,255,128,
+  165,233,235,139,131,233,137,171,233,137,133,233,252,233,244,2,255,3,68,36,
+  20,255,129,124,253,202,4,239,139,44,202,15,133,244,60,141,84,202,8,137,114,
+  252,252,139,181,233,139,14,15,182,252,233,15,182,205,131,198,4,252,255,36,
+  171,255,141,76,202,8,137,215,139,105,252,248,129,121,253,252,252,239,15,133,
+  244,30,248,61,139,114,252,252,252,247,198,237,15,133,244,253,248,1,137,106,
+  252,248,137,68,36,20,131,232,1,15,132,244,249,248,2,139,41,137,47,139,105,
+  4,131,193,8,137,111,4,131,199,8,131,232,1,15,133,244,2,139,106,252,248,248,
+  3,139,68,36,20,128,189,233,1,15,135,244,251,248,4,139,181,233,139,14,15,182,
+  252,233,15,182,205,131,198,4,252,255,36,171,248,5,255,252,247,198,237,15,
+  133,244,4,15,182,78,252,253,252,247,209,141,12,202,139,121,252,248,139,191,
+  233,139,191,233,252,233,244,4,248,7,129,252,238,239,252,247,198,237,15,133,
+  244,254,41,252,242,137,215,139,114,252,252,252,233,244,1,248,8,129,198,239,
+  252,233,244,1,255,141,76,202,8,139,105,232,139,65,252,236,137,41,137,65,4,
+  139,105,252,240,139,65,252,244,137,105,8,137,65,12,139,105,224,139,65,228,
+  137,105,252,248,137,65,252,252,129,252,248,239,184,237,15,133,244,30,137,
+  202,137,114,252,252,139,181,233,139,14,15,182,252,233,15,182,205,131,198,
+  4,252,255,36,171,255,137,124,36,16,137,92,36,20,139,108,202,252,240,139,68,
+  202,252,248,139,157,233,131,198,4,139,189,233,248,1,57,216,15,131,244,251,
+  129,124,253,199,4,239,15,132,244,250,219,68,202,252,248,139,108,199,4,137,
+  108,202,12,139,44,199,137,108,202,8,131,192,1,221,28,202,137,68,202,252,248,
+  248,2,15,183,70,252,254,141,180,253,134,233,248,3,139,92,36,20,139,124,36,
+  16,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,248,4,
+  131,192,1,137,68,202,252,248,252,233,244,1,248,5,41,216,248,6,59,133,233,
+  15,135,244,3,105,252,248,239,255,3,189,233,129,191,233,239,15,132,244,253,
+  141,92,24,1,139,175,233,139,135,233,137,44,202,137,68,202,4,139,175,233,139,
+  135,233,137,108,202,8,137,68,202,12,137,92,202,252,248,252,233,244,2,248,
+  7,131,192,1,252,233,244,6,255,129,124,253,202,252,236,239,15,133,244,251,
+  139,108,202,232,129,124,253,202,252,244,239,15,133,244,251,129,124,253,202,
+  252,252,239,15,133,244,251,128,189,233,235,15,133,244,251,141,180,253,134,
+  233,199,68,202,252,248,0,0,0,0,199,68,202,252,252,252,255,127,252,254,252,
+  255,248,1,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,
+  248,5,198,70,252,252,235,141,180,253,134,233,198,6,235,252,233,244,1,255,
+  15,182,252,236,15,182,192,137,124,36,16,141,188,253,194,233,141,12,202,43,
+  122,252,252,133,252,237,15,132,244,251,141,108,252,233,252,248,57,215,15,
+  131,244,248,248,1,139,71,252,248,137,1,139,71,252,252,131,199,8,137,65,4,
+  131,193,8,57,252,233,15,131,244,249,57,215,15,130,244,1,248,2,199,65,4,237,
+  131,193,8,57,252,233,15,130,244,2,248,3,139,124,36,16,139,6,15,182,204,15,
+  182,232,131,198,4,193,232,16,252,255,36,171,248,5,199,68,36,20,1,0,0,0,137,
+  208,41,252,248,15,134,244,3,137,197,193,252,237,3,131,197,1,137,108,36,20,
+  139,108,36,48,1,200,59,133,233,15,135,244,253,248,6,255,139,71,252,248,137,
+  1,139,71,252,252,131,199,8,137,65,4,131,193,8,57,215,15,130,244,6,252,233,
+  244,3,248,7,137,149,233,137,141,233,137,116,36,24,41,215,139,84,36,20,131,
+  252,234,1,137,252,233,232,251,1,0,139,149,233,139,141,233,1,215,252,233,244,
+  6,255,193,225,3,255,248,1,139,114,252,252,137,68,36,20,252,247,198,237,15,
+  133,244,253,255,248,14,137,215,131,232,1,15,132,244,249,248,2,139,44,15,137,
+  111,252,248,139,108,15,4,137,111,252,252,131,199,8,131,232,1,15,133,244,2,
+  248,3,139,68,36,20,15,182,110,252,255,248,5,57,197,15,135,244,252,255,139,
+  108,10,4,137,106,252,252,139,44,10,137,106,252,248,255,248,5,56,70,252,255,
+  15,135,244,252,255,15,182,78,252,253,252,247,209,141,20,202,139,122,252,248,
+  139,191,233,139,191,233,139,6,15,182,204,15,182,232,131,198,4,193,232,16,
+  252,255,36,171,248,6,255,199,71,252,252,237,131,199,8,255,199,68,194,252,
+  244,237,255,131,192,1,252,233,244,5,248,7,141,174,233,252,247,197,237,15,
+  133,244,15,41,252,234,255,1,252,233,255,137,252,245,209,252,237,129,229,239,
+  102,129,172,253,43,233,238,15,130,244,150,255,141,12,202,255,129,121,253,
+  4,239,15,133,244,255,255,129,121,253,12,239,15,133,244,62,129,121,253,20,
+  239,15,133,244,62,139,41,131,121,16,0,15,140,244,251,255,129,121,253,12,239,
+  15,133,244,167,129,121,253,20,239,15,133,244,167,255,139,105,16,133,252,237,
+  15,136,244,251,3,41,15,128,244,247,137,41,255,59,105,8,199,65,28,237,137,
+  105,24,255,15,142,244,253,248,1,248,6,141,180,253,134,233,255,141,180,253,
+  134,233,15,183,70,252,254,15,142,245,248,1,248,6,255,15,143,244,253,248,6,
+  141,180,253,134,233,248,1,255,248,7,139,6,15,182,204,15,182,232,131,198,4,
+  193,232,16,252,255,36,171,248,5,255,3,41,15,128,244,1,137,41,255,15,141,244,
+  7,255,141,180,253,134,233,15,183,70,252,254,15,141,245,255,15,140,244,7,255,
+  252,233,244,6,248,9,255,129,121,253,4,239,255,15,131,244,62,129,121,253,12,
+  239,15,131,244,62,255,129,121,253,12,239,15,131,244,167,129,121,253,20,239,
+  15,131,244,167,255,139,105,20,255,129,252,253,239,15,131,244,62,255,221,65,
+  8,221,1,255,220,65,16,221,17,221,81,24,133,252,237,15,136,244,247,255,221,
+  81,24,15,140,244,247,255,217,201,248,1,223,252,233,221,216,255,15,131,244,
+  248,141,180,253,134,233,255,141,180,253,134,233,15,183,70,252,254,15,131,
+  245,255,15,130,244,248,141,180,253,134,233,255,141,12,202,139,105,4,129,252,
+  253,239,15,132,244,247,255,137,105,252,252,139,41,137,105,252,248,252,233,
+  245,255,141,180,253,134,233,139,1,137,105,252,252,137,65,252,248,255,139,
+  139,233,139,4,129,139,128,233,139,108,36,48,137,147,233,137,171,233,252,255,
+  224,255,141,180,253,134,233,139,6,15,182,204,15,182,232,131,198,4,193,232,
+  16,252,255,36,171,255,137,252,245,209,252,237,129,229,239,102,129,172,253,
+  43,233,238,15,130,244,152,255,139,190,233,139,108,36,48,141,12,202,59,141,
+  233,15,135,244,25,15,182,142,233,57,200,15,134,244,249,248,2,255,15,183,70,
+  252,254,252,233,245,255,248,3,199,68,194,252,252,237,131,192,1,57,200,15,
+  134,244,3,252,233,244,2,255,141,44,197,237,141,4,194,139,122,252,248,137,
+  104,252,252,137,120,252,248,139,108,36,48,141,12,200,59,141,233,15,135,244,
+  24,137,209,137,194,15,182,174,233,133,252,237,15,132,244,248,248,1,131,193,
+  8,57,209,15,131,244,249,139,121,252,248,137,56,139,121,252,252,137,120,4,
+  131,192,8,199,65,252,252,237,131,252,237,1,15,133,244,1,248,2,255,139,190,
+  233,139,6,15,182,204,15,182,232,131,198,4,193,232,16,252,255,36,171,255,248,
+  3,199,64,4,237,131,192,8,131,252,237,1,15,133,244,3,252,233,244,2,255,139,
+  106,252,248,139,189,233,139,108,36,48,141,68,194,252,248,137,149,233,141,
+  136,233,59,141,233,137,133,233,255,137,44,36,255,137,124,36,4,137,44,36,255,
+  15,135,244,23,199,131,233,237,255,252,255,215,255,252,255,147,233,255,199,
+  131,233,237,139,149,233,141,12,194,252,247,217,3,141,233,139,114,252,252,
+  252,233,244,12,255,254,0
+};
+
+enum {
+  GLOB_vm_returnp,
+  GLOB_cont_dispatch,
+  GLOB_vm_returnc,
+  GLOB_vm_unwind_yield,
+  GLOB_BC_RET_Z,
+  GLOB_vm_return,
+  GLOB_vm_leave_cp,
+  GLOB_vm_leave_unw,
+  GLOB_vm_unwind_c_eh,
+  GLOB_vm_unwind_c,
+  GLOB_vm_unwind_rethrow,
+  GLOB_vm_unwind_ff,
+  GLOB_vm_unwind_ff_eh,
+  GLOB_vm_growstack_c,
+  GLOB_vm_growstack_v,
+  GLOB_vm_growstack_f,
+  GLOB_vm_resume,
+  GLOB_vm_pcall,
+  GLOB_vm_call,
+  GLOB_vm_call_dispatch,
+  GLOB_vmeta_call,
+  GLOB_vm_call_dispatch_f,
+  GLOB_vm_cpcall,
+  GLOB_cont_ffi_callback,
+  GLOB_vm_call_tail,
+  GLOB_cont_cat,
+  GLOB_cont_ra,
+  GLOB_BC_CAT_Z,
+  GLOB_vmeta_tgets,
+  GLOB_vmeta_tgetb,
+  GLOB_vmeta_tgetv,
+  GLOB_vmeta_tsets,
+  GLOB_vmeta_tsetb,
+  GLOB_vmeta_tsetv,
+  GLOB_cont_nop,
+  GLOB_vmeta_comp,
+  GLOB_vmeta_binop,
+  GLOB_cont_condt,
+  GLOB_cont_condf,
+  GLOB_vmeta_equal,
+  GLOB_vmeta_equal_cd,
+  GLOB_vmeta_arith_vno,
+  GLOB_vmeta_arith_vn,
+  GLOB_vmeta_arith_nvo,
+  GLOB_vmeta_arith_nv,
+  GLOB_vmeta_unm,
+  GLOB_vmeta_arith_vvo,
+  GLOB_vmeta_arith_vv,
+  GLOB_vmeta_len,
+  GLOB_BC_LEN_Z,
+  GLOB_vmeta_call_ra,
+  GLOB_BC_CALLT_Z,
+  GLOB_vmeta_for,
+  GLOB_ff_assert,
+  GLOB_fff_fallback,
+  GLOB_fff_res_,
+  GLOB_ff_type,
+  GLOB_fff_res1,
+  GLOB_ff_getmetatable,
+  GLOB_ff_setmetatable,
+  GLOB_ff_rawget,
+  GLOB_ff_tonumber,
+  GLOB_fff_resn,
+  GLOB_ff_tostring,
+  GLOB_fff_gcstep,
+  GLOB_ff_next,
+  GLOB_fff_res2,
+  GLOB_fff_res,
+  GLOB_ff_pairs,
+  GLOB_ff_ipairs_aux,
+  GLOB_fff_res0,
+  GLOB_ff_ipairs,
+  GLOB_ff_pcall,
+  GLOB_ff_xpcall,
+  GLOB_ff_coroutine_resume,
+  GLOB_ff_coroutine_wrap_aux,
+  GLOB_ff_coroutine_yield,
+  GLOB_fff_resi,
+  GLOB_ff_math_abs,
+  GLOB_fff_resxmm0,
+  GLOB_ff_math_floor,
+  GLOB_vm_floor,
+  GLOB_ff_math_ceil,
+  GLOB_vm_ceil,
+  GLOB_ff_math_sqrt,
+  GLOB_ff_math_log,
+  GLOB_ff_math_log10,
+  GLOB_ff_math_exp,
+  GLOB_vm_exp_x87,
+  GLOB_ff_math_sin,
+  GLOB_ff_math_cos,
+  GLOB_ff_math_tan,
+  GLOB_ff_math_asin,
+  GLOB_ff_math_acos,
+  GLOB_ff_math_atan,
+  GLOB_ff_math_sinh,
+  GLOB_ff_math_cosh,
+  GLOB_ff_math_tanh,
+  GLOB_ff_math_deg,
+  GLOB_ff_math_rad,
+  GLOB_ff_math_atan2,
+  GLOB_ff_math_ldexp,
+  GLOB_ff_math_frexp,
+  GLOB_ff_math_modf,
+  GLOB_vm_trunc,
+  GLOB_ff_math_fmod,
+  GLOB_ff_math_pow,
+  GLOB_vm_pow,
+  GLOB_ff_math_min,
+  GLOB_ff_math_max,
+  GLOB_ff_string_len,
+  GLOB_ff_string_byte,
+  GLOB_ff_string_char,
+  GLOB_fff_newstr,
+  GLOB_ff_string_sub,
+  GLOB_fff_emptystr,
+  GLOB_ff_string_rep,
+  GLOB_fff_fallback_2,
+  GLOB_ff_string_reverse,
+  GLOB_fff_fallback_1,
+  GLOB_ff_string_lower,
+  GLOB_ff_string_upper,
+  GLOB_ff_table_getn,
+  GLOB_ff_bit_tobit,
+  GLOB_ff_bit_band,
+  GLOB_fff_resbit,
+  GLOB_fff_fallback_bit_op,
+  GLOB_ff_bit_bor,
+  GLOB_ff_bit_bxor,
+  GLOB_ff_bit_bswap,
+  GLOB_ff_bit_bnot,
+  GLOB_ff_bit_lshift,
+  GLOB_ff_bit_rshift,
+  GLOB_ff_bit_arshift,
+  GLOB_ff_bit_rol,
+  GLOB_ff_bit_ror,
+  GLOB_vm_record,
+  GLOB_vm_rethook,
+  GLOB_vm_inshook,
+  GLOB_cont_hook,
+  GLOB_vm_hotloop,
+  GLOB_vm_callhook,
+  GLOB_vm_hotcall,
+  GLOB_vm_exit_handler,
+  GLOB_vm_exit_interp,
+  GLOB_vm_floor_sse,
+  GLOB_vm_ceil_sse,
+  GLOB_vm_trunc_sse,
+  GLOB_vm_mod,
+  GLOB_vm_log2,
+  GLOB_vm_exp2_x87,
+  GLOB_vm_exp2raw,
+  GLOB_vm_pow_sse,
+  GLOB_vm_powi_sse,
+  GLOB_vm_foldfpm,
+  GLOB_vm_foldarith,
+  GLOB_vm_cpuid,
+  GLOB_assert_bad_for_arg_type,
+  GLOB_vm_ffi_callback,
+  GLOB_vm_ffi_call,
+  GLOB_BC_MODVN_Z,
+  GLOB_BC_TGETS_Z,
+  GLOB_BC_TSETS_Z,
+  GLOB__MAX
+};
+static const char *const globnames[] = {
+  "vm_returnp",
+  "cont_dispatch",
+  "vm_returnc",
+  "vm_unwind_yield",
+  "BC_RET_Z",
+  "vm_return",
+  "vm_leave_cp",
+  "vm_leave_unw",
+  "vm_unwind_c_eh",
+  "vm_unwind_c@8",
+  "vm_unwind_rethrow",
+  "vm_unwind_ff@4",
+  "vm_unwind_ff_eh",
+  "vm_growstack_c",
+  "vm_growstack_v",
+  "vm_growstack_f",
+  "vm_resume",
+  "vm_pcall",
+  "vm_call",
+  "vm_call_dispatch",
+  "vmeta_call",
+  "vm_call_dispatch_f",
+  "vm_cpcall",
+  "cont_ffi_callback",
+  "vm_call_tail",
+  "cont_cat",
+  "cont_ra",
+  "BC_CAT_Z",
+  "vmeta_tgets",
+  "vmeta_tgetb",
+  "vmeta_tgetv",
+  "vmeta_tsets",
+  "vmeta_tsetb",
+  "vmeta_tsetv",
+  "cont_nop",
+  "vmeta_comp",
+  "vmeta_binop",
+  "cont_condt",
+  "cont_condf",
+  "vmeta_equal",
+  "vmeta_equal_cd",
+  "vmeta_arith_vno",
+  "vmeta_arith_vn",
+  "vmeta_arith_nvo",
+  "vmeta_arith_nv",
+  "vmeta_unm",
+  "vmeta_arith_vvo",
+  "vmeta_arith_vv",
+  "vmeta_len",
+  "BC_LEN_Z",
+  "vmeta_call_ra",
+  "BC_CALLT_Z",
+  "vmeta_for",
+  "ff_assert",
+  "fff_fallback",
+  "fff_res_",
+  "ff_type",
+  "fff_res1",
+  "ff_getmetatable",
+  "ff_setmetatable",
+  "ff_rawget",
+  "ff_tonumber",
+  "fff_resn",
+  "ff_tostring",
+  "fff_gcstep",
+  "ff_next",
+  "fff_res2",
+  "fff_res",
+  "ff_pairs",
+  "ff_ipairs_aux",
+  "fff_res0",
+  "ff_ipairs",
+  "ff_pcall",
+  "ff_xpcall",
+  "ff_coroutine_resume",
+  "ff_coroutine_wrap_aux",
+  "ff_coroutine_yield",
+  "fff_resi",
+  "ff_math_abs",
+  "fff_resxmm0",
+  "ff_math_floor",
+  "vm_floor",
+  "ff_math_ceil",
+  "vm_ceil",
+  "ff_math_sqrt",
+  "ff_math_log",
+  "ff_math_log10",
+  "ff_math_exp",
+  "vm_exp_x87",
+  "ff_math_sin",
+  "ff_math_cos",
+  "ff_math_tan",
+  "ff_math_asin",
+  "ff_math_acos",
+  "ff_math_atan",
+  "ff_math_sinh",
+  "ff_math_cosh",
+  "ff_math_tanh",
+  "ff_math_deg",
+  "ff_math_rad",
+  "ff_math_atan2",
+  "ff_math_ldexp",
+  "ff_math_frexp",
+  "ff_math_modf",
+  "vm_trunc",
+  "ff_math_fmod",
+  "ff_math_pow",
+  "vm_pow",
+  "ff_math_min",
+  "ff_math_max",
+  "ff_string_len",
+  "ff_string_byte",
+  "ff_string_char",
+  "fff_newstr",
+  "ff_string_sub",
+  "fff_emptystr",
+  "ff_string_rep",
+  "fff_fallback_2",
+  "ff_string_reverse",
+  "fff_fallback_1",
+  "ff_string_lower",
+  "ff_string_upper",
+  "ff_table_getn",
+  "ff_bit_tobit",
+  "ff_bit_band",
+  "fff_resbit",
+  "fff_fallback_bit_op",
+  "ff_bit_bor",
+  "ff_bit_bxor",
+  "ff_bit_bswap",
+  "ff_bit_bnot",
+  "ff_bit_lshift",
+  "ff_bit_rshift",
+  "ff_bit_arshift",
+  "ff_bit_rol",
+  "ff_bit_ror",
+  "vm_record",
+  "vm_rethook",
+  "vm_inshook",
+  "cont_hook",
+  "vm_hotloop",
+  "vm_callhook",
+  "vm_hotcall",
+  "vm_exit_handler",
+  "vm_exit_interp",
+  "vm_floor_sse",
+  "vm_ceil_sse",
+  "vm_trunc_sse",
+  "vm_mod",
+  "vm_log2",
+  "vm_exp2_x87",
+  "vm_exp2raw",
+  "vm_pow_sse",
+  "vm_powi_sse",
+  "vm_foldfpm",
+  "vm_foldarith",
+  "vm_cpuid",
+  "assert_bad_for_arg_type",
+  "vm_ffi_callback",
+  "vm_ffi_call@4",
+  "BC_MODVN_Z",
+  "BC_TGETS_Z",
+  "BC_TSETS_Z",
+  (const char *)0
+};
+static const char *const extnames[] = {
+  "lj_state_growstack@8",
+  "lj_meta_tget",
+  "lj_meta_tset",
+  "lj_meta_comp",
+  "lj_meta_equal",
+  "lj_meta_equal_cd@8",
+  "lj_meta_arith",
+  "lj_meta_len@8",
+  "lj_meta_call",
+  "lj_meta_for@8",
+  "lj_tab_get",
+  "lj_str_fromnum@8",
+  "lj_tab_next",
+  "lj_tab_getinth@8",
+  "lj_ffh_coroutine_wrap_err@8",
+  "lj_vm_sinh",
+  "lj_vm_cosh",
+  "lj_vm_tanh",
+  "lj_str_new",
+  "lj_tab_len@4",
+  "lj_gc_step@4",
+  "lj_dispatch_ins@8",
+  "lj_trace_hot@8",
+  "lj_dispatch_call@8",
+  "lj_trace_exit@8",
+  "lj_err_throw@8",
+  "lj_ccallback_enter@8",
+  "lj_ccallback_leave@8",
+  "lj_meta_cat",
+  "lj_gc_barrieruv@8",
+  "lj_func_closeuv@8",
+  "lj_func_newL_gc",
+  "lj_tab_new",
+  "lj_gc_step_fixtop@4",
+  "lj_tab_dup@8",
+  "lj_tab_newkey",
+  "lj_tab_reasize",
+  (const char *)0
+};
+#define Dt1(_V) (int)(ptrdiff_t)&(((lua_State *)0)_V)
+#define Dt2(_V) (int)(ptrdiff_t)&(((global_State *)0)_V)
+#define Dt3(_V) (int)(ptrdiff_t)&(((TValue *)0)_V)
+#define Dt4(_V) (int)(ptrdiff_t)&(((GCobj *)0)_V)
+#define Dt5(_V) (int)(ptrdiff_t)&(((GCstr *)0)_V)
+#define Dt6(_V) (int)(ptrdiff_t)&(((GCtab *)0)_V)
+#define Dt7(_V) (int)(ptrdiff_t)&(((GCfuncL *)0)_V)
+#define Dt8(_V) (int)(ptrdiff_t)&(((GCfuncC *)0)_V)
+#define Dt9(_V) (int)(ptrdiff_t)&(((GCproto *)0)_V)
+#define DtA(_V) (int)(ptrdiff_t)&(((GCupval *)0)_V)
+#define DtB(_V) (int)(ptrdiff_t)&(((Node *)0)_V)
+#define DtC(_V) (int)(ptrdiff_t)&(((int *)0)_V)
+#define DtD(_V) (int)(ptrdiff_t)&(((GCtrace *)0)_V)
+#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
+#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
+#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
+
+/* Generate subroutines used by opcodes and other parts of the VM. */
+/* The .code_sub section should be last to help static branch prediction. */
+static void build_subroutines(BuildCtx *ctx)
+{
+  dasm_put(Dst, 0);
+  dasm_put(Dst, 2, FRAME_P, LJ_TTRUE, FRAME_TYPE, FRAME_C, FRAME_TYPE, DISPATCH_GL(vmstate), ~LJ_VMST_C);
+  dasm_put(Dst, 91, Dt1(->base), Dt1(->top), Dt1(->cframe), Dt1(->maxstack), LJ_TNIL);
+  dasm_put(Dst, 192, Dt1(->top), Dt1(->top), LUA_YIELD, Dt1(->glref), Dt2(->vmstate), ~LJ_VMST_C);
+  dasm_put(Dst, 272, CFRAME_RAWMASK, 1+1, Dt1(->base), Dt1(->glref), GG_G2DISP, LJ_TFALSE, DISPATCH_GL(vmstate), ~LJ_VMST_INTERP, LUA_MINSTACK);
+  dasm_put(Dst, 339, -4+PC2PROTO(framesize), Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->top), Dt7(->pc), FRAME_CP, CFRAME_RESUME, Dt1(->glref), GG_G2DISP, Dt1(->cframe), Dt1(->status));
+  dasm_put(Dst, 472, DISPATCH_GL(vmstate), ~LJ_VMST_INTERP, Dt1(->status), Dt1(->base), Dt1(->top), FRAME_TYPE, FRAME_CP, FRAME_C, Dt1(->cframe), Dt1(->cframe));
+  dasm_put(Dst, 570, Dt1(->glref), GG_G2DISP, DISPATCH_GL(vmstate), ~LJ_VMST_INTERP, Dt1(->base), Dt1(->top), LJ_TFUNC, Dt7(->pc), Dt1(->stack), Dt1(->top), Dt1(->cframe), Dt1(->cframe));
+  dasm_put(Dst, 722, FRAME_CP, LJ_TNIL, Dt7(->pc), PC2PROTO(k));
+  dasm_put(Dst, 854, LJ_TSTR, BC_GGET, DISPATCH_GL(tmptv), LJ_TTAB, Dt1(->base), Dt1(->base));
+  dasm_put(Dst, 1016, Dt1(->top), FRAME_CONT, 2+1, LJ_TSTR, BC_GSET, DISPATCH_GL(tmptv), LJ_TTAB);
+  dasm_put(Dst, 1128, Dt1(->base), Dt1(->base), Dt1(->top), FRAME_CONT, 3+1, Dt1(->base), Dt1(->base));
+  dasm_put(Dst, 1310, -BCBIAS_J*4, LJ_TISTRUECOND, LJ_TISTRUECOND, Dt1(->base), Dt1(->base));
+  dasm_put(Dst, 1446, Dt1(->base), Dt1(->base), FRAME_CONT, 2+1);
+  dasm_put(Dst, 1562, Dt1(->base), Dt1(->base));
+#if LJ_52
+  dasm_put(Dst, 1593);
+#else
+  dasm_put(Dst, 1612);
+#endif
+  dasm_put(Dst, 1617, Dt1(->base), Dt1(->base), Dt7(->pc), Dt1(->base), Dt1(->base), GG_DISP2STATIC, 1+1, LJ_TISTRUECOND);
+  dasm_put(Dst, 1806, 1+1, ~LJ_TNUMX, ((char *)(&((GCfuncC *)0)->upvalue)), LJ_TSTR, 1+1);
+  dasm_put(Dst, 1905, LJ_TTAB, Dt6(->metatable), LJ_TNIL, DISPATCH_GL(gcroot)+4*(GCROOT_MMNAME+MM_metatable), LJ_TTAB, Dt6(->hmask), Dt5(->hash), sizeof(Node), Dt6(->node), DtB(->key.it), LJ_TSTR);
+  dasm_put(Dst, 1976, DtB(->key.gcr), DtB(->next), LJ_TNIL, LJ_TUDATA, LJ_TISNUM);
+  dasm_put(Dst, 2040, LJ_TNUMX, DISPATCH_GL(gcroot[GCROOT_BASEMT]), 2+1, LJ_TTAB, Dt6(->metatable), LJ_TTAB);
+  dasm_put(Dst, 2099, Dt6(->metatable), LJ_TTAB, Dt6(->marked), LJ_GC_BLACK, Dt6(->marked), (uint8_t)~LJ_GC_BLACK, DISPATCH_GL(gc.grayagain), DISPATCH_GL(gc.grayagain), Dt6(->gclist), 2+1, LJ_TTAB);
+  dasm_put(Dst, 2166, 1+1, LJ_TISNUM, 1+1, LJ_TSTR, LJ_TSTR);
+  dasm_put(Dst, 2274, LJ_TISNUM, DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM]), DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), Dt1(->base), Dt1(->base));
+  dasm_put(Dst, 2344, 1+1, LJ_TTAB, Dt1(->base), Dt1(->top), Dt1(->base), 1+2, LJ_TNIL);
+  dasm_put(Dst, 2454, LJ_TNIL, 1+1, LJ_TTAB);
+#if LJ_52
+  dasm_put(Dst, 2491, Dt6(->metatable));
+#endif
+  dasm_put(Dst, 2500, Dt8(->upvalue[0]), LJ_TFUNC, LJ_TNIL, 1+3, 1+1, LJ_TTAB, LJ_TISNUM, Dt6(->asize), Dt6(->array));
+  dasm_put(Dst, 2597, LJ_TNIL, Dt6(->hmask), 1+0, 1+1, LJ_TTAB);
+  dasm_put(Dst, 2094);
+#if LJ_52
+  dasm_put(Dst, 2491, Dt6(->metatable));
+#endif
+  dasm_put(Dst, 2676, Dt8(->upvalue[0]), LJ_TFUNC, 1+3, 1+1, 8+FRAME_PCALL, DISPATCH_GL(hookmask), HOOK_ACTIVE_SHIFT, 2+1, LJ_TFUNC);
+  dasm_put(Dst, 2762, LJ_TFUNC, 16+FRAME_PCALL, 1+1, LJ_TTHREAD, Dt1(->cframe), Dt1(->status), LUA_YIELD);
+  dasm_put(Dst, 2847, Dt1(->top), Dt1(->base), Dt1(->maxstack), Dt1(->top), Dt1(->base), Dt1(->top));
+  dasm_put(Dst, 2951, DISPATCH_GL(vmstate), ~LJ_VMST_INTERP, Dt1(->base), LUA_YIELD, Dt1(->base), Dt1(->top), Dt1(->top), Dt1(->maxstack), LJ_TTRUE);
+  dasm_put(Dst, 3048, FRAME_TYPE, LJ_TFALSE, Dt1(->top), Dt1(->top), 1+2, Dt1(->top), Dt1(->base), Dt8(->upvalue[0].gcr), Dt1(->cframe));
+  dasm_put(Dst, 3163, Dt1(->status), LUA_YIELD, Dt1(->top), Dt1(->base), Dt1(->maxstack), Dt1(->top), Dt1(->base), Dt1(->top));
+  dasm_put(Dst, 3233, DISPATCH_GL(vmstate), ~LJ_VMST_INTERP, Dt1(->base), LUA_YIELD, Dt1(->base), Dt1(->top), Dt1(->top), Dt1(->maxstack));
+  dasm_put(Dst, 3334, FRAME_TYPE, Dt1(->top), Dt1(->base), Dt1(->cframe), CFRAME_RESUME);
+  dasm_put(Dst, 3447, Dt1(->base), Dt1(->top), Dt1(->cframe), LUA_YIELD, Dt1(->status), 1+1, LJ_TISNUM, 1+1);
+  dasm_put(Dst, 3516, FRAME_TYPE, LJ_TNIL, LJ_TISNUM);
+  dasm_put(Dst, 3616, LJ_TISNUM, 1+1, LJ_TISNUM);
+  dasm_put(Dst, 3671, 1+1, LJ_TISNUM, 1+1, LJ_TISNUM, 1+1);
+  dasm_put(Dst, 3742, LJ_TISNUM, 1+1, LJ_TISNUM, 1+1);
+  dasm_put(Dst, 3799, LJ_TISNUM, 1+1, LJ_TISNUM, 1+1, LJ_TISNUM);
+  dasm_put(Dst, 3867, 1+1, LJ_TISNUM, 1+1, LJ_TISNUM);
+  dasm_put(Dst, 3961, 1+1, LJ_TISNUM, 1+1, LJ_TISNUM, 1+1);
+  dasm_put(Dst, 4044, LJ_TISNUM, 1+1, LJ_TISNUM, Dt8(->upvalue[0]), 2+1);
+  dasm_put(Dst, 4116, LJ_TISNUM, LJ_TISNUM, 2+1, LJ_TISNUM, LJ_TISNUM);
+  dasm_put(Dst, 4191, 1+1, LJ_TISNUM, 1+2);
+  dasm_put(Dst, 4321, 1+1, LJ_TISNUM, 1+2);
+  dasm_put(Dst, 4436, 2+1, LJ_TISNUM, LJ_TISNUM);
+  dasm_put(Dst, 4515, 2+1, LJ_TISNUM, LJ_TISNUM, LJ_TISNUM);
+  dasm_put(Dst, 4580, LJ_TISNUM, LJ_TISNUM, LJ_TISNUM);
+  dasm_put(Dst, 4677, 1+1, LJ_TSTR, Dt5(->len), 1+1, LJ_TSTR, Dt5(->len));
+  dasm_put(Dst, 4741, Dt5([1]), DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), 1+1, LJ_TISNUM);
+  dasm_put(Dst, 4815, Dt1(->base), Dt1(->base), LJ_TSTR, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), 1+2, LJ_TISNUM);
+  dasm_put(Dst, 4918, LJ_TSTR, LJ_TISNUM, Dt5(->len), sizeof(GCstr)-1);
+  dasm_put(Dst, 5010);
+  dasm_put(Dst, 5080, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), 2+1, LJ_TSTR, LJ_TISNUM, Dt5(->len));
+  dasm_put(Dst, 5149, DISPATCH_GL(tmpbuf.sz), Dt5([1]), DISPATCH_GL(tmpbuf.buf), DISPATCH_GL(tmpbuf.buf), 1+1, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold));
+  dasm_put(Dst, 5214, LJ_TSTR, Dt5(->len), DISPATCH_GL(tmpbuf.sz), sizeof(GCstr), DISPATCH_GL(tmpbuf.buf));
+  dasm_put(Dst, 5293, 1+1, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), LJ_TSTR, Dt5(->len), DISPATCH_GL(tmpbuf.sz), sizeof(GCstr), DISPATCH_GL(tmpbuf.buf));
+  dasm_put(Dst, 5358, 1+1, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold));
+  dasm_put(Dst, 5434, LJ_TSTR, Dt5(->len), DISPATCH_GL(tmpbuf.sz), sizeof(GCstr), DISPATCH_GL(tmpbuf.buf));
+  dasm_put(Dst, 5515, 1+1, LJ_TTAB, 1+1, LJ_TISNUM);
+  dasm_put(Dst, 5614, 1+1, LJ_TISNUM, LJ_TISNUM, 1+1, LJ_TISNUM);
+  dasm_put(Dst, 5722, LJ_TISNUM, 1+1, LJ_TISNUM);
+  dasm_put(Dst, 5838, LJ_TISNUM, 1+1, LJ_TISNUM, 1+1);
+  dasm_put(Dst, 5930, LJ_TISNUM, 2+1, LJ_TISNUM, LJ_TISNUM);
+  dasm_put(Dst, 6015, 2+1, LJ_TISNUM, LJ_TISNUM, 2+1, LJ_TISNUM);
+  dasm_put(Dst, 6146, LJ_TISNUM, 2+1, LJ_TISNUM, LJ_TISNUM, 2+1);
+  dasm_put(Dst, 6277, LJ_TISNUM, LJ_TISNUM, 1+2, 1+1, Dt1(->base), 8*LUA_MINSTACK, Dt1(->top), Dt1(->maxstack));
+  dasm_put(Dst, 6388, Dt8(->f), Dt1(->base), Dt1(->top), Dt7(->pc), FRAME_TYPE, LUA_MINSTACK);
+  dasm_put(Dst, 6496, Dt1(->base), Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->top), DISPATCH_GL(hookmask), HOOK_VMEVENT, HOOK_ACTIVE, LUA_MASKLINE|LUA_MASKCOUNT, DISPATCH_GL(hookcount));
+  dasm_put(Dst, 6594, DISPATCH_GL(hookmask), HOOK_ACTIVE, DISPATCH_GL(hookmask), HOOK_ACTIVE, LUA_MASKLINE|LUA_MASKCOUNT, DISPATCH_GL(hookcount));
+  dasm_put(Dst, 6641, LUA_MASKLINE, Dt1(->base), Dt1(->base), GG_DISP2STATIC, Dt7(->pc), PC2PROTO(framesize), Dt1(->base), Dt1(->top), GG_DISP2J, DISPATCH_J(L));
+  dasm_put(Dst, 6748, Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->top), DISPATCH_GL(vmstate), DISPATCH_GL(vmstate), ~LJ_VMST_EXIT, DISPATCH_J(exitno), DISPATCH_J(parent), 8*8+16, DISPATCH_GL(jit_L), DISPATCH_GL(jit_base));
+  dasm_put(Dst, 6948, DISPATCH_J(L), DISPATCH_GL(jit_L), Dt1(->base), GG_DISP2J, Dt1(->cframe), CFRAME_RAWMASK, CFRAME_OFS_L, Dt1(->base), CFRAME_OFS_PC, Dt7(->pc), PC2PROTO(k), DISPATCH_GL(jit_L), DISPATCH_GL(vmstate), ~LJ_VMST_INTERP, BC_FUNCF);
+  dasm_put(Dst, 7045);
+  dasm_put(Dst, 7564);
+  dasm_put(Dst, 7692);
+  dasm_put(Dst, 7760);
+  dasm_put(Dst, 7888);
+  dasm_put(Dst, 7991);
+  dasm_put(Dst, 8114);
+  dasm_put(Dst, 8303);
+  dasm_put(Dst, 8404);
+  dasm_put(Dst, 8516);
+  dasm_put(Dst, 8593);
+#ifdef LUA_USE_ASSERT
+  dasm_put(Dst, 8710);
+#endif
+#define DtE(_V) (int)(ptrdiff_t)&(((CTState *)0)_V)
+  dasm_put(Dst, 8712, GG_G2DISP, Dt2(->ctype_state), DtE(->cb.slot), CFRAME_SIZE+16, DtE(->cb.gpr[0]), DtE(->cb.gpr[1]), DtE(->cb.stack), CFRAME_SIZE+12, CFRAME_SIZE+8, DISPATCH_GL(vmstate), ~LJ_VMST_INTERP, Dt1(->base), Dt1(->top), Dt7(->pc), DISPATCH_GL(ctype_state), DtE(->L), Dt1(->base), Dt1(->top));
+#define DtF(_V) (int)(ptrdiff_t)&(((CCallState *)0)_V)
+  dasm_put(Dst, 8843, DtE(->cb.gpr[0]), DtE(->cb.gpr[1]), DtE(->cb.gpr[2]), DtE(->cb.fpr[0].d), DtE(->cb.fpr[0].f), Dt1(->top), DtF(->spadj), DtF(->spadj), DtF(->nsp));
+  dasm_put(Dst, 8944, offsetof(CCallState, stack), DtF(->gpr[0]), DtF(->gpr[1]), DtF(->func), DtF(->gpr[0]), DtF(->gpr[1]), DtF(->resx87), DtF(->fpr[0].d[0]), DtF(->fpr[0].f[0]));
+  dasm_put(Dst, 9005, DtF(->spadj));
+}
+
+/* Generate the code for a single instruction. */
+static void build_ins(BuildCtx *ctx, BCOp op, int defop)
+{
+  int vk = 0;
+  dasm_put(Dst, 470, defop);
+
+  switch (op) {
+
+  /* -- Comparison ops ---------------------------------------------------- */
+
+  /* Remember: all ops branch for a true comparison, fall through otherwise. */
+
+
+  case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
+    dasm_put(Dst, 9015, LJ_TISNUM, LJ_TISNUM);
+    switch (op) {
+    case BC_ISLT:
+    dasm_put(Dst, 9056);
+    break;
+    case BC_ISGE:
+    dasm_put(Dst, 9061);
+    break;
+    case BC_ISLE:
+    dasm_put(Dst, 5209);
+    break;
+    case BC_ISGT:
+    dasm_put(Dst, 9066);
+    break;
+    default: break;  /* Shut up GCC. */
+    }
+    dasm_put(Dst, 9071, -BCBIAS_J*4);
+    break;
+
+  case BC_ISEQV: case BC_ISNEV:
+    vk = op == BC_ISEQV;
+    dasm_put(Dst, 9102);
+    if (vk) {
+    } else {
+    }
+    dasm_put(Dst, 9110, LJ_TISNUM, LJ_TISNUM);
+  iseqne_fp:
+    if (vk) {
+      dasm_put(Dst, 9146);
+    } else {
+      dasm_put(Dst, 9155);
+    }
+  iseqne_end:
+    if (vk) {
+      dasm_put(Dst, 9164, -BCBIAS_J*4);
+    } else {
+      dasm_put(Dst, 9179, -BCBIAS_J*4);
+    }
+    if (LJ_DUALNUM && (op == BC_ISEQV || op == BC_ISNEV ||
+		       op == BC_ISEQN || op == BC_ISNEN)) {
+      dasm_put(Dst, 9194);
+    } else {
+      dasm_put(Dst, 9083);
+    }
+    if (op == BC_ISEQV || op == BC_ISNEV) {
+      dasm_put(Dst, 9199, LJ_TCDATA, LJ_TCDATA, LJ_TISPRI, LJ_TISTABUD, Dt6(->metatable));
+      dasm_put(Dst, 9266, Dt6(->nomm), 1<<MM_eq);
+      if (vk) {
+	dasm_put(Dst, 9276);
+      } else {
+	dasm_put(Dst, 9280);
+      }
+      dasm_put(Dst, 9286);
+    } else {
+      dasm_put(Dst, 9291, LJ_TCDATA);
+      if (LJ_DUALNUM && vk) {
+	dasm_put(Dst, 9298);
+      } else {
+	dasm_put(Dst, 9271);
+      }
+      dasm_put(Dst, 9303);
+    }
+    break;
+  case BC_ISEQS: case BC_ISNES:
+    vk = op == BC_ISEQS;
+    dasm_put(Dst, 9308, LJ_TSTR);
+  iseqne_test:
+    if (vk) {
+      dasm_put(Dst, 9150);
+    } else {
+      dasm_put(Dst, 6636);
+    }
+    goto iseqne_end;
+  case BC_ISEQN: case BC_ISNEN:
+    vk = op == BC_ISEQN;
+    dasm_put(Dst, 9333);
+    if (vk) {
+    } else {
+    }
+    dasm_put(Dst, 9341, LJ_TISNUM);
+    goto iseqne_fp;
+  case BC_ISEQP: case BC_ISNEP:
+    vk = op == BC_ISEQP;
+    dasm_put(Dst, 9367);
+    if (!LJ_HASFFI) goto iseqne_test;
+    if (vk) {
+      dasm_put(Dst, 9380, -BCBIAS_J*4, LJ_TCDATA);
+    } else {
+      dasm_put(Dst, 9429, LJ_TCDATA, -BCBIAS_J*4);
+    }
+    break;
+
+  /* -- Unary test and copy ops ------------------------------------------- */
+
+  case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
+    dasm_put(Dst, 9472, LJ_TISTRUECOND);
+    if (op == BC_IST || op == BC_ISTC) {
+      dasm_put(Dst, 9066);
+    } else {
+      dasm_put(Dst, 5209);
+    }
+    if (op == BC_ISTC || op == BC_ISFC) {
+      dasm_put(Dst, 9484);
+    }
+    dasm_put(Dst, 9071, -BCBIAS_J*4);
+    break;
+
+  /* -- Unary ops --------------------------------------------------------- */
+
+  case BC_MOV:
+    dasm_put(Dst, 9495);
+    break;
+  case BC_NOT:
+    dasm_put(Dst, 9528, LJ_TISTRUECOND, LJ_TTRUE);
+    break;
+  case BC_UNM:
+    dasm_put(Dst, 9563, LJ_TISNUM);
+    break;
+  case BC_LEN:
+    dasm_put(Dst, 9600, LJ_TSTR, Dt5(->len), LJ_TTAB);
+#if LJ_52
+    dasm_put(Dst, 9655, Dt6(->metatable));
+#endif
+    dasm_put(Dst, 9669);
+#if LJ_52
+    dasm_put(Dst, 9696, Dt6(->nomm), 1<<MM_len);
+#endif
+    break;
+
+  /* -- Binary ops -------------------------------------------------------- */
+
+
+  case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
+    dasm_put(Dst, 9712);
+    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
+    switch (vk) {
+    case 0:
+    dasm_put(Dst, 9720, LJ_TISNUM);
+      break;
+    case 1:
+    dasm_put(Dst, 9739, LJ_TISNUM);
+      break;
+    default:
+    dasm_put(Dst, 9758, LJ_TISNUM, LJ_TISNUM);
+      break;
+    }
+    dasm_put(Dst, 9578);
+    break;
+  case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
+    dasm_put(Dst, 9712);
+    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
+    switch (vk) {
+    case 0:
+    dasm_put(Dst, 9787, LJ_TISNUM);
+      break;
+    case 1:
+    dasm_put(Dst, 9806, LJ_TISNUM);
+      break;
+    default:
+    dasm_put(Dst, 9825, LJ_TISNUM, LJ_TISNUM);
+      break;
+    }
+    dasm_put(Dst, 9578);
+    break;
+  case BC_MULVN: case BC_MULNV: case BC_MULVV:
+    dasm_put(Dst, 9712);
+    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
+    switch (vk) {
+    case 0:
+    dasm_put(Dst, 9854, LJ_TISNUM);
+      break;
+    case 1:
+    dasm_put(Dst, 9873, LJ_TISNUM);
+      break;
+    default:
+    dasm_put(Dst, 9892, LJ_TISNUM, LJ_TISNUM);
+      break;
+    }
+    dasm_put(Dst, 9578);
+    break;
+  case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
+    dasm_put(Dst, 9712);
+    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
+    switch (vk) {
+    case 0:
+    dasm_put(Dst, 9921, LJ_TISNUM);
+      break;
+    case 1:
+    dasm_put(Dst, 9940, LJ_TISNUM);
+      break;
+    default:
+    dasm_put(Dst, 9959, LJ_TISNUM, LJ_TISNUM);
+      break;
+    }
+    dasm_put(Dst, 9578);
+    break;
+  case BC_MODVN:
+    dasm_put(Dst, 9712);
+    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
+    switch (vk) {
+    case 0:
+    dasm_put(Dst, 9988, LJ_TISNUM);
+      break;
+    case 1:
+    dasm_put(Dst, 10007, LJ_TISNUM);
+      break;
+    default:
+    dasm_put(Dst, 10026, LJ_TISNUM, LJ_TISNUM);
+      break;
+    }
+    dasm_put(Dst, 10055);
+    break;
+  case BC_MODNV: case BC_MODVV:
+    dasm_put(Dst, 9712);
+    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
+    switch (vk) {
+    case 0:
+    dasm_put(Dst, 9988, LJ_TISNUM);
+      break;
+    case 1:
+    dasm_put(Dst, 10007, LJ_TISNUM);
+      break;
+    default:
+    dasm_put(Dst, 10026, LJ_TISNUM, LJ_TISNUM);
+      break;
+    }
+    dasm_put(Dst, 10082);
+    break;
+  case BC_POW:
+    dasm_put(Dst, 9712);
+    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
+    switch (vk) {
+    case 0:
+    dasm_put(Dst, 9988, LJ_TISNUM);
+      break;
+    case 1:
+    dasm_put(Dst, 10007, LJ_TISNUM);
+      break;
+    default:
+    dasm_put(Dst, 10026, LJ_TISNUM, LJ_TISNUM);
+      break;
+    }
+    dasm_put(Dst, 10087);
+    break;
+
+  case BC_CAT:
+    dasm_put(Dst, 10112, Dt1(->base), Dt1(->base));
+    break;
+
+  /* -- Constant ops ------------------------------------------------------ */
+
+  case BC_KSTR:
+    dasm_put(Dst, 10206, LJ_TSTR);
+    break;
+  case BC_KCDATA:
+    dasm_put(Dst, 10206, LJ_TCDATA);
+    break;
+  case BC_KSHORT:
+    dasm_put(Dst, 10239);
+    break;
+  case BC_KNUM:
+    dasm_put(Dst, 10265);
+    break;
+  case BC_KPRI:
+    dasm_put(Dst, 10290);
+    break;
+  case BC_KNIL:
+    dasm_put(Dst, 10316, LJ_TNIL);
+    break;
+
+  /* -- Upvalue and function ops ------------------------------------------ */
+
+  case BC_UGET:
+    dasm_put(Dst, 10362, offsetof(GCfuncL, uvptr), DtA(->v));
+    break;
+  case BC_USETV:
+#define TV2MARKOFS \
+ ((int32_t)offsetof(GCupval, marked)-(int32_t)offsetof(GCupval, tv))
+    dasm_put(Dst, 10406, offsetof(GCfuncL, uvptr), DtA(->closed), DtA(->v), TV2MARKOFS, LJ_GC_BLACK, LJ_TISGCV, LJ_TISNUM - LJ_TISGCV, Dt4(->gch.marked), LJ_GC_WHITES, GG_DISP2G);
+    dasm_put(Dst, 10496);
+    break;
+#undef TV2MARKOFS
+  case BC_USETS:
+    dasm_put(Dst, 10508, offsetof(GCfuncL, uvptr), DtA(->v), LJ_TSTR, DtA(->marked), LJ_GC_BLACK, Dt4(->gch.marked), LJ_GC_WHITES, DtA(->closed), GG_DISP2G);
+    break;
+  case BC_USETN:
+    dasm_put(Dst, 10599, offsetof(GCfuncL, uvptr), DtA(->v));
+    break;
+  case BC_USETP:
+    dasm_put(Dst, 10635, offsetof(GCfuncL, uvptr), DtA(->v));
+    break;
+  case BC_UCLO:
+    dasm_put(Dst, 10672, -BCBIAS_J*4, Dt1(->openupval), Dt1(->base), Dt1(->base));
+    break;
+
+  case BC_FNEW:
+    dasm_put(Dst, 10726, Dt1(->base), Dt1(->base), LJ_TFUNC);
+    break;
+
+  /* -- Table ops --------------------------------------------------------- */
+
+  case BC_TNEW:
+    dasm_put(Dst, 10797, Dt1(->base), DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), Dt1(->base), LJ_TTAB);
+    break;
+  case BC_TDUP:
+    dasm_put(Dst, 10923, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), Dt1(->base), Dt1(->base), LJ_TTAB);
+    break;
+
+  case BC_GGET:
+    dasm_put(Dst, 11015, Dt7(->env));
+    break;
+  case BC_GSET:
+    dasm_put(Dst, 11033, Dt7(->env));
+    break;
+
+  case BC_TGETV:
+    dasm_put(Dst, 11051, LJ_TTAB, LJ_TISNUM, Dt6(->asize), Dt6(->array), LJ_TNIL, Dt6(->metatable));
+    dasm_put(Dst, 11169, Dt6(->metatable), Dt6(->nomm), 1<<MM_index, LJ_TNIL, LJ_TSTR);
+    break;
+  case BC_TGETS:
+    dasm_put(Dst, 11217, LJ_TTAB, Dt6(->hmask), Dt5(->hash), sizeof(Node), Dt6(->node), DtB(->key.it), LJ_TSTR, DtB(->key.gcr), LJ_TNIL);
+    dasm_put(Dst, 11305, LJ_TNIL, DtB(->next), Dt6(->metatable), Dt6(->nomm), 1<<MM_index);
+    break;
+  case BC_TGETB:
+    dasm_put(Dst, 11375, LJ_TTAB, Dt6(->asize), Dt6(->array), LJ_TNIL, Dt6(->metatable), Dt6(->metatable), Dt6(->nomm), 1<<MM_index);
+    dasm_put(Dst, 11474, LJ_TNIL);
+    break;
+
+  case BC_TSETV:
+    dasm_put(Dst, 11491, LJ_TTAB, LJ_TISNUM, Dt6(->asize), Dt6(->array), LJ_TNIL, Dt6(->marked), LJ_GC_BLACK);
+    dasm_put(Dst, 11580, Dt6(->metatable), Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, LJ_TSTR, Dt6(->marked), (uint8_t)~LJ_GC_BLACK);
+    dasm_put(Dst, 11667, DISPATCH_GL(gc.grayagain), DISPATCH_GL(gc.grayagain), Dt6(->gclist));
+    break;
+  case BC_TSETS:
+    dasm_put(Dst, 11686, LJ_TTAB, Dt6(->hmask), Dt5(->hash), sizeof(Node), Dt6(->nomm), Dt6(->node), DtB(->key.it), LJ_TSTR, DtB(->key.gcr), LJ_TNIL);
+    dasm_put(Dst, 11761, Dt6(->marked), LJ_GC_BLACK, Dt6(->metatable), Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, DtB(->next));
+    dasm_put(Dst, 11853, Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, LJ_TSTR, Dt1(->base), Dt1(->base), Dt6(->marked), (uint8_t)~LJ_GC_BLACK, DISPATCH_GL(gc.grayagain), DISPATCH_GL(gc.grayagain), Dt6(->gclist));
+    break;
+  case BC_TSETB:
+    dasm_put(Dst, 11949, LJ_TTAB, Dt6(->asize), Dt6(->array), LJ_TNIL, Dt6(->marked), LJ_GC_BLACK, Dt6(->metatable));
+    dasm_put(Dst, 12047, Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, Dt6(->marked), (uint8_t)~LJ_GC_BLACK, DISPATCH_GL(gc.grayagain), DISPATCH_GL(gc.grayagain), Dt6(->gclist));
+    break;
+
+  case BC_TSETM:
+    dasm_put(Dst, 12093, Dt6(->marked), LJ_GC_BLACK, Dt6(->asize), Dt6(->array), Dt1(->base), Dt1(->base));
+    dasm_put(Dst, 12242, Dt6(->marked), (uint8_t)~LJ_GC_BLACK, DISPATCH_GL(gc.grayagain), DISPATCH_GL(gc.grayagain), Dt6(->gclist));
+    break;
+
+  /* -- Calls and vararg handling ----------------------------------------- */
+
+  case BC_CALL: case BC_CALLM:
+    dasm_put(Dst, 9716);
+    if (op == BC_CALLM) {
+      dasm_put(Dst, 12260);
+    }
+    dasm_put(Dst, 12265, LJ_TFUNC, Dt7(->pc));
+    break;
+
+  case BC_CALLMT:
+    dasm_put(Dst, 12260);
+    break;
+  case BC_CALLT:
+    dasm_put(Dst, 12306, LJ_TFUNC, FRAME_TYPE, Dt7(->ffid), Dt7(->pc));
+    dasm_put(Dst, 12424, FRAME_TYPE, Dt7(->pc), PC2PROTO(k), FRAME_VARG, FRAME_TYPEP, FRAME_VARG);
+    break;
+
+  case BC_ITERC:
+    dasm_put(Dst, 12494, LJ_TFUNC, 2+1, Dt7(->pc));
+    break;
+
+  case BC_ITERN:
+    dasm_put(Dst, 12574, Dt6(->asize), Dt6(->array), LJ_TNIL, -BCBIAS_J*4, Dt6(->hmask), sizeof(Node));
+    dasm_put(Dst, 12722, Dt6(->node), DtB(->val.it), LJ_TNIL, DtB(->key.gcr), DtB(->key.it), DtB(->val.gcr), DtB(->val.it));
+    break;
+
+  case BC_ISNEXT:
+    dasm_put(Dst, 12783, LJ_TFUNC, LJ_TTAB, LJ_TNIL, Dt8(->ffid), FF_next_N, -BCBIAS_J*4, BC_JMP, -BCBIAS_J*4, BC_ITERC);
+    break;
+
+  case BC_VARG:
+    dasm_put(Dst, 12894, (8+FRAME_VARG), LJ_TNIL, Dt1(->maxstack));
+    dasm_put(Dst, 13058, Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->top));
+    break;
+
+  /* -- Returns ----------------------------------------------------------- */
+
+  case BC_RETM:
+    dasm_put(Dst, 12260);
+    break;
+
+  case BC_RET: case BC_RET0: case BC_RET1:
+    if (op != BC_RET0) {
+      dasm_put(Dst, 13129);
+    }
+    dasm_put(Dst, 13133, FRAME_TYPE);
+    switch (op) {
+    case BC_RET:
+      dasm_put(Dst, 13152);
+      break;
+    case BC_RET1:
+      dasm_put(Dst, 13210);
+      /* fallthrough */
+    case BC_RET0:
+      dasm_put(Dst, 13226);
+    default:
+      break;
+    }
+    dasm_put(Dst, 13237, Dt7(->pc), PC2PROTO(k));
+    if (op == BC_RET) {
+      dasm_put(Dst, 13279, LJ_TNIL);
+    } else {
+      dasm_put(Dst, 13288, LJ_TNIL);
+    }
+    dasm_put(Dst, 13295, -FRAME_VARG, FRAME_TYPEP);
+    if (op != BC_RET0) {
+      dasm_put(Dst, 13319);
+    }
+    dasm_put(Dst, 9691);
+    break;
+
+  /* -- Loops and branches ------------------------------------------------ */
+
+
+  case BC_FORL:
+    dasm_put(Dst, 13323, HOTCOUNT_PCMASK, GG_DISP2HOT, HOTCOUNT_LOOP);
+    break;
+
+  case BC_JFORI:
+  case BC_JFORL:
+#if !LJ_HASJIT
+    break;
+#endif
+  case BC_FORI:
+  case BC_IFORL:
+    vk = (op == BC_IFORL || op == BC_JFORL);
+    dasm_put(Dst, 13344);
+    if (LJ_DUALNUM) {
+      dasm_put(Dst, 13348, LJ_TISNUM);
+      if (!vk) {
+	dasm_put(Dst, 13358, LJ_TISNUM, LJ_TISNUM);
+      } else {
+#ifdef LUA_USE_ASSERT
+	dasm_put(Dst, 13387, LJ_TISNUM, LJ_TISNUM);
+#endif
+	dasm_put(Dst, 13406);
+      }
+      dasm_put(Dst, 13425, LJ_TISNUM);
+      if (op == BC_FORI) {
+	dasm_put(Dst, 13436, -BCBIAS_J*4);
+      } else if (op == BC_JFORI) {
+	dasm_put(Dst, 13450, -BCBIAS_J*4, BC_JLOOP);
+      } else if (op == BC_IFORL) {
+	dasm_put(Dst, 13468, -BCBIAS_J*4);
+      } else {
+	dasm_put(Dst, 13460, BC_JLOOP);
+      }
+      dasm_put(Dst, 13482);
+      if (vk) {
+	dasm_put(Dst, 13505);
+      }
+      dasm_put(Dst, 13425, LJ_TISNUM);
+      if (op == BC_FORI) {
+	dasm_put(Dst, 13514);
+      } else if (op == BC_JFORI) {
+	dasm_put(Dst, 13519, -BCBIAS_J*4, BC_JLOOP);
+      } else if (op == BC_IFORL) {
+	dasm_put(Dst, 13533);
+      } else {
+	dasm_put(Dst, 13529, BC_JLOOP);
+      }
+      dasm_put(Dst, 13538);
+    } else if (!vk) {
+      dasm_put(Dst, 13545, LJ_TISNUM);
+    }
+    if (!vk) {
+      dasm_put(Dst, 13551, LJ_TISNUM);
+    } else {
+#ifdef LUA_USE_ASSERT
+      dasm_put(Dst, 13565, LJ_TISNUM, LJ_TISNUM);
+#endif
+    }
+    dasm_put(Dst, 13584);
+    if (!vk) {
+      dasm_put(Dst, 13588, LJ_TISNUM);
+    }
+    if (vk) {
+    } else {
+    }
+    dasm_put(Dst, 13597);
+    if (vk) {
+      dasm_put(Dst, 13603);
+    } else {
+      dasm_put(Dst, 13619);
+    }
+    dasm_put(Dst, 13627);
+    if (op == BC_FORI) {
+      dasm_put(Dst, 13637, -BCBIAS_J*4);
+    } else if (op == BC_JFORI) {
+      dasm_put(Dst, 13647, -BCBIAS_J*4, BC_JLOOP);
+    } else if (op == BC_IFORL) {
+      dasm_put(Dst, 13661, -BCBIAS_J*4);
+    } else {
+      dasm_put(Dst, 13657, BC_JLOOP);
+    }
+    dasm_put(Dst, 9451);
+    break;
+
+  case BC_ITERL:
+    dasm_put(Dst, 13323, HOTCOUNT_PCMASK, GG_DISP2HOT, HOTCOUNT_LOOP);
+    break;
+
+  case BC_JITERL:
+#if !LJ_HASJIT
+    break;
+#endif
+  case BC_IITERL:
+    dasm_put(Dst, 13671, LJ_TNIL);
+    if (op == BC_JITERL) {
+      dasm_put(Dst, 13686, BC_JLOOP);
+    } else {
+      dasm_put(Dst, 13700, -BCBIAS_J*4);
+    }
+    dasm_put(Dst, 9081);
+    break;
+
+  case BC_LOOP:
+    dasm_put(Dst, 13323, HOTCOUNT_PCMASK, GG_DISP2HOT, HOTCOUNT_LOOP);
+    break;
+
+  case BC_ILOOP:
+    dasm_put(Dst, 9083);
+    break;
+
+  case BC_JLOOP:
+    dasm_put(Dst, 13716, DISPATCH_J(trace), DtD(->mcode), DISPATCH_GL(jit_base), DISPATCH_GL(jit_L));
+    break;
+
+  case BC_JMP:
+    dasm_put(Dst, 13739, -BCBIAS_J*4);
+    break;
+
+  /* -- Function headers -------------------------------------------------- */
+
+   /*
+   ** Reminder: A function may be called with func/args above L->maxstack,
+   ** i.e. occupying EXTRA_STACK slots. And vmeta_call may add one extra slot,
+   ** too. This means all FUNC* ops (including fast functions) must check
+   ** for stack overflow _before_ adding more slots!
+   */
+
+  case BC_FUNCF:
+    dasm_put(Dst, 13763, HOTCOUNT_PCMASK, GG_DISP2HOT, HOTCOUNT_CALL);
+  case BC_FUNCV:  /* NYI: compiled vararg functions. */
+    break;
+
+  case BC_JFUNCF:
+#if !LJ_HASJIT
+    break;
+#endif
+  case BC_IFUNCF:
+    dasm_put(Dst, 13784, -4+PC2PROTO(k), Dt1(->maxstack), -4+PC2PROTO(numparams));
+    if (op == BC_JFUNCF) {
+      dasm_put(Dst, 13814, BC_JLOOP);
+    } else {
+      dasm_put(Dst, 9083);
+    }
+    dasm_put(Dst, 13823, LJ_TNIL);
+    break;
+
+  case BC_JFUNCV:
+#if !LJ_HASJIT
+    break;
+#endif
+    dasm_put(Dst, 8710);
+    break;  /* NYI: compiled vararg functions. */
+
+  case BC_IFUNCV:
+    dasm_put(Dst, 13845, FRAME_VARG, Dt1(->maxstack), -4+PC2PROTO(numparams), LJ_TNIL);
+    if (op == BC_JFUNCV) {
+      dasm_put(Dst, 13814, BC_JLOOP);
+    } else {
+      dasm_put(Dst, 13936, -4+PC2PROTO(k));
+    }
+    dasm_put(Dst, 13958, LJ_TNIL);
+    break;
+
+  case BC_FUNCC:
+  case BC_FUNCCW:
+    dasm_put(Dst, 13980, Dt8(->f), Dt1(->base), 8*LUA_MINSTACK, Dt1(->maxstack), Dt1(->top));
+    if (op == BC_FUNCC) {
+      dasm_put(Dst, 14009);
+    } else {
+      dasm_put(Dst, 14013);
+    }
+    dasm_put(Dst, 14021, DISPATCH_GL(vmstate), ~LJ_VMST_C);
+    if (op == BC_FUNCC) {
+      dasm_put(Dst, 14030);
+    } else {
+      dasm_put(Dst, 14034, DISPATCH_GL(wrapf));
+    }
+    dasm_put(Dst, 14039, DISPATCH_GL(vmstate), ~LJ_VMST_INTERP, Dt1(->base), Dt1(->top));
+    break;
+
+  /* ---------------------------------------------------------------------- */
+
+  default:
+    fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
+    exit(2);
+    break;
+  }
+}
+
+static int build_backend(BuildCtx *ctx)
+{
+  int op;
+  dasm_growpc(Dst, BC__MAX);
+  build_subroutines(ctx);
+  dasm_put(Dst, 14064);
+  for (op = 0; op < BC__MAX; op++)
+    build_ins(ctx, (BCOp)op, op);
+  return BC__MAX;
+}
+
+/* Emit pseudo frame-info for all assembler functions. */
+static void emit_asm_debug(BuildCtx *ctx)
+{
+  int fcofs = (int)((uint8_t *)ctx->glob[GLOB_vm_ffi_call] - ctx->code);
+#if LJ_64
+#define SZPTR	"8"
+#define BSZPTR	"3"
+#define REG_SP	"0x7"
+#define REG_RA	"0x10"
+#else
+#define SZPTR	"4"
+#define BSZPTR	"2"
+#define REG_SP	"0x4"
+#define REG_RA	"0x8"
+#endif
+  switch (ctx->mode) {
+  case BUILD_elfasm:
+    fprintf(ctx->fp, "\t.section .debug_frame,\"\",@progbits\n");
+    fprintf(ctx->fp,
+	".Lframe0:\n"
+	"\t.long .LECIE0-.LSCIE0\n"
+	".LSCIE0:\n"
+	"\t.long 0xffffffff\n"
+	"\t.byte 0x1\n"
+	"\t.string \"\"\n"
+	"\t.uleb128 0x1\n"
+	"\t.sleb128 -" SZPTR "\n"
+	"\t.byte " REG_RA "\n"
+	"\t.byte 0xc\n\t.uleb128 " REG_SP "\n\t.uleb128 " SZPTR "\n"
+	"\t.byte 0x80+" REG_RA "\n\t.uleb128 0x1\n"
+	"\t.align " SZPTR "\n"
+	".LECIE0:\n\n");
+    fprintf(ctx->fp,
+	".LSFDE0:\n"
+	"\t.long .LEFDE0-.LASFDE0\n"
+	".LASFDE0:\n"
+	"\t.long .Lframe0\n"
+#if LJ_64
+	"\t.quad .Lbegin\n"
+	"\t.quad %d\n"
+	"\t.byte 0xe\n\t.uleb128 %d\n"		/* def_cfa_offset */
+	"\t.byte 0x86\n\t.uleb128 0x2\n"	/* offset rbp */
+	"\t.byte 0x83\n\t.uleb128 0x3\n"	/* offset rbx */
+	"\t.byte 0x8f\n\t.uleb128 0x4\n"	/* offset r15 */
+	"\t.byte 0x8e\n\t.uleb128 0x5\n"	/* offset r14 */
+#else
+	"\t.long .Lbegin\n"
+	"\t.long %d\n"
+	"\t.byte 0xe\n\t.uleb128 %d\n"		/* def_cfa_offset */
+	"\t.byte 0x85\n\t.uleb128 0x2\n"	/* offset ebp */
+	"\t.byte 0x87\n\t.uleb128 0x3\n"	/* offset edi */
+	"\t.byte 0x86\n\t.uleb128 0x4\n"	/* offset esi */
+	"\t.byte 0x83\n\t.uleb128 0x5\n"	/* offset ebx */
+#endif
+	"\t.align " SZPTR "\n"
+	".LEFDE0:\n\n", fcofs, CFRAME_SIZE);
+#if LJ_HASFFI
+    fprintf(ctx->fp,
+	".LSFDE1:\n"
+	"\t.long .LEFDE1-.LASFDE1\n"
+	".LASFDE1:\n"
+	"\t.long .Lframe0\n"
+#if LJ_64
+	"\t.quad lj_vm_ffi_call\n"
+	"\t.quad %d\n"
+	"\t.byte 0xe\n\t.uleb128 16\n"		/* def_cfa_offset */
+	"\t.byte 0x86\n\t.uleb128 0x2\n"	/* offset rbp */
+	"\t.byte 0xd\n\t.uleb128 0x6\n"		/* def_cfa_register rbp */
+	"\t.byte 0x83\n\t.uleb128 0x3\n"	/* offset rbx */
+#else
+	"\t.long lj_vm_ffi_call\n"
+	"\t.long %d\n"
+	"\t.byte 0xe\n\t.uleb128 8\n"		/* def_cfa_offset */
+	"\t.byte 0x85\n\t.uleb128 0x2\n"	/* offset ebp */
+	"\t.byte 0xd\n\t.uleb128 0x5\n"		/* def_cfa_register ebp */
+	"\t.byte 0x83\n\t.uleb128 0x3\n"	/* offset ebx */
+#endif
+	"\t.align " SZPTR "\n"
+	".LEFDE1:\n\n", (int)ctx->codesz - fcofs);
+#endif
+#if (defined(__sun__) && defined(__svr4__))
+    fprintf(ctx->fp, "\t.section .eh_frame,\"aw\",@progbits\n");
+#else
+    fprintf(ctx->fp, "\t.section .eh_frame,\"a\",@progbits\n");
+#endif
+    fprintf(ctx->fp,
+	".Lframe1:\n"
+	"\t.long .LECIE1-.LSCIE1\n"
+	".LSCIE1:\n"
+	"\t.long 0\n"
+	"\t.byte 0x1\n"
+	"\t.string \"zPR\"\n"
+	"\t.uleb128 0x1\n"
+	"\t.sleb128 -" SZPTR "\n"
+	"\t.byte " REG_RA "\n"
+	"\t.uleb128 6\n"			/* augmentation length */
+	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
+	"\t.long lj_err_unwind_dwarf-.\n"
+	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
+	"\t.byte 0xc\n\t.uleb128 " REG_SP "\n\t.uleb128 " SZPTR "\n"
+	"\t.byte 0x80+" REG_RA "\n\t.uleb128 0x1\n"
+	"\t.align " SZPTR "\n"
+	".LECIE1:\n\n");
+    fprintf(ctx->fp,
+	".LSFDE2:\n"
+	"\t.long .LEFDE2-.LASFDE2\n"
+	".LASFDE2:\n"
+	"\t.long .LASFDE2-.Lframe1\n"
+	"\t.long .Lbegin-.\n"
+	"\t.long %d\n"
+	"\t.uleb128 0\n"			/* augmentation length */
+	"\t.byte 0xe\n\t.uleb128 %d\n"		/* def_cfa_offset */
+#if LJ_64
+	"\t.byte 0x86\n\t.uleb128 0x2\n"	/* offset rbp */
+	"\t.byte 0x83\n\t.uleb128 0x3\n"	/* offset rbx */
+	"\t.byte 0x8f\n\t.uleb128 0x4\n"	/* offset r15 */
+	"\t.byte 0x8e\n\t.uleb128 0x5\n"	/* offset r14 */
+#else
+	"\t.byte 0x85\n\t.uleb128 0x2\n"	/* offset ebp */
+	"\t.byte 0x87\n\t.uleb128 0x3\n"	/* offset edi */
+	"\t.byte 0x86\n\t.uleb128 0x4\n"	/* offset esi */
+	"\t.byte 0x83\n\t.uleb128 0x5\n"	/* offset ebx */
+#endif
+	"\t.align " SZPTR "\n"
+	".LEFDE2:\n\n", fcofs, CFRAME_SIZE);
+#if LJ_HASFFI
+    fprintf(ctx->fp,
+	".Lframe2:\n"
+	"\t.long .LECIE2-.LSCIE2\n"
+	".LSCIE2:\n"
+	"\t.long 0\n"
+	"\t.byte 0x1\n"
+	"\t.string \"zR\"\n"
+	"\t.uleb128 0x1\n"
+	"\t.sleb128 -" SZPTR "\n"
+	"\t.byte " REG_RA "\n"
+	"\t.uleb128 1\n"			/* augmentation length */
+	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
+	"\t.byte 0xc\n\t.uleb128 " REG_SP "\n\t.uleb128 " SZPTR "\n"
+	"\t.byte 0x80+" REG_RA "\n\t.uleb128 0x1\n"
+	"\t.align " SZPTR "\n"
+	".LECIE2:\n\n");
+    fprintf(ctx->fp,
+	".LSFDE3:\n"
+	"\t.long .LEFDE3-.LASFDE3\n"
+	".LASFDE3:\n"
+	"\t.long .LASFDE3-.Lframe2\n"
+	"\t.long lj_vm_ffi_call-.\n"
+	"\t.long %d\n"
+	"\t.uleb128 0\n"			/* augmentation length */
+#if LJ_64
+	"\t.byte 0xe\n\t.uleb128 16\n"		/* def_cfa_offset */
+	"\t.byte 0x86\n\t.uleb128 0x2\n"	/* offset rbp */
+	"\t.byte 0xd\n\t.uleb128 0x6\n"		/* def_cfa_register rbp */
+	"\t.byte 0x83\n\t.uleb128 0x3\n"	/* offset rbx */
+#else
+	"\t.byte 0xe\n\t.uleb128 8\n"		/* def_cfa_offset */
+	"\t.byte 0x85\n\t.uleb128 0x2\n"	/* offset ebp */
+	"\t.byte 0xd\n\t.uleb128 0x5\n"		/* def_cfa_register ebp */
+	"\t.byte 0x83\n\t.uleb128 0x3\n"	/* offset ebx */
+#endif
+	"\t.align " SZPTR "\n"
+	".LEFDE3:\n\n", (int)ctx->codesz - fcofs);
+#endif
+    break;
+  /* Mental note: never let Apple design an assembler.
+  ** Or a linker. Or a plastic case. But I digress.
+  */
+  case BUILD_machasm: {
+#if LJ_HASFFI
+    int fcsize = 0;
+#endif
+    int i;
+    fprintf(ctx->fp, "\t.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support\n");
+    fprintf(ctx->fp,
+	"EH_frame1:\n"
+	"\t.set L$set$x,LECIEX-LSCIEX\n"
+	"\t.long L$set$x\n"
+	"LSCIEX:\n"
+	"\t.long 0\n"
+	"\t.byte 0x1\n"
+	"\t.ascii \"zPR\\0\"\n"
+	"\t.byte 0x1\n"
+	"\t.byte 128-" SZPTR "\n"
+	"\t.byte " REG_RA "\n"
+	"\t.byte 6\n"				/* augmentation length */
+	"\t.byte 0x9b\n"			/* indirect|pcrel|sdata4 */
+#if LJ_64
+	"\t.long _lj_err_unwind_dwarf+4@GOTPCREL\n"
+	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
+	"\t.byte 0xc\n\t.byte " REG_SP "\n\t.byte " SZPTR "\n"
+#else
+	"\t.long L_lj_err_unwind_dwarf$non_lazy_ptr-.\n"
+	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
+	"\t.byte 0xc\n\t.byte 0x5\n\t.byte 0x4\n"  /* esp=5 on 32 bit MACH-O. */
+#endif
+	"\t.byte 0x80+" REG_RA "\n\t.byte 0x1\n"
+	"\t.align " BSZPTR "\n"
+	"LECIEX:\n\n");
+    for (i = 0; i < ctx->nsym; i++) {
+      const char *name = ctx->sym[i].name;
+      int32_t size = ctx->sym[i+1].ofs - ctx->sym[i].ofs;
+      if (size == 0) continue;
+#if LJ_HASFFI
+      if (!strcmp(name, "_lj_vm_ffi_call")) { fcsize = size; continue; }
+#endif
+      fprintf(ctx->fp,
+	  "%s.eh:\n"
+	  "LSFDE%d:\n"
+	  "\t.set L$set$%d,LEFDE%d-LASFDE%d\n"
+	  "\t.long L$set$%d\n"
+	  "LASFDE%d:\n"
+	  "\t.long LASFDE%d-EH_frame1\n"
+	  "\t.long %s-.\n"
+	  "\t.long %d\n"
+	  "\t.byte 0\n"				/* augmentation length */
+	  "\t.byte 0xe\n\t.byte %d\n"		/* def_cfa_offset */
+#if LJ_64
+	  "\t.byte 0x86\n\t.byte 0x2\n"		/* offset rbp */
+	  "\t.byte 0x83\n\t.byte 0x3\n"		/* offset rbx */
+	  "\t.byte 0x8f\n\t.byte 0x4\n"		/* offset r15 */
+	  "\t.byte 0x8e\n\t.byte 0x5\n"		/* offset r14 */
+#else
+	  "\t.byte 0x84\n\t.byte 0x2\n"		/* offset ebp (4 for MACH-O)*/
+	  "\t.byte 0x87\n\t.byte 0x3\n"		/* offset edi */
+	  "\t.byte 0x86\n\t.byte 0x4\n"		/* offset esi */
+	  "\t.byte 0x83\n\t.byte 0x5\n"		/* offset ebx */
+#endif
+	  "\t.align " BSZPTR "\n"
+	  "LEFDE%d:\n\n",
+	  name, i, i, i, i, i, i, i, name, size, CFRAME_SIZE, i);
+    }
+#if LJ_HASFFI
+    if (fcsize) {
+      fprintf(ctx->fp,
+	  "EH_frame2:\n"
+	  "\t.set L$set$y,LECIEY-LSCIEY\n"
+	  "\t.long L$set$y\n"
+	  "LSCIEY:\n"
+	  "\t.long 0\n"
+	  "\t.byte 0x1\n"
+	  "\t.ascii \"zR\\0\"\n"
+	  "\t.byte 0x1\n"
+	  "\t.byte 128-" SZPTR "\n"
+	  "\t.byte " REG_RA "\n"
+	  "\t.byte 1\n"				/* augmentation length */
+#if LJ_64
+	  "\t.byte 0x1b\n"			/* pcrel|sdata4 */
+	  "\t.byte 0xc\n\t.byte " REG_SP "\n\t.byte " SZPTR "\n"
+#else
+	  "\t.byte 0x1b\n"			/* pcrel|sdata4 */
+	  "\t.byte 0xc\n\t.byte 0x5\n\t.byte 0x4\n"  /* esp=5 on 32 bit MACH. */
+#endif
+	  "\t.byte 0x80+" REG_RA "\n\t.byte 0x1\n"
+	  "\t.align " BSZPTR "\n"
+	  "LECIEY:\n\n");
+      fprintf(ctx->fp,
+	  "_lj_vm_ffi_call.eh:\n"
+	  "LSFDEY:\n"
+	  "\t.set L$set$yy,LEFDEY-LASFDEY\n"
+	  "\t.long L$set$yy\n"
+	  "LASFDEY:\n"
+	  "\t.long LASFDEY-EH_frame2\n"
+	  "\t.long _lj_vm_ffi_call-.\n"
+	  "\t.long %d\n"
+	  "\t.byte 0\n"				/* augmentation length */
+#if LJ_64
+	  "\t.byte 0xe\n\t.byte 16\n"		/* def_cfa_offset */
+	  "\t.byte 0x86\n\t.byte 0x2\n"		/* offset rbp */
+	  "\t.byte 0xd\n\t.uleb128 0x6\n"	/* def_cfa_register rbp */
+	  "\t.byte 0x83\n\t.byte 0x3\n"		/* offset rbx */
+#else
+	  "\t.byte 0xe\n\t.byte 8\n"		/* def_cfa_offset */
+	  "\t.byte 0x84\n\t.byte 0x2\n"		/* offset ebp (4 for MACH-O)*/
+	  "\t.byte 0xd\n\t.uleb128 0x4\n"	/* def_cfa_register ebp */
+	  "\t.byte 0x83\n\t.byte 0x3\n"		/* offset ebx */
+#endif
+	  "\t.align " BSZPTR "\n"
+	  "LEFDEY:\n\n", fcsize);
+    }
+#endif
+#if LJ_64
+    fprintf(ctx->fp, "\t.subsections_via_symbols\n");
+#else
+    fprintf(ctx->fp,
+      "\t.non_lazy_symbol_pointer\n"
+      "L_lj_err_unwind_dwarf$non_lazy_ptr:\n"
+      ".indirect_symbol _lj_err_unwind_dwarf\n"
+      ".long 0\n");
+#endif
+    }
+    break;
+  default:  /* Difficult for other modes. */
+    break;
+  }
+}
+
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/jit/vmdef.lua b/scripting/lua/luajit/LuaJIT-2.0.1/src/jit/vmdef.lua
new file mode 100755
index 0000000..52bb253
--- /dev/null
+++ b/scripting/lua/luajit/LuaJIT-2.0.1/src/jit/vmdef.lua
@@ -0,0 +1,331 @@
+-- This is a generated file. DO NOT EDIT!
+
+module(...)
+
+bcnames = "ISLT  ISGE  ISLE  ISGT  ISEQV ISNEV ISEQS ISNES ISEQN ISNEN ISEQP ISNEP ISTC  ISFC  IST   ISF   MOV   NOT   UNM   LEN   ADDVN SUBVN MULVN DIVVN MODVN ADDNV SUBNV MULNV DIVNV MODNV ADDVV SUBVV MULVV DIVVV MODVV POW   CAT   KSTR  KCDATAKSHORTKNUM  KPRI  KNIL  UGET  USETV USETS USETN USETP UCLO  FNEW  TNEW  TDUP  GGET  GSET  TGETV TGETS TGETB TSETV TSETS TSETB TSETM CALLM CALL  CALLMTCALLT ITERC ITERN VARG  ISNEXTRETM  RET   RET0  RET1  FORI  JFORI FORL  IFORL JFORL ITERL IITERLJITERLLOOP  ILOOP JLOOP JMP   FUNCF IFUNCFJFUNCFFUNCV IFUNCVJFUNCVFUNCC FUNCCW"
+
+irnames = "LT    GE    LE    GT    ULT   UGE   ULE   UGT   EQ    NE    ABC   RETF  NOP   BASE  PVAL  GCSTEPHIOP  LOOP  USE   PHI   RENAMEKPRI  KINT  KGC   KPTR  KKPTR KNULL KNUM  KINT64KSLOT BNOT  BSWAP BAND  BOR   BXOR  BSHL  BSHR  BSAR  BROL  BROR  ADD   SUB   MUL   DIV   MOD   POW   NEG   ABS   ATAN2 LDEXP MIN   MAX   FPMATHADDOV SUBOV MULOV AREF  HREFK HREF  NEWREFUREFO UREFC FREF  STRREFALOAD HLOAD ULOAD FLOAD XLOAD SLOAD VLOAD ASTOREHSTOREUSTOREFSTOREXSTORESNEW  XSNEW TNEW  TDUP  CNEW  CNEWI TBAR  OBAR  XBAR  CONV  TOBIT TOSTR STRTO CALLN CALLL CALLS CALLXSCARG  "
+
+irfpm = { [0]="floor", "ceil", "trunc", "sqrt", "exp", "exp2", "log", "log2", "log10", "sin", "cos", "tan", "other", }
+
+irfield = { [0]="str.len", "func.env", "func.pc", "tab.meta", "tab.array", "tab.node", "tab.asize", "tab.hmask", "tab.nomm", "udata.meta", "udata.udtype", "udata.file", "cdata.ctypeid", "cdata.ptr", "cdata.int", "cdata.int64", "cdata.int64_4", }
+
+ircall = {
+[0]="lj_str_cmp",
+"lj_str_new",
+"lj_strscan_num",
+"lj_str_fromint",
+"lj_str_fromnum",
+"lj_tab_new1",
+"lj_tab_dup",
+"lj_tab_newkey",
+"lj_tab_len",
+"lj_gc_step_jit",
+"lj_gc_barrieruv",
+"lj_mem_newgco",
+"lj_math_random_step",
+"lj_vm_modi",
+"sinh",
+"cosh",
+"tanh",
+"fputc",
+"fwrite",
+"fflush",
+"lj_vm_floor",
+"lj_vm_ceil",
+"lj_vm_trunc",
+"sqrt",
+"exp",
+"lj_vm_exp2",
+"log",
+"lj_vm_log2",
+"log10",
+"sin",
+"cos",
+"tan",
+"lj_vm_powi",
+"pow",
+"atan2",
+"ldexp",
+"lj_vm_tobit",
+"softfp_add",
+"softfp_sub",
+"softfp_mul",
+"softfp_div",
+"softfp_cmp",
+"softfp_i2d",
+"softfp_d2i",
+"softfp_ui2d",
+"softfp_f2d",
+"softfp_d2ui",
+"softfp_d2f",
+"softfp_i2f",
+"softfp_ui2f",
+"softfp_f2i",
+"softfp_f2ui",
+"fp64_l2d",
+"fp64_ul2d",
+"fp64_l2f",
+"fp64_ul2f",
+"fp64_d2l",
+"fp64_d2ul",
+"fp64_f2l",
+"fp64_f2ul",
+"lj_carith_divi64",
+"lj_carith_divu64",
+"lj_carith_modi64",
+"lj_carith_modu64",
+"lj_carith_powi64",
+"lj_carith_powu64",
+"lj_cdata_setfin",
+"strlen",
+"memcpy",
+"memset",
+"lj_vm_errno",
+"lj_carith_mul64",
+}
+
+traceerr = {
+[0]="error thrown or hook called during recording",
+"trace too long",
+"trace too deep",
+"too many snapshots",
+"blacklisted",
+"NYI: bytecode %d",
+"leaving loop in root trace",
+"inner loop in root trace",
+"loop unroll limit reached",
+"bad argument type",
+"call to JIT-disabled function",
+"call unroll limit reached",
+"down-recursion, restarting",
+"NYI: C function %p",
+"NYI: FastFunc %s",
+"NYI: unsupported variant of FastFunc %s",
+"NYI: return to lower frame",
+"store with nil or NaN key",
+"missing metamethod",
+"looping index lookup",
+"NYI: mixed sparse/dense table",
+"symbol not in cache",
+"NYI: unsupported C type conversion",
+"NYI: unsupported C function type",
+"guard would always fail",
+"too many PHIs",
+"persistent type instability",
+"failed to allocate mcode memory",
+"machine code too long",
+"hit mcode limit (retrying)",
+"too many spill slots",
+"inconsistent register allocation",
+"NYI: cannot assemble IR instruction %d",
+"NYI: PHI shuffling too complex",
+"NYI: register coalescing too complex",
+}
+
+ffnames = {
+[0]="Lua",
+"C",
+"assert",
+"type",
+"next",
+"pairs",
+"ipairs_aux",
+"ipairs",
+"getmetatable",
+"setmetatable",
+"getfenv",
+"setfenv",
+"rawget",
+"rawset",
+"rawequal",
+"unpack",
+"select",
+"tonumber",
+"tostring",
+"error",
+"pcall",
+"xpcall",
+"loadfile",
+"load",
+"loadstring",
+"dofile",
+"gcinfo",
+"collectgarbage",
+"newproxy",
+"print",
+"coroutine.status",
+"coroutine.running",
+"coroutine.create",
+"coroutine.yield",
+"coroutine.resume",
+"coroutine.wrap_aux",
+"coroutine.wrap",
+"math.abs",
+"math.floor",
+"math.ceil",
+"math.sqrt",
+"math.log10",
+"math.exp",
+"math.sin",
+"math.cos",
+"math.tan",
+"math.asin",
+"math.acos",
+"math.atan",
+"math.sinh",
+"math.cosh",
+"math.tanh",
+"math.frexp",
+"math.modf",
+"math.log",
+"math.deg",
+"math.rad",
+"math.atan2",
+"math.pow",
+"math.fmod",
+"math.ldexp",
+"math.min",
+"math.max",
+"math.random",
+"math.randomseed",
+"bit.tobit",
+"bit.bnot",
+"bit.bswap",
+"bit.lshift",
+"bit.rshift",
+"bit.arshift",
+"bit.rol",
+"bit.ror",
+"bit.band",
+"bit.bor",
+"bit.bxor",
+"bit.tohex",
+"string.len",
+"string.byte",
+"string.char",
+"string.sub",
+"string.rep",
+"string.reverse",
+"string.lower",
+"string.upper",
+"string.dump",
+"string.find",
+"string.match",
+"string.gmatch_aux",
+"string.gmatch",
+"string.gsub",
+"string.format",
+"table.foreachi",
+"table.foreach",
+"table.getn",
+"table.maxn",
+"table.insert",
+"table.remove",
+"table.concat",
+"table.sort",
+"io.method.close",
+"io.method.read",
+"io.method.write",
+"io.method.flush",
+"io.method.seek",
+"io.method.setvbuf",
+"io.method.lines",
+"io.method.__gc",
+"io.method.__tostring",
+"io.open",
+"io.popen",
+"io.tmpfile",
+"io.close",
+"io.read",
+"io.write",
+"io.flush",
+"io.input",
+"io.output",
+"io.lines",
+"io.type",
+"os.execute",
+"os.remove",
+"os.rename",
+"os.tmpname",
+"os.getenv",
+"os.exit",
+"os.clock",
+"os.date",
+"os.time",
+"os.difftime",
+"os.setlocale",
+"debug.getregistry",
+"debug.getmetatable",
+"debug.setmetatable",
+"debug.getfenv",
+"debug.setfenv",
+"debug.getinfo",
+"debug.getlocal",
+"debug.setlocal",
+"debug.getupvalue",
+"debug.setupvalue",
+"debug.upvalueid",
+"debug.upvaluejoin",
+"debug.sethook",
+"debug.gethook",
+"debug.debug",
+"debug.traceback",
+"jit.on",
+"jit.off",
+"jit.flush",
+"jit.status",
+"jit.attach",
+"jit.util.funcinfo",
+"jit.util.funcbc",
+"jit.util.funck",
+"jit.util.funcuvname",
+"jit.util.traceinfo",
+"jit.util.traceir",
+"jit.util.tracek",
+"jit.util.tracesnap",
+"jit.util.tracemc",
+"jit.util.traceexitstub",
+"jit.util.ircalladdr",
+"jit.opt.start",
+"ffi.meta.__index",
+"ffi.meta.__newindex",
+"ffi.meta.__eq",
+"ffi.meta.__len",
+"ffi.meta.__lt",
+"ffi.meta.__le",
+"ffi.meta.__concat",
+"ffi.meta.__call",
+"ffi.meta.__add",
+"ffi.meta.__sub",
+"ffi.meta.__mul",
+"ffi.meta.__div",
+"ffi.meta.__mod",
+"ffi.meta.__pow",
+"ffi.meta.__unm",
+"ffi.meta.__tostring",
+"ffi.meta.__pairs",
+"ffi.meta.__ipairs",
+"ffi.clib.__index",
+"ffi.clib.__newindex",
+"ffi.clib.__gc",
+"ffi.callback.free",
+"ffi.callback.set",
+"ffi.cdef",
+"ffi.new",
+"ffi.cast",
+"ffi.typeof",
+"ffi.istype",
+"ffi.sizeof",
+"ffi.alignof",
+"ffi.offsetof",
+"ffi.errno",
+"ffi.string",
+"ffi.copy",
+"ffi.fill",
+"ffi.abi",
+"ffi.metatype",
+"ffi.gc",
+"ffi.load",
+}
+
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_bcdef.h b/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_bcdef.h
new file mode 100755
index 0000000..461e7de
--- /dev/null
+++ b/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_bcdef.h
@@ -0,0 +1,226 @@
+/* This is a generated file. DO NOT EDIT! */
+
+LJ_DATADEF const uint16_t lj_bc_ofs[] = {
+0,
+65,
+130,
+195,
+260,
+387,
+517,
+577,
+637,
+701,
+765,
+816,
+866,
+916,
+966,
+1006,
+1046,
+1077,
+1108,
+1144,
+1212,
+1255,
+1298,
+1341,
+1384,
+1432,
+1475,
+1518,
+1561,
+1604,
+1632,
+1686,
+1740,
+1794,
+1848,
+1887,
+1946,
+2034,
+2067,
+2100,
+2123,
+2146,
+2169,
+2211,
+2251,
+2334,
+2412,
+2444,
+2476,
+2526,
+2596,
+2709,
+2796,
+2812,
+2828,
+2976,
+3102,
+3205,
+3376,
+3615,
+3741,
+3883,
+3928,
+3969,
+3973,
+4119,
+4194,
+4364,
+4552,
+4639,
+4643,
+4772,
+4859,
+4964,
+5041,
+5126,
+5145,
+5200,
+5252,
+5271,
+5314,
+5352,
+5371,
+5388,
+5418,
+5442,
+5461,
+5522,
+5575,
+5575,
+5692,
+5693,
+5769,
+7416,
+7487,
+7961,
+8081,
+8138,
+8253,
+7536,
+7678,
+7768,
+7835,
+7861,
+8308,
+8348,
+8980,
+8403,
+8719,
+9022,
+9122,
+9141,
+9160,
+9218,
+9248,
+9279,
+9307,
+9335,
+9365,
+9403,
+9443,
+9473,
+9511,
+9549,
+9703,
+9838,
+9188,
+9587,
+9587,
+9619,
+9974,
+9926,
+9660,
+10018,
+10065,
+10972,
+11297,
+11254,
+11358,
+11426,
+11497,
+11568,
+11639,
+11016,
+11098,
+11180,
+10119,
+10148,
+10199,
+10313,
+10478,
+10603,
+10709,
+10820,
+10931
+};
+
+LJ_DATADEF const uint16_t lj_bc_mode[] = {
+BCDEF(BCMODE)
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF,
+BCMODE_FF
+};
+
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_ffdef.h b/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_ffdef.h
new file mode 100755
index 0000000..27ec013
--- /dev/null
+++ b/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_ffdef.h
@@ -0,0 +1,210 @@
+/* This is a generated file. DO NOT EDIT! */
+
+FFDEF(assert)
+FFDEF(type)
+FFDEF(next)
+FFDEF(pairs)
+FFDEF(ipairs_aux)
+FFDEF(ipairs)
+FFDEF(getmetatable)
+FFDEF(setmetatable)
+FFDEF(getfenv)
+FFDEF(setfenv)
+FFDEF(rawget)
+FFDEF(rawset)
+FFDEF(rawequal)
+FFDEF(unpack)
+FFDEF(select)
+FFDEF(tonumber)
+FFDEF(tostring)
+FFDEF(error)
+FFDEF(pcall)
+FFDEF(xpcall)
+FFDEF(loadfile)
+FFDEF(load)
+FFDEF(loadstring)
+FFDEF(dofile)
+FFDEF(gcinfo)
+FFDEF(collectgarbage)
+FFDEF(newproxy)
+FFDEF(print)
+FFDEF(coroutine_status)
+FFDEF(coroutine_running)
+FFDEF(coroutine_create)
+FFDEF(coroutine_yield)
+FFDEF(coroutine_resume)
+FFDEF(coroutine_wrap_aux)
+FFDEF(coroutine_wrap)
+FFDEF(math_abs)
+FFDEF(math_floor)
+FFDEF(math_ceil)
+FFDEF(math_sqrt)
+FFDEF(math_log10)
+FFDEF(math_exp)
+FFDEF(math_sin)
+FFDEF(math_cos)
+FFDEF(math_tan)
+FFDEF(math_asin)
+FFDEF(math_acos)
+FFDEF(math_atan)
+FFDEF(math_sinh)
+FFDEF(math_cosh)
+FFDEF(math_tanh)
+FFDEF(math_frexp)
+FFDEF(math_modf)
+FFDEF(math_log)
+FFDEF(math_deg)
+FFDEF(math_rad)
+FFDEF(math_atan2)
+FFDEF(math_pow)
+FFDEF(math_fmod)
+FFDEF(math_ldexp)
+FFDEF(math_min)
+FFDEF(math_max)
+FFDEF(math_random)
+FFDEF(math_randomseed)
+FFDEF(bit_tobit)
+FFDEF(bit_bnot)
+FFDEF(bit_bswap)
+FFDEF(bit_lshift)
+FFDEF(bit_rshift)
+FFDEF(bit_arshift)
+FFDEF(bit_rol)
+FFDEF(bit_ror)
+FFDEF(bit_band)
+FFDEF(bit_bor)
+FFDEF(bit_bxor)
+FFDEF(bit_tohex)
+FFDEF(string_len)
+FFDEF(string_byte)
+FFDEF(string_char)
+FFDEF(string_sub)
+FFDEF(string_rep)
+FFDEF(string_reverse)
+FFDEF(string_lower)
+FFDEF(string_upper)
+FFDEF(string_dump)
+FFDEF(string_find)
+FFDEF(string_match)
+FFDEF(string_gmatch_aux)
+FFDEF(string_gmatch)
+FFDEF(string_gsub)
+FFDEF(string_format)
+FFDEF(table_foreachi)
+FFDEF(table_foreach)
+FFDEF(table_getn)
+FFDEF(table_maxn)
+FFDEF(table_insert)
+FFDEF(table_remove)
+FFDEF(table_concat)
+FFDEF(table_sort)
+FFDEF(io_method_close)
+FFDEF(io_method_read)
+FFDEF(io_method_write)
+FFDEF(io_method_flush)
+FFDEF(io_method_seek)
+FFDEF(io_method_setvbuf)
+FFDEF(io_method_lines)
+FFDEF(io_method___gc)
+FFDEF(io_method___tostring)
+FFDEF(io_open)
+FFDEF(io_popen)
+FFDEF(io_tmpfile)
+FFDEF(io_close)
+FFDEF(io_read)
+FFDEF(io_write)
+FFDEF(io_flush)
+FFDEF(io_input)
+FFDEF(io_output)
+FFDEF(io_lines)
+FFDEF(io_type)
+FFDEF(os_execute)
+FFDEF(os_remove)
+FFDEF(os_rename)
+FFDEF(os_tmpname)
+FFDEF(os_getenv)
+FFDEF(os_exit)
+FFDEF(os_clock)
+FFDEF(os_date)
+FFDEF(os_time)
+FFDEF(os_difftime)
+FFDEF(os_setlocale)
+FFDEF(debug_getregistry)
+FFDEF(debug_getmetatable)
+FFDEF(debug_setmetatable)
+FFDEF(debug_getfenv)
+FFDEF(debug_setfenv)
+FFDEF(debug_getinfo)
+FFDEF(debug_getlocal)
+FFDEF(debug_setlocal)
+FFDEF(debug_getupvalue)
+FFDEF(debug_setupvalue)
+FFDEF(debug_upvalueid)
+FFDEF(debug_upvaluejoin)
+FFDEF(debug_sethook)
+FFDEF(debug_gethook)
+FFDEF(debug_debug)
+FFDEF(debug_traceback)
+FFDEF(jit_on)
+FFDEF(jit_off)
+FFDEF(jit_flush)
+FFDEF(jit_status)
+FFDEF(jit_attach)
+FFDEF(jit_util_funcinfo)
+FFDEF(jit_util_funcbc)
+FFDEF(jit_util_funck)
+FFDEF(jit_util_funcuvname)
+FFDEF(jit_util_traceinfo)
+FFDEF(jit_util_traceir)
+FFDEF(jit_util_tracek)
+FFDEF(jit_util_tracesnap)
+FFDEF(jit_util_tracemc)
+FFDEF(jit_util_traceexitstub)
+FFDEF(jit_util_ircalladdr)
+FFDEF(jit_opt_start)
+FFDEF(ffi_meta___index)
+FFDEF(ffi_meta___newindex)
+FFDEF(ffi_meta___eq)
+FFDEF(ffi_meta___len)
+FFDEF(ffi_meta___lt)
+FFDEF(ffi_meta___le)
+FFDEF(ffi_meta___concat)
+FFDEF(ffi_meta___call)
+FFDEF(ffi_meta___add)
+FFDEF(ffi_meta___sub)
+FFDEF(ffi_meta___mul)
+FFDEF(ffi_meta___div)
+FFDEF(ffi_meta___mod)
+FFDEF(ffi_meta___pow)
+FFDEF(ffi_meta___unm)
+FFDEF(ffi_meta___tostring)
+FFDEF(ffi_meta___pairs)
+FFDEF(ffi_meta___ipairs)
+FFDEF(ffi_clib___index)
+FFDEF(ffi_clib___newindex)
+FFDEF(ffi_clib___gc)
+FFDEF(ffi_callback_free)
+FFDEF(ffi_callback_set)
+FFDEF(ffi_cdef)
+FFDEF(ffi_new)
+FFDEF(ffi_cast)
+FFDEF(ffi_typeof)
+FFDEF(ffi_istype)
+FFDEF(ffi_sizeof)
+FFDEF(ffi_alignof)
+FFDEF(ffi_offsetof)
+FFDEF(ffi_errno)
+FFDEF(ffi_string)
+FFDEF(ffi_copy)
+FFDEF(ffi_fill)
+FFDEF(ffi_abi)
+FFDEF(ffi_metatype)
+FFDEF(ffi_gc)
+FFDEF(ffi_load)
+
+#undef FFDEF
+
+#ifndef FF_NUM_ASMFUNC
+#define FF_NUM_ASMFUNC 62
+#endif
+
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_folddef.h b/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_folddef.h
new file mode 100755
index 0000000..ebda3b1
--- /dev/null
+++ b/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_folddef.h
@@ -0,0 +1,1068 @@
+/* This is a generated file. DO NOT EDIT! */
+
+static const FoldFunc fold_func[] = {
+  fold_kfold_numarith,
+  fold_kfold_ldexp,
+  fold_kfold_fpmath,
+  fold_kfold_numpow,
+  fold_kfold_numcomp,
+  fold_kfold_intarith,
+  fold_kfold_intovarith,
+  fold_kfold_bnot,
+  fold_kfold_bswap,
+  fold_kfold_intcomp,
+  fold_kfold_intcomp0,
+  fold_kfold_int64arith,
+  fold_kfold_int64arith2,
+  fold_kfold_int64shift,
+  fold_kfold_bnot64,
+  fold_kfold_bswap64,
+  fold_kfold_int64comp,
+  fold_kfold_int64comp0,
+  fold_kfold_snew_kptr,
+  fold_kfold_snew_empty,
+  fold_kfold_strref,
+  fold_kfold_strref_snew,
+  fold_kfold_strcmp,
+  fold_kfold_add_kgc,
+  fold_kfold_add_kptr,
+  fold_kfold_add_kright,
+  fold_kfold_tobit,
+  fold_kfold_conv_kint_num,
+  fold_kfold_conv_kintu32_num,
+  fold_kfold_conv_kint_ext,
+  fold_kfold_conv_kint_i64,
+  fold_kfold_conv_kint64_num_i64,
+  fold_kfold_conv_kint64_num_u64,
+  fold_kfold_conv_kint64_int_i64,
+  fold_kfold_conv_knum_int_num,
+  fold_kfold_conv_knum_u32_num,
+  fold_kfold_conv_knum_i64_num,
+  fold_kfold_conv_knum_u64_num,
+  fold_kfold_tostr_knum,
+  fold_kfold_tostr_kint,
+  fold_kfold_strto,
+  lj_opt_cse,
+  fold_kfold_kref,
+  fold_shortcut_round,
+  fold_shortcut_left,
+  fold_shortcut_dropleft,
+  fold_shortcut_leftleft,
+  fold_simplify_numadd_negx,
+  fold_simplify_numadd_xneg,
+  fold_simplify_numsub_k,
+  fold_simplify_numsub_negk,
+  fold_simplify_numsub_xneg,
+  fold_simplify_nummuldiv_k,
+  fold_simplify_nummuldiv_negk,
+  fold_simplify_nummuldiv_negneg,
+  fold_simplify_numpow_xk,
+  fold_simplify_numpow_kx,
+  fold_shortcut_conv_num_int,
+  fold_simplify_conv_int_num,
+  fold_simplify_conv_i64_num,
+  fold_simplify_conv_int_i64,
+  fold_simplify_conv_flt_num,
+  fold_simplify_tobit_conv,
+  fold_simplify_floor_conv,
+  fold_simplify_conv_sext,
+  fold_simplify_conv_narrow,
+  fold_cse_conv,
+  fold_narrow_convert,
+  fold_simplify_intadd_k,
+  fold_simplify_intmul_k,
+  fold_simplify_intsub_k,
+  fold_simplify_intsub_kleft,
+  fold_simplify_intadd_k64,
+  fold_simplify_intsub_k64,
+  fold_simplify_intmul_k32,
+  fold_simplify_intmul_k64,
+  fold_simplify_intmod_k,
+  fold_simplify_intmod_kleft,
+  fold_simplify_intsub,
+  fold_simplify_intsubadd_leftcancel,
+  fold_simplify_intsubsub_leftcancel,
+  fold_simplify_intsubsub_rightcancel,
+  fold_simplify_intsubadd_rightcancel,
+  fold_simplify_intsubaddadd_cancel,
+  fold_simplify_band_k,
+  fold_simplify_bor_k,
+  fold_simplify_bxor_k,
+  fold_simplify_shift_ik,
+  fold_simplify_shift_andk,
+  fold_simplify_shift1_ki,
+  fold_simplify_shift2_ki,
+  fold_simplify_shiftk_andk,
+  fold_simplify_andk_shiftk,
+  fold_reassoc_intarith_k,
+  fold_reassoc_intarith_k64,
+  fold_reassoc_dup,
+  fold_reassoc_bxor,
+  fold_reassoc_shift,
+  fold_reassoc_minmax_k,
+  fold_reassoc_minmax_left,
+  fold_reassoc_minmax_right,
+  fold_abc_fwd,
+  fold_abc_k,
+  fold_abc_invar,
+  fold_comm_swap,
+  fold_comm_equal,
+  fold_comm_comp,
+  fold_comm_dup,
+  fold_comm_bxor,
+  fold_merge_eqne_snew_kgc,
+  lj_opt_fwd_aload,
+  fold_kfold_hload_kkptr,
+  lj_opt_fwd_hload,
+  lj_opt_fwd_uload,
+  lj_opt_fwd_tab_len,
+  fold_cse_uref,
+  lj_opt_fwd_hrefk,
+  fold_fwd_href_tnew,
+  fold_fwd_href_tdup,
+  fold_fload_tab_tnew_asize,
+  fold_fload_tab_tnew_hmask,
+  fold_fload_tab_tdup_asize,
+  fold_fload_tab_tdup_hmask,
+  fold_fload_tab_ah,
+  fold_fload_str_len_kgc,
+  fold_fload_str_len_snew,
+  fold_fload_cdata_typeid_kgc,
+  fold_fload_cdata_int64_kgc,
+  fold_fload_cdata_typeid_cnew,
+  fold_fload_cdata_ptr_int64_cnew,
+  lj_opt_cse,
+  lj_opt_fwd_fload,
+  fold_fwd_sload,
+  fold_xload_kptr,
+  lj_opt_fwd_xload,
+  fold_barrier_tab,
+  fold_barrier_tnew_tdup,
+  lj_opt_dse_ahstore,
+  lj_opt_dse_ustore,
+  lj_opt_dse_fstore,
+  lj_opt_dse_xstore,
+  lj_ir_emit
+};
+
+static const uint32_t fold_hash[916] = {
+0xffffffff,
+0xffffffff,
+0x5b4c8016,
+0x0d4e7016,
+0xffffffff,
+0x1000701c,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x29110c1a,
+0xffffffff,
+0xffffffff,
+0x5b488016,
+0x0d4a7016,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x7b87fc07,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x0d467016,
+0xffffffff,
+0x5a4c73ff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x5153fc29,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x5d408016,
+0xffffffff,
+0x594873ff,
+0x8187440f,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x8287fc0f,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6715ffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x2a11fc1a,
+0xffffffff,
+0x1daa5a70,
+0xffffffff,
+0xffffffff,
+0x0a0bfc16,
+0x5c408c16,
+0x6911ffff,
+0x8db7ffff,
+0xffffffff,
+0xffffffff,
+0x1caa59d4,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6a0dffff,
+0x2b68d002,
+0xffffffff,
+0x3cab5695,
+0xffffffff,
+0x41aaa675,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x27ae5800,
+0xffffffff,
+0x6a09ffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x7f865c0f,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6a05ffff,
+0x42abffff,
+0x5e44881c,
+0x5d50a016,
+0x066c5816,
+0x00646c1b,
+0x75753bff,
+0x1951fc18,
+0x6264c81b,
+0x1850641c,
+0xffffffff,
+0x6a01ffff,
+0x87a7ffff,
+0x4953fc1c,
+0x8da80000,
+0x4f52a3ff,
+0x00606c1b,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x5d428416,
+0x88a53800,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x05645816,
+0xffffffff,
+0x005c6c1b,
+0x20aa71d6,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x1399fc16,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x157f33ff,
+0xffffffff,
+0xffffffff,
+0x584dfc20,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x8d9bffff,
+0xffffffff,
+0x055c5816,
+0xffffffff,
+0x00546c1b,
+0xffffffff,
+0xffffffff,
+0x5849fc20,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x8c97ffff,
+0x5543fc1c,
+0x05585816,
+0xffffffff,
+0x00506c1b,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x8a93ffff,
+0x26ae6c00,
+0x05545816,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x76753c17,
+0x41aaa695,
+0xffffffff,
+0x898fffff,
+0xffffffff,
+0x05505816,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x858867ff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x848bffff,
+0xffffffff,
+0x054c5816,
+0x79873c06,
+0x47525bff,
+0xffffffff,
+0x3f695401,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x8387ffff,
+0xffffffff,
+0x05485816,
+0xffffffff,
+0x5a4e5bff,
+0xffffffff,
+0xffffffff,
+0x6264c816,
+0x43aaa26e,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x05445816,
+0xffffffff,
+0x5a4a5bff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x3455fc1b,
+0x0c5a701c,
+0x6366cbff,
+0x0e3c7000,
+0xffffffff,
+0x05405816,
+0xffffffff,
+0x59465bff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x41aaa276,
+0x0c56701c,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x21aa7275,
+0x0b52701c,
+0x61489016,
+0x6465fc33,
+0x8d77ffff,
+0xffffffff,
+0x7b87fc05,
+0xffffffff,
+0xffffffff,
+0x2a126bff,
+0x385a6fff,
+0xffffffff,
+0x446dfc16,
+0xffffffff,
+0x7473ffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x7d873000,
+0xffffffff,
+0x5c409016,
+0x686fffff,
+0x8187440d,
+0xffffffff,
+0xffffffff,
+0x3554b81b,
+0x8287fc0d,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x686bffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x8d9ffc00,
+0x737a5fff,
+0x41aaaa75,
+0xffffffff,
+0xffffffff,
+0x5e40801c,
+0x0b42701c,
+0x6b67ffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x2b68d000,
+0xffffffff,
+0xffffffff,
+0x6d133017,
+0xffffffff,
+0xffffffff,
+0x4c59fc16,
+0xffffffff,
+0xffffffff,
+0x110bfc1c,
+0x3aab566e,
+0xffffffff,
+0x5052a7ff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6515fc28,
+0x4a55fc16,
+0x7f865c0d,
+0x88a53c00,
+0x41aaa296,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x4451fc16,
+0xffffffff,
+0x60448bff,
+0x21aa7295,
+0xffffffff,
+0x3cab5676,
+0x04106c1b,
+0xffffffff,
+0x78873807,
+0xffffffff,
+0xffffffff,
+0x574dfc16,
+0xffffffff,
+0x4e53ffff,
+0xffffffff,
+0x09145816,
+0xffffffff,
+0x040c6c1b,
+0x8287fc00,
+0x5e50a01c,
+0x6467fc32,
+0xffffffff,
+0x5749fc16,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x2a105816,
+0x2e3e7c00,
+0x04086c1b,
+0x7083fc00,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x5645fc16,
+0xffffffff,
+0x22aa6e6e,
+0x5e42841c,
+0x614e9c16,
+0x090c5816,
+0x04046c1b,
+0x1eaa5ab3,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x5441fc16,
+0x41aaaa95,
+0xffffffff,
+0x5352a028,
+0x09085816,
+0x17505c16,
+0x04006c1b,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6b43ffff,
+0xffffffff,
+0x09045816,
+0xffffffff,
+0x43aaa2ae,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x083e5800,
+0x7c865c00,
+0xffffffff,
+0x76753c15,
+0x3051fc2e,
+0x09005816,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x3aab568e,
+0xffffffff,
+0x43aaa66e,
+0xffffffff,
+0x1daa5a71,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x2a12701c,
+0x5f66cfff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x3cab5696,
+0xffffffff,
+0x100e701c,
+0x41aaa676,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x2a125c17,
+0x3654b82e,
+0x100a701c,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x1006701c,
+0xffffffff,
+0x1951fc19,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x23aa6e8e,
+0xffffffff,
+0x5b4e8016,
+0xffffffff,
+0x1eaa5ad3,
+0x1002701c,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x29130c1a,
+0xffffffff,
+0xffffffff,
+0x0d4c7016,
+0xffffffff,
+0x475273ff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x5b468016,
+0x0d487016,
+0x5a4e73ff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x5d54a816,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x5a4a73ff,
+0x6615fc16,
+0x3bab56ae,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x594673ff,
+0xffffffff,
+0x61468c16,
+0x8d17ffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x2a13fc1a,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6913ffff,
+0x40abfeb3,
+0x8db9ffff,
+0x41aaa696,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6a0fffff,
+0x8db5ffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x7a873c07,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6a0bffff,
+0x3f695402,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x24aa6eae,
+0xffffffff,
+0xffffffff,
+0x6a07ffff,
+0xffffffff,
+0xffffffff,
+0x066e5816,
+0xffffffff,
+0x00666c1b,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6a03ffff,
+0xffffffff,
+0x4b55fc1c,
+0x066a5816,
+0xffffffff,
+0x00626c1b,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x4851fc1c,
+0x05665816,
+0x18506016,
+0x005e6c1b,
+0x12986416,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x8da1ffff,
+0xffffffff,
+0x3bab56ce,
+0xffffffff,
+0x43aaa6ae,
+0xffffffff,
+0xffffffff,
+0x584ffc20,
+0x7b87fc06,
+0xffffffff,
+0x5f4287ff,
+0x8d9dffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x00566c1b,
+0xffffffff,
+0xffffffff,
+0x584bfc20,
+0x5253fc28,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x5645fc1c,
+0xffffffff,
+0x40abfed3,
+0x00526c1b,
+0x8187440e,
+0xffffffff,
+0x5847fc20,
+0x8287fc0e,
+0xffffffff,
+0xffffffff,
+0x8b95ffff,
+0x2e3c7800,
+0x5441fc1c,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x17505c1c,
+0xffffffff,
+0xffffffff,
+0x41aaaa76,
+0xffffffff,
+0x614c9816,
+0x8991ffff,
+0x1daa5a6f,
+0x05525816,
+0x4d585bff,
+0xffffffff,
+0x8087400c,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x1baa59d3,
+0x828dffff,
+0x25aa6ece,
+0x054e5816,
+0x76753c1b,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x2b68d001,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x8689ffff,
+0xffffffff,
+0x054a5816,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x43aca01b,
+0x05465816,
+0x7f865c0e,
+0x5a4c5bff,
+0x39ab55d3,
+0x01626c16,
+0x02686fff,
+0x3457fc1b,
+0xffffffff,
+0xffffffff,
+0x0f3e7000,
+0x3dab55ae,
+0x05425816,
+0x1951fc17,
+0x59485bff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x3153fc1b,
+0x0c58701c,
+0x5f64cbff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x035a6c16,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x0b54701c,
+0xffffffff,
+0x8779ffff,
+0x1faa71d5,
+0xffffffff,
+0xffffffff,
+0x2d5eb81b,
+0x72b5fc08,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x0b50701c,
+0x456ffc16,
+0x7b75ffff,
+0xffffffff,
+0xffffffff,
+0x147e5c16,
+0xffffffff,
+0xffffffff,
+0x2a106bff,
+0xffffffff,
+0x1eaa5ab4,
+0x446bfc16,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x41aaaa96,
+0xffffffff,
+0x3556b81b,
+0x87a5fc00,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x4e6dffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x3252b81b,
+0xffffffff,
+0x5e54a81c,
+0xffffffff,
+0xffffffff,
+0x0b44701c,
+0x28b05c00,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x73785fff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x0b40701c,
+0xffffffff,
+0x6b65ffff,
+0xffffffff,
+0xffffffff,
+0x1daa5a72,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6266cc1b,
+0xffffffff,
+0x375bfc16,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x3f695400,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6d113017,
+0x3ead541b,
+0xffffffff,
+0x5d448816,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x18506416,
+0xffffffff,
+0xffffffff,
+0x16b37400,
+0xffffffff,
+0x4653fc16,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x04126c1b,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x574ffc16,
+0xffffffff,
+0x6855ffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x040e6c1b,
+0x41aaa275,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x574bfc16,
+0x6f826400,
+0x6851ffff,
+0x1eaa5ad4,
+0x2a125816,
+0xffffffff,
+0x040a6c1b,
+0x7185fc00,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x5747fc16,
+0x7b87fc04,
+0xffffffff,
+0xffffffff,
+0x090e5816,
+0xffffffff,
+0x04066c1b,
+0x6e81fc00,
+0x1aac6c1b,
+0x1850601c,
+0x2e5cbbff,
+0x5543fc16,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x090a5816,
+0xffffffff,
+0x04026c1b,
+0xffffffff,
+0xffffffff,
+0x8087440c,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6c45ffff,
+0x8287fc0c,
+0x09065816,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x6b41ffff,
+0x3353fc2e,
+0x09025816,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x2f50bbff,
+0x073c5800,
+0x6266cc16,
+0x5f4083ff,
+0xffffffff,
+0xffffffff,
+0x43aca41b,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x2a10701c,
+0x6364cfff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x7e865c0c,
+0xffffffff,
+0xffffffff,
+0x3656b82e,
+0x41aaa295,
+0x100c701c,
+0x614a9416,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x2c5ebc1b,
+0xffffffff,
+0x2a105c17,
+0xffffffff,
+0x1008701c,
+0x3cab5675,
+0xffffffff,
+0xffffffff,
+0x77873806,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0x1004701c,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff,
+0xffffffff
+};
+
+#define fold_hashkey(k)	(lj_rol(lj_rol((k),17)-(k),16)%915)
+
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_libdef.h b/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_libdef.h
new file mode 100755
index 0000000..bd7a02d
--- /dev/null
+++ b/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_libdef.h
@@ -0,0 +1,393 @@
+/* This is a generated file. DO NOT EDIT! */
+
+#ifdef LJLIB_MODULE_base
+#undef LJLIB_MODULE_base
+static const lua_CFunction lj_lib_cf_base[] = {
+  lj_ffh_assert,
+  lj_ffh_next,
+  lj_ffh_pairs,
+  lj_ffh_ipairs_aux,
+  lj_ffh_ipairs,
+  lj_ffh_setmetatable,
+  lj_cf_getfenv,
+  lj_cf_setfenv,
+  lj_ffh_rawget,
+  lj_cf_rawset,
+  lj_cf_rawequal,
+  lj_cf_unpack,
+  lj_cf_select,
+  lj_ffh_tonumber,
+  lj_ffh_tostring,
+  lj_cf_error,
+  lj_ffh_pcall,
+  lj_cf_loadfile,
+  lj_cf_load,
+  lj_cf_loadstring,
+  lj_cf_dofile,
+  lj_cf_gcinfo,
+  lj_cf_collectgarbage,
+  lj_cf_newproxy,
+  lj_cf_print
+};
+static const uint8_t lj_lib_init_base[] = {
+2,0,28,70,97,115,115,101,114,116,195,110,105,108,199,98,111,111,108,101,97,
+110,252,1,200,117,115,101,114,100,97,116,97,198,115,116,114,105,110,103,197,
+117,112,118,97,108,198,116,104,114,101,97,100,197,112,114,111,116,111,200,102,
+117,110,99,116,105,111,110,197,116,114,97,99,101,197,99,100,97,116,97,197,116,
+97,98,108,101,252,9,198,110,117,109,98,101,114,132,116,121,112,101,68,110,101,
+120,116,253,69,112,97,105,114,115,64,253,70,105,112,97,105,114,115,140,103,
+101,116,109,101,116,97,116,97,98,108,101,76,115,101,116,109,101,116,97,116,
+97,98,108,101,7,103,101,116,102,101,110,118,7,115,101,116,102,101,110,118,70,
+114,97,119,103,101,116,6,114,97,119,115,101,116,8,114,97,119,101,113,117,97,
+108,6,117,110,112,97,99,107,6,115,101,108,101,99,116,72,116,111,110,117,109,
+98,101,114,195,110,105,108,197,102,97,108,115,101,196,116,114,117,101,72,116,
+111,115,116,114,105,110,103,5,101,114,114,111,114,69,112,99,97,108,108,134,
+120,112,99,97,108,108,8,108,111,97,100,102,105,108,101,4,108,111,97,100,10,
+108,111,97,100,115,116,114,105,110,103,6,100,111,102,105,108,101,6,103,99,105,
+110,102,111,14,99,111,108,108,101,99,116,103,97,114,98,97,103,101,252,2,8,110,
+101,119,112,114,111,120,121,200,116,111,115,116,114,105,110,103,5,112,114,105,
+110,116,252,3,200,95,86,69,82,83,73,79,78,250,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_coroutine
+#undef LJLIB_MODULE_coroutine
+static const lua_CFunction lj_lib_cf_coroutine[] = {
+  lj_cf_coroutine_status,
+  lj_cf_coroutine_running,
+  lj_cf_coroutine_create,
+  lj_ffh_coroutine_yield,
+  lj_ffh_coroutine_resume,
+  lj_cf_coroutine_wrap
+};
+static const uint8_t lj_lib_init_coroutine[] = {
+30,13,6,6,115,116,97,116,117,115,7,114,117,110,110,105,110,103,6,99,114,101,
+97,116,101,69,121,105,101,108,100,70,114,101,115,117,109,101,254,4,119,114,
+97,112,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_math
+#undef LJLIB_MODULE_math
+static const lua_CFunction lj_lib_cf_math[] = {
+  lj_ffh_math_abs,
+  lj_ffh_math_sqrt,
+  lj_ffh_math_log,
+  lj_ffh_math_atan2,
+  lj_ffh_math_ldexp,
+  lj_ffh_math_min,
+  lj_cf_math_random,
+  lj_cf_math_randomseed
+};
+static const uint8_t lj_lib_init_math[] = {
+37,16,30,67,97,98,115,133,102,108,111,111,114,132,99,101,105,108,68,115,113,
+114,116,133,108,111,103,49,48,131,101,120,112,131,115,105,110,131,99,111,115,
+131,116,97,110,132,97,115,105,110,132,97,99,111,115,132,97,116,97,110,132,115,
+105,110,104,132,99,111,115,104,132,116,97,110,104,133,102,114,101,120,112,132,
+109,111,100,102,67,108,111,103,251,248,193,99,26,220,165,76,64,131,100,101,
+103,251,57,157,82,162,70,223,145,63,131,114,97,100,69,97,116,97,110,50,131,
+112,111,119,132,102,109,111,100,69,108,100,101,120,112,67,109,105,110,131,109,
+97,120,251,24,45,68,84,251,33,9,64,194,112,105,250,251,0,0,0,0,0,0,240,127,
+196,104,117,103,101,250,252,2,6,114,97,110,100,111,109,252,2,10,114,97,110,
+100,111,109,115,101,101,100,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_bit
+#undef LJLIB_MODULE_bit
+static const lua_CFunction lj_lib_cf_bit[] = {
+  lj_ffh_bit_tobit,
+  lj_ffh_bit_lshift,
+  lj_ffh_bit_band,
+  lj_cf_bit_tohex
+};
+static const uint8_t lj_lib_init_bit[] = {
+65,42,12,69,116,111,98,105,116,132,98,110,111,116,133,98,115,119,97,112,70,
+108,115,104,105,102,116,134,114,115,104,105,102,116,135,97,114,115,104,105,
+102,116,131,114,111,108,131,114,111,114,68,98,97,110,100,131,98,111,114,132,
+98,120,111,114,5,116,111,104,101,120,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_string
+#undef LJLIB_MODULE_string
+static const lua_CFunction lj_lib_cf_string[] = {
+  lj_ffh_string_len,
+  lj_ffh_string_byte,
+  lj_ffh_string_char,
+  lj_ffh_string_sub,
+  lj_ffh_string_rep,
+  lj_ffh_string_reverse,
+  lj_cf_string_dump,
+  lj_cf_string_find,
+  lj_cf_string_match,
+  lj_cf_string_gmatch,
+  lj_cf_string_gsub,
+  lj_cf_string_format
+};
+static const uint8_t lj_lib_init_string[] = {
+77,53,14,67,108,101,110,68,98,121,116,101,68,99,104,97,114,67,115,117,98,67,
+114,101,112,71,114,101,118,101,114,115,101,133,108,111,119,101,114,133,117,
+112,112,101,114,4,100,117,109,112,4,102,105,110,100,5,109,97,116,99,104,254,
+6,103,109,97,116,99,104,4,103,115,117,98,6,102,111,114,109,97,116,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_table
+#undef LJLIB_MODULE_table
+static const lua_CFunction lj_lib_cf_table[] = {
+  lj_cf_table_foreachi,
+  lj_cf_table_foreach,
+  lj_ffh_table_getn,
+  lj_cf_table_maxn,
+  lj_cf_table_insert,
+  lj_cf_table_remove,
+  lj_cf_table_concat,
+  lj_cf_table_sort
+};
+static const uint8_t lj_lib_init_table[] = {
+92,61,8,8,102,111,114,101,97,99,104,105,7,102,111,114,101,97,99,104,68,103,
+101,116,110,4,109,97,120,110,6,105,110,115,101,114,116,6,114,101,109,111,118,
+101,6,99,111,110,99,97,116,4,115,111,114,116,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_io_method
+#undef LJLIB_MODULE_io_method
+static const lua_CFunction lj_lib_cf_io_method[] = {
+  lj_cf_io_method_close,
+  lj_cf_io_method_read,
+  lj_cf_io_method_write,
+  lj_cf_io_method_flush,
+  lj_cf_io_method_seek,
+  lj_cf_io_method_setvbuf,
+  lj_cf_io_method_lines,
+  lj_cf_io_method___gc,
+  lj_cf_io_method___tostring
+};
+static const uint8_t lj_lib_init_io_method[] = {
+100,62,10,5,99,108,111,115,101,4,114,101,97,100,5,119,114,105,116,101,5,102,
+108,117,115,104,4,115,101,101,107,7,115,101,116,118,98,117,102,5,108,105,110,
+101,115,4,95,95,103,99,10,95,95,116,111,115,116,114,105,110,103,252,1,199,95,
+95,105,110,100,101,120,250,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_io
+#undef LJLIB_MODULE_io
+static const lua_CFunction lj_lib_cf_io[] = {
+  lj_cf_io_open,
+  lj_cf_io_popen,
+  lj_cf_io_tmpfile,
+  lj_cf_io_close,
+  lj_cf_io_read,
+  lj_cf_io_write,
+  lj_cf_io_flush,
+  lj_cf_io_input,
+  lj_cf_io_output,
+  lj_cf_io_lines,
+  lj_cf_io_type
+};
+static const uint8_t lj_lib_init_io[] = {
+109,62,12,252,2,192,250,4,111,112,101,110,5,112,111,112,101,110,7,116,109,112,
+102,105,108,101,5,99,108,111,115,101,4,114,101,97,100,5,119,114,105,116,101,
+5,102,108,117,115,104,5,105,110,112,117,116,6,111,117,116,112,117,116,5,108,
+105,110,101,115,4,116,121,112,101,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_os
+#undef LJLIB_MODULE_os
+static const lua_CFunction lj_lib_cf_os[] = {
+  lj_cf_os_execute,
+  lj_cf_os_remove,
+  lj_cf_os_rename,
+  lj_cf_os_tmpname,
+  lj_cf_os_getenv,
+  lj_cf_os_exit,
+  lj_cf_os_clock,
+  lj_cf_os_date,
+  lj_cf_os_time,
+  lj_cf_os_difftime,
+  lj_cf_os_setlocale
+};
+static const uint8_t lj_lib_init_os[] = {
+120,62,11,7,101,120,101,99,117,116,101,6,114,101,109,111,118,101,6,114,101,
+110,97,109,101,7,116,109,112,110,97,109,101,6,103,101,116,101,110,118,4,101,
+120,105,116,5,99,108,111,99,107,4,100,97,116,101,4,116,105,109,101,8,100,105,
+102,102,116,105,109,101,9,115,101,116,108,111,99,97,108,101,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_debug
+#undef LJLIB_MODULE_debug
+static const lua_CFunction lj_lib_cf_debug[] = {
+  lj_cf_debug_getregistry,
+  lj_cf_debug_getmetatable,
+  lj_cf_debug_setmetatable,
+  lj_cf_debug_getfenv,
+  lj_cf_debug_setfenv,
+  lj_cf_debug_getinfo,
+  lj_cf_debug_getlocal,
+  lj_cf_debug_setlocal,
+  lj_cf_debug_getupvalue,
+  lj_cf_debug_setupvalue,
+  lj_cf_debug_upvalueid,
+  lj_cf_debug_upvaluejoin,
+  lj_cf_debug_sethook,
+  lj_cf_debug_gethook,
+  lj_cf_debug_debug,
+  lj_cf_debug_traceback
+};
+static const uint8_t lj_lib_init_debug[] = {
+131,62,16,11,103,101,116,114,101,103,105,115,116,114,121,12,103,101,116,109,
+101,116,97,116,97,98,108,101,12,115,101,116,109,101,116,97,116,97,98,108,101,
+7,103,101,116,102,101,110,118,7,115,101,116,102,101,110,118,7,103,101,116,105,
+110,102,111,8,103,101,116,108,111,99,97,108,8,115,101,116,108,111,99,97,108,
+10,103,101,116,117,112,118,97,108,117,101,10,115,101,116,117,112,118,97,108,
+117,101,9,117,112,118,97,108,117,101,105,100,11,117,112,118,97,108,117,101,
+106,111,105,110,7,115,101,116,104,111,111,107,7,103,101,116,104,111,111,107,
+5,100,101,98,117,103,9,116,114,97,99,101,98,97,99,107,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_jit
+#undef LJLIB_MODULE_jit
+static const lua_CFunction lj_lib_cf_jit[] = {
+  lj_cf_jit_on,
+  lj_cf_jit_off,
+  lj_cf_jit_flush,
+  lj_cf_jit_status,
+  lj_cf_jit_attach
+};
+static const uint8_t lj_lib_init_jit[] = {
+147,62,9,2,111,110,3,111,102,102,5,102,108,117,115,104,6,115,116,97,116,117,
+115,6,97,116,116,97,99,104,252,5,194,111,115,250,252,4,196,97,114,99,104,250,
+252,3,203,118,101,114,115,105,111,110,95,110,117,109,250,252,2,199,118,101,
+114,115,105,111,110,250,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_jit_util
+#undef LJLIB_MODULE_jit_util
+static const lua_CFunction lj_lib_cf_jit_util[] = {
+  lj_cf_jit_util_funcinfo,
+  lj_cf_jit_util_funcbc,
+  lj_cf_jit_util_funck,
+  lj_cf_jit_util_funcuvname,
+  lj_cf_jit_util_traceinfo,
+  lj_cf_jit_util_traceir,
+  lj_cf_jit_util_tracek,
+  lj_cf_jit_util_tracesnap,
+  lj_cf_jit_util_tracemc,
+  lj_cf_jit_util_traceexitstub,
+  lj_cf_jit_util_ircalladdr
+};
+static const uint8_t lj_lib_init_jit_util[] = {
+152,62,11,8,102,117,110,99,105,110,102,111,6,102,117,110,99,98,99,5,102,117,
+110,99,107,10,102,117,110,99,117,118,110,97,109,101,9,116,114,97,99,101,105,
+110,102,111,7,116,114,97,99,101,105,114,6,116,114,97,99,101,107,9,116,114,97,
+99,101,115,110,97,112,7,116,114,97,99,101,109,99,13,116,114,97,99,101,101,120,
+105,116,115,116,117,98,10,105,114,99,97,108,108,97,100,100,114,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_jit_opt
+#undef LJLIB_MODULE_jit_opt
+static const lua_CFunction lj_lib_cf_jit_opt[] = {
+  lj_cf_jit_opt_start
+};
+static const uint8_t lj_lib_init_jit_opt[] = {
+163,62,1,5,115,116,97,114,116,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_ffi_meta
+#undef LJLIB_MODULE_ffi_meta
+static const lua_CFunction lj_lib_cf_ffi_meta[] = {
+  lj_cf_ffi_meta___index,
+  lj_cf_ffi_meta___newindex,
+  lj_cf_ffi_meta___eq,
+  lj_cf_ffi_meta___len,
+  lj_cf_ffi_meta___lt,
+  lj_cf_ffi_meta___le,
+  lj_cf_ffi_meta___concat,
+  lj_cf_ffi_meta___call,
+  lj_cf_ffi_meta___add,
+  lj_cf_ffi_meta___sub,
+  lj_cf_ffi_meta___mul,
+  lj_cf_ffi_meta___div,
+  lj_cf_ffi_meta___mod,
+  lj_cf_ffi_meta___pow,
+  lj_cf_ffi_meta___unm,
+  lj_cf_ffi_meta___tostring,
+  lj_cf_ffi_meta___pairs,
+  lj_cf_ffi_meta___ipairs
+};
+static const uint8_t lj_lib_init_ffi_meta[] = {
+164,62,19,7,95,95,105,110,100,101,120,10,95,95,110,101,119,105,110,100,101,
+120,4,95,95,101,113,5,95,95,108,101,110,4,95,95,108,116,4,95,95,108,101,8,95,
+95,99,111,110,99,97,116,6,95,95,99,97,108,108,5,95,95,97,100,100,5,95,95,115,
+117,98,5,95,95,109,117,108,5,95,95,100,105,118,5,95,95,109,111,100,5,95,95,
+112,111,119,5,95,95,117,110,109,10,95,95,116,111,115,116,114,105,110,103,7,
+95,95,112,97,105,114,115,8,95,95,105,112,97,105,114,115,195,102,102,105,203,
+95,95,109,101,116,97,116,97,98,108,101,250,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_ffi_clib
+#undef LJLIB_MODULE_ffi_clib
+static const lua_CFunction lj_lib_cf_ffi_clib[] = {
+  lj_cf_ffi_clib___index,
+  lj_cf_ffi_clib___newindex,
+  lj_cf_ffi_clib___gc
+};
+static const uint8_t lj_lib_init_ffi_clib[] = {
+182,62,3,7,95,95,105,110,100,101,120,10,95,95,110,101,119,105,110,100,101,120,
+4,95,95,103,99,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_ffi_callback
+#undef LJLIB_MODULE_ffi_callback
+static const lua_CFunction lj_lib_cf_ffi_callback[] = {
+  lj_cf_ffi_callback_free,
+  lj_cf_ffi_callback_set
+};
+static const uint8_t lj_lib_init_ffi_callback[] = {
+185,62,3,4,102,114,101,101,3,115,101,116,252,1,199,95,95,105,110,100,101,120,
+250,255
+};
+#endif
+
+#ifdef LJLIB_MODULE_ffi
+#undef LJLIB_MODULE_ffi
+static const lua_CFunction lj_lib_cf_ffi[] = {
+  lj_cf_ffi_cdef,
+  lj_cf_ffi_new,
+  lj_cf_ffi_cast,
+  lj_cf_ffi_typeof,
+  lj_cf_ffi_istype,
+  lj_cf_ffi_sizeof,
+  lj_cf_ffi_alignof,
+  lj_cf_ffi_offsetof,
+  lj_cf_ffi_errno,
+  lj_cf_ffi_string,
+  lj_cf_ffi_copy,
+  lj_cf_ffi_fill,
+  lj_cf_ffi_abi,
+  lj_cf_ffi_metatype,
+  lj_cf_ffi_gc,
+  lj_cf_ffi_load
+};
+static const uint8_t lj_lib_init_ffi[] = {
+187,62,22,4,99,100,101,102,3,110,101,119,4,99,97,115,116,6,116,121,112,101,
+111,102,6,105,115,116,121,112,101,6,115,105,122,101,111,102,7,97,108,105,103,
+110,111,102,8,111,102,102,115,101,116,111,102,5,101,114,114,110,111,6,115,116,
+114,105,110,103,4,99,111,112,121,4,102,105,108,108,3,97,98,105,252,8,192,250,
+8,109,101,116,97,116,121,112,101,252,7,192,250,2,103,99,252,5,192,250,4,108,
+111,97,100,252,4,193,67,250,252,3,194,111,115,250,252,2,196,97,114,99,104,250,
+255
+};
+#endif
+
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_recdef.h b/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_recdef.h
new file mode 100755
index 0000000..76a0af4
--- /dev/null
+++ b/scripting/lua/luajit/LuaJIT-2.0.1/src/lj_recdef.h
@@ -0,0 +1,263 @@
+/* This is a generated file. DO NOT EDIT! */
+
+static const uint16_t recff_idmap[] = {
+0,
+0x0100,
+0x0200,
+0x0300,
+0,
+0,
+0x0400,
+0x0500,
+0x0600,
+0x0700,
+0,
+0,
+0x0800,
+0x0900,
+0x0a00,
+0,
+0x0b00,
+0x0c00,
+0x0d00,
+0,
+0x0e00,
+0x0f00,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0x1000,
+0x1100+(IRFPM_FLOOR),
+0x1100+(IRFPM_CEIL),
+0x1200+(IRFPM_SQRT),
+0x1200+(IRFPM_LOG10),
+0x1200+(IRFPM_EXP),
+0x1200+(IRFPM_SIN),
+0x1200+(IRFPM_COS),
+0x1200+(IRFPM_TAN),
+0x1300+(FF_math_asin),
+0x1300+(FF_math_acos),
+0x1300+(FF_math_atan),
+0x1400+(IRCALL_sinh),
+0x1400+(IRCALL_cosh),
+0x1400+(IRCALL_tanh),
+0,
+0x1500,
+0x1600,
+0x1700,
+0x1700,
+0x1800,
+0x1900,
+0,
+0x1a00,
+0x1b00+(IR_MIN),
+0x1b00+(IR_MAX),
+0x1c00,
+0,
+0x1d00+(IR_TOBIT),
+0x1d00+(IR_BNOT),
+0x1d00+(IR_BSWAP),
+0x1e00+(IR_BSHL),
+0x1e00+(IR_BSHR),
+0x1e00+(IR_BSAR),
+0x1e00+(IR_BROL),
+0x1e00+(IR_BROR),
+0x1f00+(IR_BAND),
+0x1f00+(IR_BOR),
+0x1f00+(IR_BXOR),
+0,
+0x2000,
+0x2100+(0),
+0,
+0x2100+(1),
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0x2200,
+0,
+0x2300,
+0x2400,
+0,
+0,
+0,
+0,
+0x2500+(0),
+0x2600+(0),
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0x2500+(GCROOT_IO_OUTPUT),
+0x2600+(GCROOT_IO_OUTPUT),
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0,
+0x2700+(0),
+0x2700+(1),
+0x2800+(MM_eq),
+0x2800+(MM_len),
+0x2800+(MM_lt),
+0x2800+(MM_le),
+0x2800+(MM_concat),
+0x2900,
+0x2800+(MM_add),
+0x2800+(MM_sub),
+0x2800+(MM_mul),
+0x2800+(MM_div),
+0x2800+(MM_mod),
+0x2800+(MM_pow),
+0x2800+(MM_unm),
+0,
+0,
+0,
+0x2a00+(1),
+0x2a00+(0),
+0,
+0,
+0,
+0,
+0x2b00,
+0x2b00,
+0x2c00,
+0x2d00,
+0x2e00+(FF_ffi_sizeof),
+0x2e00+(FF_ffi_alignof),
+0x2e00+(FF_ffi_offsetof),
+0x2f00,
+0x3000,
+0x3100,
+0x3200,
+0x3300,
+0,
+0x3400
+};
+
+static const RecordFunc recff_func[] = {
+recff_nyi,
+recff_c,
+recff_assert,
+recff_type,
+recff_ipairs_aux,
+recff_ipairs,
+recff_getmetatable,
+recff_setmetatable,
+recff_rawget,
+recff_rawset,
+recff_rawequal,
+recff_select,
+recff_tonumber,
+recff_tostring,
+recff_pcall,
+recff_xpcall,
+recff_math_abs,
+recff_math_round,
+recff_math_unary,
+recff_math_atrig,
+recff_math_htrig,
+recff_math_modf,
+recff_math_log,
+recff_math_degrad,
+recff_math_atan2,
+recff_math_pow,
+recff_math_ldexp,
+recff_math_minmax,
+recff_math_random,
+recff_bit_unary,
+recff_bit_shift,
+recff_bit_nary,
+recff_string_len,
+recff_string_range,
+recff_table_getn,
+recff_table_insert,
+recff_table_remove,
+recff_io_write,
+recff_io_flush,
+recff_cdata_index,
+recff_cdata_arith,
+recff_cdata_call,
+recff_clib_index,
+recff_ffi_new,
+recff_ffi_typeof,
+recff_ffi_istype,
+recff_ffi_xof,
+recff_ffi_errno,
+recff_ffi_string,
+recff_ffi_copy,
+recff_ffi_fill,
+recff_ffi_abi,
+recff_ffi_gc
+};
+
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/lua51.dll b/scripting/lua/luajit/LuaJIT-2.0.1/src/lua51.dll
new file mode 100755
index 0000000..8c3c72b
Binary files /dev/null and b/scripting/lua/luajit/LuaJIT-2.0.1/src/lua51.dll differ
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/lua51.exp b/scripting/lua/luajit/LuaJIT-2.0.1/src/lua51.exp
new file mode 100755
index 0000000..5125b59
Binary files /dev/null and b/scripting/lua/luajit/LuaJIT-2.0.1/src/lua51.exp differ
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/lua51.lib b/scripting/lua/luajit/LuaJIT-2.0.1/src/lua51.lib
new file mode 100755
index 0000000..3dbde0f
Binary files /dev/null and b/scripting/lua/luajit/LuaJIT-2.0.1/src/lua51.lib differ
diff --git a/scripting/lua/luajit/LuaJIT-2.0.1/src/luajit.exe b/scripting/lua/luajit/LuaJIT-2.0.1/src/luajit.exe
new file mode 100755
index 0000000..d0b4794
Binary files /dev/null and b/scripting/lua/luajit/LuaJIT-2.0.1/src/luajit.exe differ
diff --git a/scripting/lua/proj.android/Android.mk b/scripting/lua/proj.android/Android.mk
old mode 100644
new mode 100755
index ff53dfc..ed73e81
--- a/scripting/lua/proj.android/Android.mk
+++ b/scripting/lua/proj.android/Android.mk
@@ -6,6 +6,7 @@ LOCAL_MODULE    := cocos_lua_static
 LOCAL_MODULE_FILENAME := liblua
 
 LOCAL_SRC_FILES := ../cocos2dx_support/CCLuaBridge.cpp \
+          ../cocos2dx_support/LuaCocos2dExtension.cpp \
           ../cocos2dx_support/CCLuaEngine.cpp \
           ../cocos2dx_support/CCLuaStack.cpp \
           ../cocos2dx_support/CCLuaValue.cpp \
@@ -23,6 +24,15 @@ LOCAL_SRC_FILES := ../cocos2dx_support/CCLuaBridge.cpp \
           ../tolua/tolua_map.c \
           ../tolua/tolua_push.c \
           ../tolua/tolua_to.c \
+          ../crypt/md5lib.c \
+          ../crypt/md5.c \
+          ../crypt/ldes56.c \
+          ../crypt/des56.c \
+		../crypt/lua_zlib.c \
+          ../lfs/lfs.c \
+          ../cjson/lua_cjson.c \
+          ../cjson/strbuf.c \
+          ../cjson/fpconv.c \
           ../cocos2dx_support/tolua_fix.c
           
 LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/../luajit/include \
@@ -33,13 +43,19 @@ LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)/../luajit/include \
 LOCAL_C_INCLUDES := $(LOCAL_PATH)/ \
                     $(LOCAL_PATH)/../luajit/include \
                     $(LOCAL_PATH)/../tolua \
+                    $(LOCAL_PATH)/../crypt \
+                    $(LOCAL_PATH)/../lfs \
+                    $(LOCAL_PATH)/../cjson \
                     $(LOCAL_PATH)/../../../cocos2dx \
                     $(LOCAL_PATH)/../../../cocos2dx/include \
                     $(LOCAL_PATH)/../../../cocos2dx/platform \
                     $(LOCAL_PATH)/../../../cocos2dx/platform/android \
                     $(LOCAL_PATH)/../../../cocos2dx/kazmath/include \
                     $(LOCAL_PATH)/../../../CocosDenshion/include \
-                    $(LOCAL_PATH)/../../../extensions
+                    $(LOCAL_PATH)/../../../extensions \
+                    $(LOCAL_PATH)/../../../extensions/GUI/CCEditBox \
+                    $(LOCAL_PATH)/../../../extensions/Social \
+                    $(LOCAL_PATH)/../../../extensions/Utils
 
 LOCAL_WHOLE_STATIC_LIBRARIES := luajit_static
 LOCAL_WHOLE_STATIC_LIBRARIES += cocos_extension_static
diff --git a/scripting/lua/proj.win32/liblua.vcxproj b/scripting/lua/proj.win32/liblua.vcxproj
index 5deea30..73df87f 100644
--- a/scripting/lua/proj.win32/liblua.vcxproj
+++ b/scripting/lua/proj.win32/liblua.vcxproj
@@ -67,7 +67,7 @@
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
     <ClCompile>
       <Optimization>Disabled</Optimization>
-      <AdditionalIncludeDirectories>$(ProjectDir)..\..\..\cocos2dx;$(ProjectDir)..\..\..\cocos2dx\include;$(ProjectDir)..\..\..\cocos2dx\kazmath\include;$(ProjectDir)..\..\..\cocos2dx\platform\win32;$(ProjectDir)..\..\..\cocos2dx\platform\third_party\win32\OGLES;$(ProjectDir)..\..\..\cocos2dx\platform\third_party\win32\pthread;$(ProjectDir)..\..\..\CocosDenshion\include;$(ProjectDir)..\..\..\extensions;$(ProjectDir)..\..\..\extensions\network;$(ProjectDir)..\..\..\extensions\Social;$(ProjectDir)..\..\..\external\libwebsockets\win32\include;$(ProjectDir)..\tolua;$(ProjectDir)..\luajit\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>$(ProjectDir)..\..\..\cocos2dx;$(ProjectDir)..\..\..\cocos2dx\include;$(ProjectDir)..\..\..\cocos2dx\kazmath\include;$(ProjectDir)..\..\..\cocos2dx\platform\win32\;$(ProjectDir)..\..\..\cocos2dx\platform\third_party\win32\zlib;$(ProjectDir)..\..\..\cocos2dx\platform\third_party\win32\OGLES;$(ProjectDir)..\..\..\cocos2dx\platform\third_party\win32\pthread;$(ProjectDir)..\..\..\CocosDenshion\include;$(ProjectDir)..\..\..\extensions\GUI\CCEditBox;$(ProjectDir)..\..\..\extensions;$(ProjectDir)..\..\..\extensions\network;$(ProjectDir)..\..\..\extensions\Utils;$(ProjectDir)..\..\..\extensions\Social;$(ProjectDir)..\..\..\external\libwebsockets\win32\include;$(ProjectDir)..\tolua;$(ProjectDir)..\crypt;$(ProjectDir)..\lfs;$(ProjectDir)..\cjson;$(ProjectDir)..\luajit\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>WIN32;_WINDOWS;%(PreprocessorDefinitions);COCOS2D_DEBUG</PreprocessorDefinitions>
       <MinimalRebuild>true</MinimalRebuild>
       <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
@@ -83,7 +83,8 @@
       <DisableSpecificWarnings>4996;4800;4267;4251;4244;%(DisableSpecificWarnings)</DisableSpecificWarnings>
     </ClCompile>
     <Lib>
-      <AdditionalLibraryDirectories>%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+      <AdditionalDependencies>libzlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
     </Lib>
     <PreLinkEvent>
       <Command>
@@ -93,6 +94,10 @@
       <Command>if not exist "$(OutDir)" mkdir "$(OutDir)"
 xcopy /Y /Q "$(ProjectDir)..\luajit\win32\*.*" "$(OutDir)"</Command>
     </PreBuildEvent>
+    <Link>
+      <AdditionalDependencies>libzlib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalLibraryDirectories>$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
     <ClCompile>
@@ -125,6 +130,9 @@ xcopy /Y /Q "$(ProjectDir)..\luajit\win32\*.*" "$(OutDir)"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClCompile Include="..\cjson\fpconv.c" />
+    <ClCompile Include="..\cjson\lua_cjson.c" />
+    <ClCompile Include="..\cjson\strbuf.c" />
     <ClCompile Include="..\cocos2dx_support\CCBProxy.cpp" />
     <ClCompile Include="..\cocos2dx_support\CCLuaBridge.cpp" />
     <ClCompile Include="..\cocos2dx_support\CCLuaEngine.cpp" />
@@ -140,6 +148,12 @@ xcopy /Y /Q "$(ProjectDir)..\luajit\win32\*.*" "$(OutDir)"</Command>
     <ClCompile Include="..\cocos2dx_support\Lua_extensions_CCB.cpp" />
     <ClCompile Include="..\cocos2dx_support\Lua_web_socket.cpp" />
     <ClCompile Include="..\cocos2dx_support\tolua_fix.c" />
+    <ClCompile Include="..\crypt\des56.c" />
+    <ClCompile Include="..\crypt\ldes56.c" />
+    <ClCompile Include="..\crypt\lua_zlib.c" />
+    <ClCompile Include="..\crypt\md5.c" />
+    <ClCompile Include="..\crypt\md5lib.c" />
+    <ClCompile Include="..\lfs\lfs.c" />
     <ClCompile Include="..\tolua\tolua_event.c" />
     <ClCompile Include="..\tolua\tolua_is.c" />
     <ClCompile Include="..\tolua\tolua_map.c" />
@@ -147,6 +161,9 @@ xcopy /Y /Q "$(ProjectDir)..\luajit\win32\*.*" "$(OutDir)"</Command>
     <ClCompile Include="..\tolua\tolua_to.c" />
   </ItemGroup>
   <ItemGroup>
+    <ClInclude Include="..\cjson\fpconv.h" />
+    <ClInclude Include="..\cjson\lua_cjson.h" />
+    <ClInclude Include="..\cjson\strbuf.h" />
     <ClInclude Include="..\cocos2dx_support\CCBProxy.h" />
     <ClInclude Include="..\cocos2dx_support\CCLuaBridge.h" />
     <ClInclude Include="..\cocos2dx_support\CCLuaEngine.h" />
@@ -162,6 +179,11 @@ xcopy /Y /Q "$(ProjectDir)..\luajit\win32\*.*" "$(OutDir)"</Command>
     <ClInclude Include="..\cocos2dx_support\Lua_extensions_CCB.h" />
     <ClInclude Include="..\cocos2dx_support\Lua_web_socket.h" />
     <ClInclude Include="..\cocos2dx_support\tolua_fix.h" />
+    <ClInclude Include="..\crypt\des56.h" />
+    <ClInclude Include="..\crypt\ldes56.h" />
+    <ClInclude Include="..\crypt\lua_zlib.h" />
+    <ClInclude Include="..\crypt\md5.h" />
+    <ClInclude Include="..\lfs\lfs.h" />
     <ClInclude Include="..\luajit\include\lauxlib.h" />
     <ClInclude Include="..\luajit\include\lua.h" />
     <ClInclude Include="..\luajit\include\luaconf.h" />
diff --git a/scripting/lua/proj.win32/liblua.vcxproj.filters b/scripting/lua/proj.win32/liblua.vcxproj.filters
index a9c1793..72aaad7 100644
--- a/scripting/lua/proj.win32/liblua.vcxproj.filters
+++ b/scripting/lua/proj.win32/liblua.vcxproj.filters
@@ -13,6 +13,15 @@
     <Filter Include="luajit\include">
       <UniqueIdentifier>{b7025611-420a-4414-b567-f7496eec5f57}</UniqueIdentifier>
     </Filter>
+    <Filter Include="crypt">
+      <UniqueIdentifier>{d9e016ec-f3f6-4bca-b2c1-4fd54ecb04ad}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="lfs">
+      <UniqueIdentifier>{286d8193-09cc-464f-bd6d-266675c56a1c}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="cjson">
+      <UniqueIdentifier>{f0f208d3-8b44-477b-8018-e913bcf0df6f}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
   <ItemGroup>
     <ClCompile Include="..\tolua\tolua_event.c">
@@ -75,6 +84,33 @@
     <ClCompile Include="..\cocos2dx_support\LuaCocos2dExtension.cpp">
       <Filter>cocos2dx_support</Filter>
     </ClCompile>
+    <ClCompile Include="..\crypt\des56.c">
+      <Filter>crypt</Filter>
+    </ClCompile>
+    <ClCompile Include="..\crypt\ldes56.c">
+      <Filter>crypt</Filter>
+    </ClCompile>
+    <ClCompile Include="..\crypt\md5.c">
+      <Filter>crypt</Filter>
+    </ClCompile>
+    <ClCompile Include="..\crypt\md5lib.c">
+      <Filter>crypt</Filter>
+    </ClCompile>
+    <ClCompile Include="..\lfs\lfs.c">
+      <Filter>lfs</Filter>
+    </ClCompile>
+    <ClCompile Include="..\crypt\lua_zlib.c">
+      <Filter>crypt</Filter>
+    </ClCompile>
+    <ClCompile Include="..\cjson\lua_cjson.c">
+      <Filter>cjson</Filter>
+    </ClCompile>
+    <ClCompile Include="..\cjson\strbuf.c">
+      <Filter>cjson</Filter>
+    </ClCompile>
+    <ClCompile Include="..\cjson\fpconv.c">
+      <Filter>cjson</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\tolua\tolua++.h">
@@ -140,5 +176,29 @@
     <ClInclude Include="..\cocos2dx_support\LuaCocos2dExtension.h">
       <Filter>cocos2dx_support</Filter>
     </ClInclude>
+    <ClInclude Include="..\crypt\des56.h">
+      <Filter>crypt</Filter>
+    </ClInclude>
+    <ClInclude Include="..\crypt\ldes56.h">
+      <Filter>crypt</Filter>
+    </ClInclude>
+    <ClInclude Include="..\crypt\md5.h">
+      <Filter>crypt</Filter>
+    </ClInclude>
+    <ClInclude Include="..\lfs\lfs.h">
+      <Filter>lfs</Filter>
+    </ClInclude>
+    <ClInclude Include="..\crypt\lua_zlib.h">
+      <Filter>crypt</Filter>
+    </ClInclude>
+    <ClInclude Include="..\cjson\lua_cjson.h">
+      <Filter>cjson</Filter>
+    </ClInclude>
+    <ClInclude Include="..\cjson\strbuf.h">
+      <Filter>cjson</Filter>
+    </ClInclude>
+    <ClInclude Include="..\cjson\fpconv.h">
+      <Filter>cjson</Filter>
+    </ClInclude>
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/scripting/lua/proj.win32/liblua.vcxproj.user b/scripting/lua/proj.win32/liblua.vcxproj.user
index 695b5c7..2c48fb5 100644
--- a/scripting/lua/proj.win32/liblua.vcxproj.user
+++ b/scripting/lua/proj.win32/liblua.vcxproj.user
@@ -1,3 +1,6 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
 <Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <ShowAllFiles>true</ShowAllFiles>
+  </PropertyGroup>
 </Project>
\ No newline at end of file
